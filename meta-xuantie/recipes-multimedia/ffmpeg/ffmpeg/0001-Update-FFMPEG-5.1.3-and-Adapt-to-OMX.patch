From ceb6531ec992e93e789c3bf66f6a51d61ac1f9af Mon Sep 17 00:00:00 2001
From: "yangtianyu.lu" <luyangtianyu.lyty@alibaba-inc.com>
Date: Mon, 20 Nov 2023 03:19:10 +0000
Subject: [PATCH] Update FFMPEG 5.1.3 and Adapt to OMX

---
 configure                   |    7 +
 libavcodec/Makefile         |    7 +
 libavcodec/allcodecs.c      |   14 +-
 libavcodec/omx.c            |  870 ++++++++++++----
 libavcodec/omxdecoder.c     | 1958 +++++++++++++++++++++++++++++++++++
 libavcodec/omxjpegdecoder.c | 1089 +++++++++++++++++++
 libavcodec/omxjpegencoder.c | 1203 +++++++++++++++++++++
 libavutil/Makefile          |    1 +
 libavutil/cpu.c             |    2 +-
 libavutil/hwcontext.h       |    1 +
 libavutil/hwcontext_omx.c   |   75 ++
 tests/api/Makefile          |    6 +-
 12 files changed, 5051 insertions(+), 182 deletions(-)
 create mode 100644 libavcodec/omxdecoder.c
 create mode 100644 libavcodec/omxjpegdecoder.c
 create mode 100644 libavcodec/omxjpegencoder.c
 create mode 100755 libavutil/hwcontext_omx.c

diff --git a/configure b/configure
index ba5793b..04de04a 100755
--- a/configure
+++ b/configure
@@ -3176,6 +3176,7 @@ h264_mmal_decoder_deps="mmal"
 h264_nvenc_encoder_deps="nvenc"
 h264_nvenc_encoder_select="atsc_a53"
 h264_omx_encoder_deps="omx"
+h264_omx_decoder_deps="omx"
 h264_qsv_decoder_select="h264_mp4toannexb_bsf qsvdec"
 h264_qsv_encoder_select="atsc_a53 qsvenc"
 h264_rkmpp_decoder_deps="rkmpp"
@@ -3192,6 +3193,8 @@ hevc_mediacodec_decoder_select="hevc_mp4toannexb_bsf hevc_parser"
 hevc_mf_encoder_deps="mediafoundation"
 hevc_nvenc_encoder_deps="nvenc"
 hevc_nvenc_encoder_select="atsc_a53"
+hevc_omx_encoder_deps="omx"
+hevc_omx_decoder_deps="omx"
 hevc_qsv_decoder_select="hevc_mp4toannexb_bsf qsvdec"
 hevc_qsv_encoder_select="hevcparse qsvenc"
 hevc_rkmpp_decoder_deps="rkmpp"
@@ -3201,6 +3204,8 @@ hevc_vaapi_encoder_select="cbs_h265 vaapi_encode"
 hevc_v4l2m2m_decoder_deps="v4l2_m2m hevc_v4l2_m2m"
 hevc_v4l2m2m_decoder_select="hevc_mp4toannexb_bsf"
 hevc_v4l2m2m_encoder_deps="v4l2_m2m hevc_v4l2_m2m"
+jpeg_omx_encoder_deps="omx"
+jpeg_omx_decoder_deps="omx"
 mjpeg_cuvid_decoder_deps="cuvid"
 mjpeg_qsv_decoder_select="qsvdec"
 mjpeg_qsv_encoder_deps="libmfx"
@@ -3223,6 +3228,7 @@ mpeg4_cuvid_decoder_deps="cuvid"
 mpeg4_mediacodec_decoder_deps="mediacodec"
 mpeg4_mmal_decoder_deps="mmal"
 mpeg4_omx_encoder_deps="omx"
+mpeg4_omx_decoder_deps="omx"
 mpeg4_v4l2m2m_decoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
 mpeg4_v4l2m2m_encoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
 msmpeg4_crystalhd_decoder_select="crystalhd"
@@ -3241,6 +3247,7 @@ vp8_v4l2m2m_decoder_deps="v4l2_m2m vp8_v4l2_m2m"
 vp8_v4l2m2m_encoder_deps="v4l2_m2m vp8_v4l2_m2m"
 vp9_cuvid_decoder_deps="cuvid"
 vp9_mediacodec_decoder_deps="mediacodec"
+vp9_omx_decoder_deps="omx"
 vp9_qsv_decoder_select="qsvdec"
 vp9_rkmpp_decoder_deps="rkmpp"
 vp9_vaapi_encoder_deps="VAEncPictureParameterBufferVP9"
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 457ec58..12f1412 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -391,6 +391,7 @@ OBJS-$(CONFIG_H264_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_H264_MF_ENCODER)         += mfenc.o mf_utils.o
 OBJS-$(CONFIG_H264_MMAL_DECODER)       += mmaldec.o
 OBJS-$(CONFIG_H264_NVENC_ENCODER)      += nvenc_h264.o nvenc.o
+OBJS-$(CONFIG_H264_OMX_DECODER)        += omxdecoder.o
 OBJS-$(CONFIG_H264_OMX_ENCODER)        += omx.o
 OBJS-$(CONFIG_H264_QSV_DECODER)        += qsvdec.o
 OBJS-$(CONFIG_H264_QSV_ENCODER)        += qsvenc_h264.o
@@ -412,6 +413,8 @@ OBJS-$(CONFIG_HEVC_CUVID_DECODER)      += cuviddec.o
 OBJS-$(CONFIG_HEVC_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_HEVC_MF_ENCODER)         += mfenc.o mf_utils.o
 OBJS-$(CONFIG_HEVC_NVENC_ENCODER)      += nvenc_hevc.o nvenc.o
+OBJS-$(CONFIG_HEVC_OMX_DECODER)        += omxdecoder.o
+OBJS-$(CONFIG_HEVC_OMX_ENCODER)        += omx.o
 OBJS-$(CONFIG_HEVC_QSV_DECODER)        += qsvdec.o
 OBJS-$(CONFIG_HEVC_QSV_ENCODER)        += qsvenc_hevc.o hevc_ps_enc.o       \
                                           hevc_data.o
@@ -449,6 +452,8 @@ OBJS-$(CONFIG_JPEG2000_DECODER)        += jpeg2000dec.o jpeg2000.o jpeg2000dsp.o
                                           jpeg2000dwt.o mqcdec.o mqc.o
 OBJS-$(CONFIG_JPEGLS_DECODER)          += jpeglsdec.o jpegls.o
 OBJS-$(CONFIG_JPEGLS_ENCODER)          += jpeglsenc.o jpegls.o
+OBJS-$(CONFIG_JPEG_OMX_DECODER)        += omxjpegdecoder.o
+OBJS-$(CONFIG_JPEG_OMX_ENCODER)        += omxjpegencoder.o
 OBJS-$(CONFIG_JV_DECODER)              += jvdec.o
 OBJS-$(CONFIG_KGV1_DECODER)            += kgv1dec.o
 OBJS-$(CONFIG_KMVC_DECODER)            += kmvc.o
@@ -519,6 +524,7 @@ OBJS-$(CONFIG_MPEG4_ENCODER)           += mpeg4videoenc.o
 OBJS-$(CONFIG_MPEG4_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MPEG4_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_MPEG4_OMX_ENCODER)       += omx.o
+OBJS-$(CONFIG_MPEG4_OMX_DECODER)       += omxdecoder.o
 OBJS-$(CONFIG_MPEG4_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
 OBJS-$(CONFIG_MPEG4_V4L2M2M_ENCODER)   += v4l2_m2m_enc.o
 OBJS-$(CONFIG_MPL2_DECODER)            += mpl2dec.o ass.o
@@ -752,6 +758,7 @@ OBJS-$(CONFIG_VP9_DECODER)             += vp9.o vp9data.o vp9dsp.o vp9lpf.o vp9r
                                           vp9dsp_8bpp.o vp9dsp_10bpp.o vp9dsp_12bpp.o
 OBJS-$(CONFIG_VP9_CUVID_DECODER)       += cuviddec.o
 OBJS-$(CONFIG_VP9_MEDIACODEC_DECODER)  += mediacodecdec.o
+OBJS-$(CONFIG_VP9_OMX_DECODER)         += omxdecoder.o
 OBJS-$(CONFIG_VP9_RKMPP_DECODER)       += rkmppdec.o
 OBJS-$(CONFIG_VP9_VAAPI_ENCODER)       += vaapi_encode_vp9.o
 OBJS-$(CONFIG_VP9_QSV_ENCODER)         += qsvenc_vp9.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index bdfc2f6..5a7db7f 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -33,6 +33,18 @@
 #include "codec.h"
 #include "codec_id.h"
 #include "codec_internal.h"
+#include "avcodec.h"
+#include "version.h"
+
+extern const FFCodec ff_vp9_omx_decoder;
+extern const FFCodec ff_hevc_omx_decoder;
+extern const FFCodec ff_hevc_omx_encoder;
+extern const FFCodec ff_h264_omx_decoder;
+extern const FFCodec ff_h264_omx_encoder;
+extern const FFCodec ff_jpeg_omx_encoder;
+extern const FFCodec ff_jpeg_omx_decoder;
+extern const FFCodec ff_mpeg4_omx_encoder;
+extern const FFCodec ff_mpeg4_omx_decoder;
 
 extern const FFCodec ff_a64multi_encoder;
 extern const FFCodec ff_a64multi5_encoder;
@@ -822,7 +834,6 @@ extern const FFCodec ff_h264_amf_encoder;
 extern const FFCodec ff_h264_cuvid_decoder;
 extern const FFCodec ff_h264_mf_encoder;
 extern const FFCodec ff_h264_nvenc_encoder;
-extern const FFCodec ff_h264_omx_encoder;
 extern const FFCodec ff_h264_qsv_encoder;
 extern const FFCodec ff_h264_v4l2m2m_encoder;
 extern const FFCodec ff_h264_vaapi_encoder;
@@ -848,7 +859,6 @@ extern const FFCodec ff_mpeg2_qsv_encoder;
 extern const FFCodec ff_mpeg2_vaapi_encoder;
 extern const FFCodec ff_mpeg4_cuvid_decoder;
 extern const FFCodec ff_mpeg4_mediacodec_decoder;
-extern const FFCodec ff_mpeg4_omx_encoder;
 extern const FFCodec ff_mpeg4_v4l2m2m_encoder;
 extern const FFCodec ff_prores_videotoolbox_encoder;
 extern const FFCodec ff_vc1_cuvid_decoder;
diff --git a/libavcodec/omx.c b/libavcodec/omx.c
index d481c06..9dafd18 100644
--- a/libavcodec/omx.c
+++ b/libavcodec/omx.c
@@ -32,6 +32,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/time.h>
+#include <fcntl.h>
+#include <sys/mman.h>
 
 #include "libavutil/avstring.h"
 #include "libavutil/avutil.h"
@@ -44,6 +46,10 @@
 #include "codec_internal.h"
 #include "h264.h"
 #include "pthread_internal.h"
+#include "encode.h"
+
+#include <omxil/OMX_CsiExt.h>
+int omx_load_count = 0;
 
 #ifdef OMX_SKIP64BIT
 static OMX_TICKS to_omx_ticks(int64_t value)
@@ -80,10 +86,10 @@ typedef struct OMXContext {
     OMX_ERRORTYPE (*ptr_Init)(void);
     OMX_ERRORTYPE (*ptr_Deinit)(void);
     OMX_ERRORTYPE (*ptr_ComponentNameEnum)(OMX_STRING, OMX_U32, OMX_U32);
-    OMX_ERRORTYPE (*ptr_GetHandle)(OMX_HANDLETYPE*, OMX_STRING, OMX_PTR, OMX_CALLBACKTYPE*);
+    OMX_ERRORTYPE (*ptr_GetHandle)(OMX_HANDLETYPE *, OMX_STRING, OMX_PTR, OMX_CALLBACKTYPE *);
     OMX_ERRORTYPE (*ptr_FreeHandle)(OMX_HANDLETYPE);
-    OMX_ERRORTYPE (*ptr_GetComponentsOfRole)(OMX_STRING, OMX_U32*, OMX_U8**);
-    OMX_ERRORTYPE (*ptr_GetRolesOfComponent)(OMX_STRING, OMX_U32*, OMX_U8**);
+    OMX_ERRORTYPE (*ptr_GetComponentsOfRole)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    OMX_ERRORTYPE (*ptr_GetRolesOfComponent)(OMX_STRING, OMX_U32 *, OMX_U8 **);
     void (*host_init)(void);
 } OMXContext;
 
@@ -144,6 +150,7 @@ static av_cold OMXContext *omx_init(void *logctx, const char *libname, const cha
 #if CONFIG_OMX_RPI
         "/opt/vc/lib/libopenmaxil.so", "/opt/vc/lib/libbcm_host.so",
 #else
+        "libomxil-bellagio.so.0", NULL,
         "libOMX_Core.so", NULL,
         "libOmxCore.so", NULL,
 #endif
@@ -152,7 +159,7 @@ static av_cold OMXContext *omx_init(void *logctx, const char *libname, const cha
     const char* const* nameptr;
     int ret = AVERROR_ENCODER_NOT_FOUND;
     OMXContext *omx_context;
-
+    OMX_ERRORTYPE error;
     omx_context = av_mallocz(sizeof(*omx_context));
     if (!omx_context)
         return NULL;
@@ -174,7 +181,14 @@ static av_cold OMXContext *omx_init(void *logctx, const char *libname, const cha
 
     if (omx_context->host_init)
         omx_context->host_init();
-    omx_context->ptr_Init();
+    av_log(NULL, AV_LOG_INFO, "OMX_count load %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        error = omx_context->ptr_Init();
+        if (error != OMX_ErrorNone) {
+            av_log(NULL, AV_LOG_WARNING, "OMX Init error\n");
+        }
+    }
+    omx_load_count++;
     return omx_context;
 }
 
@@ -182,8 +196,12 @@ static av_cold void omx_deinit(OMXContext *omx_context)
 {
     if (!omx_context)
         return;
-    omx_context->ptr_Deinit();
-    dlclose(omx_context->lib);
+    omx_load_count--;
+    av_log(NULL, AV_LOG_INFO, "OMX_count %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        omx_context->ptr_Deinit();
+        dlclose(omx_context->lib);
+    }
     av_free(omx_context);
 }
 
@@ -228,13 +246,234 @@ typedef struct OMXCodecContext {
 
     int input_zerocopy;
     int profile;
+    int level;
+    int bitrate;
+    int QpI;
+    int QpP;
+    int gop_size;
+    int dts_now;
+    int dts_duration;
+    int pts_pre;
+    int stride_padding;
 } OMXCodecContext;
 
-#define NB_MUTEX_CONDS 6
-#define OFF(field) offsetof(OMXCodecContext, field)
-DEFINE_OFFSET_ARRAY(OMXCodecContext, omx_codec_context, mutex_cond_inited_cnt,
-                    (OFF(input_mutex), OFF(output_mutex), OFF(state_mutex)),
-                    (OFF(input_cond),  OFF(output_cond),  OFF(state_cond)));
+
+
+static void say(OMXCodecContext *s, const char *message, ...)
+{
+    va_list args;
+    size_t str_len;
+    char str[1024];
+    memset(str, 0, sizeof(str));
+    va_start(args, message);
+    vsnprintf(str, sizeof(str) - 1, message, args);
+    va_end(args);
+    str_len = strlen(str);
+    if (str[str_len - 1] != '\n') {
+        str[str_len] = '\n';
+    }
+
+    av_log(s->avctx, AV_LOG_INFO, "%s", str);
+}
+
+
+static const char *dump_compression_format(OMXCodecContext *s, OMX_VIDEO_CODINGTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_VIDEO_CodingUnused:
+        return "not used";
+    case OMX_VIDEO_CodingAutoDetect:
+        return "autodetect";
+    case OMX_VIDEO_CodingMPEG2:
+        return "MPEG2";
+    case OMX_VIDEO_CodingH263:
+        return "H.263";
+    case OMX_VIDEO_CodingMPEG4:
+        return "MPEG4";
+    case OMX_VIDEO_CodingWMV:
+        return "Windows Media Video";
+    case OMX_VIDEO_CodingRV:
+        return "RealVideo";
+    case OMX_VIDEO_CodingAVC:
+        return "H.264/AVC";
+    case OMX_VIDEO_CodingMJPEG:
+        return "Motion JPEG";
+//        case OMX_VIDEO_CodingTheora:     return "OGG Theora";
+
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f, "format type 0x%08x", c);
+        return f;//maybe memleak
+    }
+}
+
+static const char *dump_color_format(OMXCodecContext *s, OMX_COLOR_FORMATTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_COLOR_FormatUnused:
+        return "OMX_COLOR_FormatUnused: not used";
+    case OMX_COLOR_FormatMonochrome:
+        return "OMX_COLOR_FormatMonochrome";
+    case OMX_COLOR_Format8bitRGB332:
+        return "OMX_COLOR_Format8bitRGB332";
+    case OMX_COLOR_Format12bitRGB444:
+        return "OMX_COLOR_Format12bitRGB444";
+    case OMX_COLOR_Format16bitARGB4444:
+        return "OMX_COLOR_Format16bitARGB4444";
+    case OMX_COLOR_Format16bitARGB1555:
+        return "OMX_COLOR_Format16bitARGB1555";
+    case OMX_COLOR_Format16bitRGB565:
+        return "OMX_COLOR_Format16bitRGB565";
+    case OMX_COLOR_Format16bitBGR565:
+        return "OMX_COLOR_Format16bitBGR565";
+    case OMX_COLOR_Format18bitRGB666:
+        return "OMX_COLOR_Format18bitRGB666";
+    case OMX_COLOR_Format18bitARGB1665:
+        return "OMX_COLOR_Format18bitARGB1665";
+    case OMX_COLOR_Format19bitARGB1666:
+        return "OMX_COLOR_Format19bitARGB1666";
+    case OMX_COLOR_Format24bitRGB888:
+        return "OMX_COLOR_Format24bitRGB888";
+    case OMX_COLOR_Format24bitBGR888:
+        return "OMX_COLOR_Format24bitBGR888";
+    case OMX_COLOR_Format24bitARGB1887:
+        return "OMX_COLOR_Format24bitARGB1887";
+    case OMX_COLOR_Format25bitARGB1888:
+        return "OMX_COLOR_Format25bitARGB1888";
+    case OMX_COLOR_Format32bitBGRA8888:
+        return "OMX_COLOR_Format32bitBGRA8888";
+    case OMX_COLOR_Format32bitARGB8888:
+        return "OMX_COLOR_Format32bitARGB8888";
+    case OMX_COLOR_FormatYUV411Planar:
+        return "OMX_COLOR_FormatYUV411Planar";
+    case OMX_COLOR_FormatYUV411PackedPlanar:
+        return "OMX_COLOR_FormatYUV411PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420Planar:
+        return "OMX_COLOR_FormatYUV420Planar: Planar YUV, 4:2:0 (I420)";
+    case OMX_COLOR_FormatYUV420PackedPlanar:
+        return "OMX_COLOR_FormatYUV420PackedPlanar: Planar YUV, 4:2:0 (I420), planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420SemiPlanar:
+        return "OMX_COLOR_FormatYUV420SemiPlanar, Planar YUV, 4:2:0 (NV12), U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422Planar:
+        return "OMX_COLOR_FormatYUV422Planar";
+    case OMX_COLOR_FormatYUV422PackedPlanar:
+        return "OMX_COLOR_FormatYUV422PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV422SemiPlanar:
+        return "OMX_COLOR_FormatYUV422SemiPlanar";
+    case OMX_COLOR_FormatYCbYCr:
+        return "OMX_COLOR_FormatYCbYCr";
+    case OMX_COLOR_FormatYCrYCb:
+        return "OMX_COLOR_FormatYCrYCb";
+    case OMX_COLOR_FormatCbYCrY:
+        return "OMX_COLOR_FormatCbYCrY";
+    case OMX_COLOR_FormatCrYCbY:
+        return "OMX_COLOR_FormatCrYCbY";
+    case OMX_COLOR_FormatYUV444Interleaved:
+        return "OMX_COLOR_FormatYUV444Interleaved";
+    case OMX_COLOR_FormatRawBayer8bit:
+        return "OMX_COLOR_FormatRawBayer8bit";
+    case OMX_COLOR_FormatRawBayer10bit:
+        return "OMX_COLOR_FormatRawBayer10bit";
+    case OMX_COLOR_FormatRawBayer8bitcompressed:
+        return "OMX_COLOR_FormatRawBayer8bitcompressed";
+    case OMX_COLOR_FormatL2:
+        return "OMX_COLOR_FormatL2";
+    case OMX_COLOR_FormatL4:
+        return "OMX_COLOR_FormatL4";
+    case OMX_COLOR_FormatL8:
+        return "OMX_COLOR_FormatL8";
+    case OMX_COLOR_FormatL16:
+        return "OMX_COLOR_FormatL16";
+    case OMX_COLOR_FormatL24:
+        return "OMX_COLOR_FormatL24";
+    case OMX_COLOR_FormatL32:
+        return "OMX_COLOR_FormatL32";
+    case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV420PackedSemiPlanar: Planar YUV, 4:2:0 (NV12), planes fragmented when a frame is split in multiple buffers, U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV422PackedSemiPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_Format18BitBGR666:
+        return "OMX_COLOR_Format18BitBGR666";
+    case OMX_COLOR_Format24BitARGB6666:
+        return "OMX_COLOR_Format24BitARGB6666";
+    case OMX_COLOR_Format24BitABGR6666:
+        return "OMX_COLOR_Format24BitABGR6666";
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f,  "format type 0x%08x", c);
+        return f;
+    }
+}
+
+static void dump_portdef(OMXCodecContext *s, OMX_PARAM_PORTDEFINITIONTYPE *portdef)
+{
+    OMX_VIDEO_PORTDEFINITIONTYPE *viddef = &portdef->format.video;
+    OMX_IMAGE_PORTDEFINITIONTYPE *imgdef = &portdef->format.image;
+
+    say(s, "Port %d is %s, %s, buffers wants:%d needs:%d, size:%d, pop:%d, aligned:%d",
+        portdef->nPortIndex,
+        (portdef->eDir ==  OMX_DirInput ? "input" : "output"),
+        (portdef->bEnabled == OMX_TRUE ? "enabled" : "disabled"),
+        portdef->nBufferCountActual,
+        portdef->nBufferCountMin,
+        portdef->nBufferSize,
+        portdef->bPopulated,
+        portdef->nBufferAlignment);
+
+
+    switch (portdef->eDomain) {
+    case OMX_PortDomainVideo:
+        say(s, "Video type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tBitrate:\t%d\n"
+            "\tFramerate:\t%.02f\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            viddef->nFrameWidth,
+            viddef->nFrameHeight,
+            viddef->nStride,
+            viddef->nSliceHeight,
+            viddef->nBitrate,
+            ((float)viddef->xFramerate / (float)65536),
+            (viddef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, viddef->eCompressionFormat),
+            dump_color_format(s, viddef->eColorFormat));
+        break;
+    case OMX_PortDomainImage:
+        say(s, "Image type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            imgdef->nFrameWidth,
+            imgdef->nFrameHeight,
+            imgdef->nStride,
+            imgdef->nSliceHeight,
+            (imgdef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, imgdef->eCompressionFormat),
+            dump_color_format(s, imgdef->eColorFormat));
+        break;
+    default:
+        break;
+    }
+}
 
 static void append_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
                           int* array_size, OMX_BUFFERHEADERTYPE **array,
@@ -295,7 +534,7 @@ static OMX_ERRORTYPE event_handler(OMX_HANDLETYPE component, OMX_PTR app_data, O
             av_log(s->avctx, AV_LOG_VERBOSE, "OMX port %"PRIu32" enabled\n", (uint32_t) data2);
         } else {
             av_log(s->avctx, AV_LOG_VERBOSE, "OMX command complete, command %"PRIu32", value %"PRIu32"\n",
-                                             (uint32_t) data1, (uint32_t) data2);
+                   (uint32_t) data1, (uint32_t) data2);
         }
         break;
     case OMX_EventPortSettingsChanged:
@@ -399,6 +638,8 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
     OMX_PARAM_PORTDEFINITIONTYPE in_port_params = { 0 }, out_port_params = { 0 };
     OMX_VIDEO_PARAM_PORTFORMATTYPE video_port_format = { 0 };
     OMX_VIDEO_PARAM_BITRATETYPE vid_param_bitrate = { 0 };
+    OMX_VIDEO_PARAM_QUANTIZATIONTYPE vid_param_quantization = { 0 };
+    OMX_CSI_BUFFER_MODE_CONFIGTYPE bufferMode = {0};
     OMX_ERRORTYPE err;
     int i;
 
@@ -418,6 +659,10 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
     // Intentionally ignore errors on this one
     OMX_SetParameter(s->handle, OMX_IndexParamStandardComponentRole, &role_params);
 
+    s->dts_duration = avctx->pkt_timebase.den;
+    s->dts_now = 0;
+    s->pts_pre = -1;
+
     INIT_STRUCT(video_port_params);
     err = OMX_GetParameter(s->handle, OMX_IndexParamVideoInit, &video_port_params);
     CHECK(err);
@@ -446,32 +691,19 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
         return AVERROR_UNKNOWN;
     }
 
-    s->color_format = 0;
-    for (i = 0; ; i++) {
-        INIT_STRUCT(video_port_format);
-        video_port_format.nIndex = i;
-        video_port_format.nPortIndex = s->in_port;
-        if (OMX_GetParameter(s->handle, OMX_IndexParamVideoPortFormat, &video_port_format) != OMX_ErrorNone)
-            break;
-        if (video_port_format.eColorFormat == OMX_COLOR_FormatYUV420Planar ||
-            video_port_format.eColorFormat == OMX_COLOR_FormatYUV420PackedPlanar) {
-            s->color_format = video_port_format.eColorFormat;
-            break;
-        }
-    }
-    if (s->color_format == 0) {
-        av_log(avctx, AV_LOG_ERROR, "No supported pixel formats (%d formats available)\n", i);
-        return AVERROR_UNKNOWN;
-    }
+    s->color_format = OMX_COLOR_FormatYUV420SemiPlanar;
 
     in_port_params.bEnabled   = OMX_TRUE;
     in_port_params.bPopulated = OMX_FALSE;
     in_port_params.eDomain    = OMX_PortDomainVideo;
+    in_port_params.nBufferAlignment = 64;
 
     in_port_params.format.video.pNativeRender         = NULL;
     in_port_params.format.video.bFlagErrorConcealment = OMX_FALSE;
     in_port_params.format.video.eColorFormat          = s->color_format;
-    s->stride     = avctx->width;
+
+    s->stride = (avctx->width / 64 * 64) < avctx->width ? ((avctx->width / 64 + 1) * 64) : avctx->width;
+    s->stride_padding = s->stride - avctx->width;
     s->plane_size = avctx->height;
     // If specific codecs need to manually override the stride/plane_size,
     // that can be done here.
@@ -501,27 +733,49 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
     out_port_params.format.video.nFrameHeight  = avctx->height;
     out_port_params.format.video.nStride       = 0;
     out_port_params.format.video.nSliceHeight  = 0;
-    out_port_params.format.video.nBitrate      = avctx->bit_rate;
+    out_port_params.format.video.nBitrate      = s->bitrate ? s->bitrate : avctx->bit_rate;
     out_port_params.format.video.xFramerate    = in_port_params.format.video.xFramerate;
     out_port_params.format.video.bFlagErrorConcealment  = OMX_FALSE;
     if (avctx->codec->id == AV_CODEC_ID_MPEG4)
         out_port_params.format.video.eCompressionFormat = OMX_VIDEO_CodingMPEG4;
     else if (avctx->codec->id == AV_CODEC_ID_H264)
         out_port_params.format.video.eCompressionFormat = OMX_VIDEO_CodingAVC;
+    else if (avctx->codec->id == AV_CODEC_ID_HEVC)
+        out_port_params.format.video.eCompressionFormat = OMX_CSI_VIDEO_CodingHEVC;
 
     err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
     CHECK(err);
     err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
     CHECK(err);
+    dump_portdef(s, &in_port_params);
+    dump_portdef(s, &out_port_params);
+
     s->num_out_buffers = out_port_params.nBufferCountActual;
 
+    //bitrate control
     INIT_STRUCT(vid_param_bitrate);
     vid_param_bitrate.nPortIndex     = s->out_port;
     vid_param_bitrate.eControlRate   = OMX_Video_ControlRateVariable;
-    vid_param_bitrate.nTargetBitrate = avctx->bit_rate;
+    vid_param_bitrate.nTargetBitrate = s->bitrate ? s->bitrate : avctx->bit_rate;
+    //vid_param_bitrate.eControlRate = OMX_Video_ControlRateDisable;
     err = OMX_SetParameter(s->handle, OMX_IndexParamVideoBitrate, &vid_param_bitrate);
     if (err != OMX_ErrorNone)
         av_log(avctx, AV_LOG_WARNING, "Unable to set video bitrate parameter\n");
+    else
+        av_log(avctx, AV_LOG_INFO, "Target Bitrate Setted: %d\n", vid_param_bitrate.nTargetBitrate);
+
+    //quantization control
+    INIT_STRUCT(vid_param_quantization);
+    vid_param_quantization.nPortIndex = s->out_port;
+    vid_param_quantization.nQpI = s->QpI;
+    vid_param_quantization.nQpP = s->QpP;
+    vid_param_quantization.nQpB = 0; //not used
+    err = OMX_SetParameter(s->handle, OMX_IndexParamVideoQuantization, &vid_param_quantization);
+    if (err != OMX_ErrorNone)
+        av_log(avctx, AV_LOG_WARNING, "Unable to set video quantization parameter\n");
+    else
+        av_log(avctx, AV_LOG_INFO, "Qp for I frames: %d, Qp for P frames: %d\n", vid_param_quantization.nQpI,
+               vid_param_quantization.nQpP);
 
     if (avctx->codec->id == AV_CODEC_ID_H264) {
         OMX_VIDEO_PARAM_AVCTYPE avc = { 0 };
@@ -530,31 +784,196 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
         err = OMX_GetParameter(s->handle, OMX_IndexParamVideoAvc, &avc);
         CHECK(err);
         avc.nBFrames = 0;
-        avc.nPFrames = avctx->gop_size - 1;
+        avc.nPFrames = (s->gop_size) ? (s->gop_size - 1) : (avctx->gop_size - 1);
+        s->gop_size = avc.nPFrames + 1;
+        avc.eProfile = OMX_VIDEO_AVCProfileMain;
+        avc.eLevel = OMX_VIDEO_AVCLevel42;
         switch (s->profile == FF_PROFILE_UNKNOWN ? avctx->profile : s->profile) {
         case FF_PROFILE_H264_BASELINE:
             avc.eProfile = OMX_VIDEO_AVCProfileBaseline;
+            avc.bEntropyCodingCABAC = 0;
+            avc.eLevel = OMX_VIDEO_AVCLevel3;
+            av_log(avctx, AV_LOG_INFO, "Profile Baseline\n");
             break;
         case FF_PROFILE_H264_MAIN:
             avc.eProfile = OMX_VIDEO_AVCProfileMain;
+            avc.eLevel = OMX_VIDEO_AVCLevel42;
+            av_log(avctx, AV_LOG_INFO, "Profile Main\n");
             break;
         case FF_PROFILE_H264_HIGH:
             avc.eProfile = OMX_VIDEO_AVCProfileHigh;
+            avc.eLevel = OMX_VIDEO_AVCLevel51;
+            av_log(avctx, AV_LOG_INFO, "Profile High\n");
             break;
         default:
+            av_log(avctx, AV_LOG_INFO, "Profile Main\n");
+            break;
+        }
+        if (s->level != FF_LEVEL_UNKNOWN) {
+            avc.eLevel = s->level;
+        }
+        switch (avc.eLevel) {
+        case OMX_VIDEO_AVCLevel1:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel1\n");
+            break;
+        case OMX_VIDEO_AVCLevel1b:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel1b\n");
+            break;
+        case OMX_VIDEO_AVCLevel11:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel11\n");
+            break;
+        case OMX_VIDEO_AVCLevel12:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel12\n");
+            break;
+        case OMX_VIDEO_AVCLevel13:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel13\n");
+            break;
+        case OMX_VIDEO_AVCLevel2:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel2\n");
+            break;
+        case OMX_VIDEO_AVCLevel21:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel21\n");
+            break;
+        case OMX_VIDEO_AVCLevel22:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel22\n");
+            break;
+        case OMX_VIDEO_AVCLevel3:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel3\n");
+            break;
+        case OMX_VIDEO_AVCLevel31:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel31\n");
+            break;
+        case OMX_VIDEO_AVCLevel32:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel32\n");
+            break;
+        case OMX_VIDEO_AVCLevel4:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel4\n");
+            break;
+        case OMX_VIDEO_AVCLevel41:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel41\n");
+            break;
+        case OMX_VIDEO_AVCLevel42:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel42\n");
+            break;
+        case OMX_VIDEO_AVCLevel5:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel5\n");
             break;
+        case OMX_VIDEO_AVCLevel51:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel51\n");
+            break;
+        default:
+            av_log(avctx, AV_LOG_ERROR, "[Error] OMX VIDEO AVCLevel\n");
+            return AVERROR_UNKNOWN;
         }
         err = OMX_SetParameter(s->handle, OMX_IndexParamVideoAvc, &avc);
         CHECK(err);
+        err = OMX_GetParameter(s->handle, OMX_IndexParamVideoAvc, &avc);
+        CHECK(err);
+        if (avc.nPFrames)
+            av_log(avctx, AV_LOG_INFO, "1 I frame and %d P frame(s) in a gop\n", avc.nPFrames);
+        else
+            av_log(avctx, AV_LOG_INFO, "All intra coding\n");
+    } else if (avctx->codec->id == AV_CODEC_ID_HEVC) {
+        OMX_CSI_VIDEO_PARAM_HEVCTYPE hevc = { 0 };
+        INIT_STRUCT(hevc);
+        hevc.nPortIndex = s->out_port;
+        err = OMX_GetParameter(s->handle, OMX_CSI_IndexParamVideoHevc, &hevc);
+        CHECK(err);
+        hevc.nPFrames = (s->gop_size) ? (s->gop_size - 1) : (avctx->gop_size - 1);
+        s->gop_size = hevc.nPFrames + 1;
+        hevc.eLevel = OMX_CSI_VIDEO_HEVCLevel51;
+        hevc.eProfile = OMX_CSI_VIDEO_HEVCProfileMain;
+        switch (s->profile == FF_PROFILE_UNKNOWN ? avctx->profile : s->profile) {
+        case FF_PROFILE_HEVC_MAIN:
+            av_log(avctx, AV_LOG_INFO, "Profile Main\n");
+            hevc.eProfile = OMX_CSI_VIDEO_HEVCProfileMain;
+            hevc.eLevel = OMX_CSI_VIDEO_HEVCLevel51;
+            break;
+        case FF_PROFILE_HEVC_MAIN_10:
+            av_log(avctx, AV_LOG_INFO, "Profile Main 10\n");
+            hevc.eProfile = OMX_CSI_VIDEO_HEVCProfileMain10;
+            hevc.eLevel = OMX_CSI_VIDEO_HEVCLevel51;
+            break;
+        default:
+            av_log(avctx, AV_LOG_INFO, "Profile Main\n");
+            break;
+        }
+        if (s->level != FF_LEVEL_UNKNOWN) {
+            hevc.eLevel = s->level;
+        }
+        switch (hevc.eLevel) {
+        case OMX_CSI_VIDEO_HEVCLevel1:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel1\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel2:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel2\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel21:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel21\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel3:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel3\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel31:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel31\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel4:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel4\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel41:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel41\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel5:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel5\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel51:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel51\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel52:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel52\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel6:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel6\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel61:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel61\n");
+            break;
+        case OMX_CSI_VIDEO_HEVCLevel62:
+            av_log(avctx, AV_LOG_INFO, "OMX_CSI_VIDEO_HEVCLevel62\n");
+            break;
+        default:
+            av_log(avctx, AV_LOG_ERROR, "[ERROR] OMX_CSI_VIDEO_HEVCLevel\n");
+            return AVERROR_UNKNOWN;
+        }
+
+        err = OMX_SetParameter(s->handle, OMX_CSI_IndexParamVideoHevc, &hevc);
+        CHECK(err);
+        err = OMX_GetParameter(s->handle, OMX_CSI_IndexParamVideoHevc, &hevc);
+        CHECK(err);
+        if (hevc.nPFrames)
+            av_log(avctx, AV_LOG_INFO, "1 I frame and %d P frame(s) in a gop\n", hevc.nPFrames);
+        else
+            av_log(avctx, AV_LOG_INFO, "All intra coding\n");
+    }
+    if (s->input_zerocopy) {
+        INIT_STRUCT(bufferMode);
+        bufferMode.nPortIndex = s->in_port;
+        bufferMode.eMode = OMX_CSI_BUFFER_MODE_DMA;
+        err = OMX_SetParameter(s->handle, OMX_CSI_IndexParamBufferMode, &bufferMode);
+        if (err != OMX_ErrorNone) {
+            av_log(avctx, AV_LOG_ERROR, "Unable to set DMA mode at port %d\n", s->in_port);
+            return AVERROR_UNKNOWN;
+        } else
+            av_log(avctx, AV_LOG_INFO, "Set DMA mode at port %d\n", s->in_port);
     }
 
     err = OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
     CHECK(err);
 
-    s->in_buffer_headers  = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE*) * s->num_in_buffers);
-    s->free_in_buffers    = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE*) * s->num_in_buffers);
-    s->out_buffer_headers = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE*) * s->num_out_buffers);
-    s->done_out_buffers   = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE*) * s->num_out_buffers);
+    s->in_buffer_headers  = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_in_buffers);
+    s->free_in_buffers    = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_in_buffers);
+    s->out_buffer_headers = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+    s->done_out_buffers   = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
     if (!s->in_buffer_headers || !s->free_in_buffers || !s->out_buffer_headers || !s->done_out_buffers)
         return AVERROR(ENOMEM);
     for (i = 0; i < s->num_in_buffers && err == OMX_ErrorNone; i++) {
@@ -589,6 +1008,7 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
         for (; i < s->num_out_buffers; i++)
             s->done_out_buffers[s->num_done_out_buffers++] = s->out_buffer_headers[i];
     }
+
     for (i = 0; i < s->num_in_buffers; i++)
         s->free_in_buffers[s->num_free_in_buffers++] = s->in_buffer_headers[i];
     return err != OMX_ErrorNone ? AVERROR_UNKNOWN : 0;
@@ -596,47 +1016,50 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
 
 static av_cold void cleanup(OMXCodecContext *s)
 {
-    int executing;
-
-    /* If the mutexes/condition variables have not been properly initialized,
-     * nothing has been initialized and locking the mutex might be unsafe. */
-    if (s->mutex_cond_inited_cnt == NB_MUTEX_CONDS) {
-        pthread_mutex_lock(&s->state_mutex);
-        executing = s->state == OMX_StateExecuting;
-        pthread_mutex_unlock(&s->state_mutex);
+    int i, executing;
+    av_log(s->avctx, AV_LOG_INFO, "OMX Cleanup\n");
+    pthread_mutex_lock(&s->state_mutex);
+    executing = s->state == OMX_StateExecuting;
+    pthread_mutex_unlock(&s->state_mutex);
 
-        if (executing) {
-            OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
-            wait_for_state(s, OMX_StateIdle);
-            OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateLoaded, NULL);
-            for (int i = 0; i < s->num_in_buffers; i++) {
-                OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->input_mutex, &s->input_cond,
-                                                        &s->num_free_in_buffers, s->free_in_buffers, 1);
-                if (s->input_zerocopy)
-                    buffer->pBuffer = NULL;
-                OMX_FreeBuffer(s->handle, s->in_port, buffer);
-            }
-            for (int i = 0; i < s->num_out_buffers; i++) {
-                OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->output_mutex, &s->output_cond,
-                                                        &s->num_done_out_buffers, s->done_out_buffers, 1);
-                OMX_FreeBuffer(s->handle, s->out_port, buffer);
-            }
-            wait_for_state(s, OMX_StateLoaded);
+    if (executing) {
+        OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
+        wait_for_state(s, OMX_StateIdle);
+        OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateLoaded, NULL);
+        for (i = 0; i < s->num_in_buffers; i++) {
+            OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                                           &s->num_free_in_buffers, s->free_in_buffers, 1);
+            if (s->input_zerocopy)
+                buffer->pBuffer = NULL;
+            OMX_FreeBuffer(s->handle, s->in_port, buffer);
         }
-        if (s->handle) {
-            s->omx_context->ptr_FreeHandle(s->handle);
-            s->handle = NULL;
+        for (i = 0; i < s->num_out_buffers; i++) {
+            OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                                           &s->num_done_out_buffers, s->done_out_buffers, 1);
+            OMX_FreeBuffer(s->handle, s->out_port, buffer);
         }
-
-        omx_deinit(s->omx_context);
-        s->omx_context = NULL;
-        av_freep(&s->in_buffer_headers);
-        av_freep(&s->out_buffer_headers);
-        av_freep(&s->free_in_buffers);
-        av_freep(&s->done_out_buffers);
-        av_freep(&s->output_buf);
+        wait_for_state(s, OMX_StateLoaded);
+    }
+    if (s->handle) {
+        s->omx_context->ptr_FreeHandle(s->handle);
+        s->handle = NULL;
     }
-    ff_pthread_free(s, omx_codec_context_offsets);
+    omx_deinit(s->omx_context);
+    s->omx_context = NULL;
+    if (s->mutex_cond_inited_cnt) {
+        pthread_cond_destroy(&s->state_cond);
+        pthread_mutex_destroy(&s->state_mutex);
+        pthread_cond_destroy(&s->input_cond);
+        pthread_mutex_destroy(&s->input_mutex);
+        pthread_cond_destroy(&s->output_cond);
+        pthread_mutex_destroy(&s->output_mutex);
+        s->mutex_cond_inited_cnt = 0;
+    }
+    av_freep(&s->in_buffer_headers);
+    av_freep(&s->out_buffer_headers);
+    av_freep(&s->free_in_buffers);
+    av_freep(&s->done_out_buffers);
+    av_freep(&s->output_buf);
 }
 
 static av_cold int omx_encode_init(AVCodecContext *avctx)
@@ -647,14 +1070,17 @@ static av_cold int omx_encode_init(AVCodecContext *avctx)
     OMX_BUFFERHEADERTYPE *buffer;
     OMX_ERRORTYPE err;
 
-    /* cleanup relies on the mutexes/conditions being initialized first. */
-    ret = ff_pthread_init(s, omx_codec_context_offsets);
-    if (ret < 0)
-        return ret;
     s->omx_context = omx_init(avctx, s->libname, s->libprefix);
     if (!s->omx_context)
         return AVERROR_ENCODER_NOT_FOUND;
 
+    pthread_mutex_init(&s->state_mutex, NULL);
+    pthread_cond_init(&s->state_cond, NULL);
+    pthread_mutex_init(&s->input_mutex, NULL);
+    pthread_cond_init(&s->input_cond, NULL);
+    pthread_mutex_init(&s->output_mutex, NULL);
+    pthread_cond_init(&s->output_cond, NULL);
+    s->mutex_cond_inited_cnt = 1;
     s->avctx = avctx;
     s->state = OMX_StateLoaded;
     s->error = OMX_ErrorNone;
@@ -666,6 +1092,9 @@ static av_cold int omx_encode_init(AVCodecContext *avctx)
     case AV_CODEC_ID_H264:
         role = "video_encoder.avc";
         break;
+    case AV_CODEC_ID_HEVC:
+        role = "video_encoder.hevc";
+        break;
     default:
         return AVERROR(ENOSYS);
     }
@@ -677,13 +1106,14 @@ static av_cold int omx_encode_init(AVCodecContext *avctx)
 
     if ((ret = omx_component_init(avctx, role)) < 0)
         goto fail;
-
+#if 0
     if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
         while (1) {
             buffer = get_buffer(&s->output_mutex, &s->output_cond,
                                 &s->num_done_out_buffers, s->done_out_buffers, 1);
             if (buffer->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
-                if ((ret = av_reallocp(&avctx->extradata, avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
+                if ((ret = av_reallocp(&avctx->extradata,
+                                       avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
                     avctx->extradata_size = 0;
                     goto fail;
                 }
@@ -706,12 +1136,12 @@ static av_cold int omx_encode_init(AVCodecContext *avctx)
                 int nals[32] = { 0 };
                 int i;
                 for (i = 0; i + 4 < avctx->extradata_size; i++) {
-                     if (!avctx->extradata[i + 0] &&
-                         !avctx->extradata[i + 1] &&
-                         !avctx->extradata[i + 2] &&
-                         avctx->extradata[i + 3] == 1) {
-                         nals[avctx->extradata[i + 4] & 0x1f]++;
-                     }
+                    if (!avctx->extradata[i + 0] &&
+                        !avctx->extradata[i + 1] &&
+                        !avctx->extradata[i + 2] &&
+                        avctx->extradata[i + 3] == 1) {
+                        nals[avctx->extradata[i + 4] & 0x1f]++;
+                    }
                 }
                 if (nals[H264_NAL_SPS] && nals[H264_NAL_PPS])
                     break;
@@ -721,12 +1151,25 @@ static av_cold int omx_encode_init(AVCodecContext *avctx)
             }
         }
     }
+#endif
 
     return 0;
 fail:
     return ret;
 }
 
+static int omx_line_copy(AVCodecContext *avctx, const AVFrame *frame, uint8_t *address)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    memset(address, 0, s->stride * frame->height * 3 / 2);
+    for (int i = 0; i < frame->height; i++) {
+        memcpy(address + i * s->stride, frame->data[0] + i * frame->width, frame->width);
+    }
+    for (int i = 0; i < frame->height / 2; i++) {
+        memcpy(address + s->stride * frame->height + i * s->stride, frame->data[1] + +i * frame->width, frame->width);
+    }
+    return 0;
+}
 
 static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                             const AVFrame *frame, int *got_packet)
@@ -736,6 +1179,7 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     OMX_BUFFERHEADERTYPE* buffer;
     OMX_ERRORTYPE err;
     int had_partial = 0;
+    struct timespec abs_time;
 
     if (frame) {
         uint8_t *dst[4];
@@ -744,56 +1188,25 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         buffer = get_buffer(&s->input_mutex, &s->input_cond,
                             &s->num_free_in_buffers, s->free_in_buffers, 1);
 
-        buffer->nFilledLen = av_image_fill_arrays(dst, linesize, buffer->pBuffer, avctx->pix_fmt, s->stride, s->plane_size, 1);
-
-        if (s->input_zerocopy) {
-            uint8_t *src[4] = { NULL };
-            int src_linesize[4];
-            av_image_fill_arrays(src, src_linesize, frame->data[0], avctx->pix_fmt, s->stride, s->plane_size, 1);
-            if (frame->linesize[0] == src_linesize[0] &&
-                frame->linesize[1] == src_linesize[1] &&
-                frame->linesize[2] == src_linesize[2] &&
-                frame->data[1] == src[1] &&
-                frame->data[2] == src[2]) {
-                // If the input frame happens to have all planes stored contiguously,
-                // with the right strides, just clone the frame and set the OMX
-                // buffer header to point to it
+        buffer->nFilledLen = s->stride * frame->height * 3 / 2;
+        buffer->nAllocLen = buffer->nFilledLen;
+
+        if (s->stride_padding == 0) {
+            if (s->input_zerocopy) {
                 AVFrame *local = av_frame_clone(frame);
-                if (!local) {
-                    // Return the buffer to the queue so it's not lost
-                    append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
-                    return AVERROR(ENOMEM);
-                } else {
-                    buffer->pAppPrivate = local;
-                    buffer->pOutputPortPrivate = NULL;
-                    buffer->pBuffer = local->data[0];
-                    need_copy = 0;
-                }
+                buffer->pAppPrivate = local;
+                buffer->pOutputPortPrivate = NULL;
+                buffer->pBuffer = ((OMX_BUFFERHEADERTYPE *)(local->opaque))->pBuffer;
             } else {
-                // If not, we need to allocate a new buffer with the right
-                // size and copy the input frame into it.
-                uint8_t *buf = NULL;
-                int image_buffer_size = av_image_get_buffer_size(avctx->pix_fmt, s->stride, s->plane_size, 1);
-                if (image_buffer_size >= 0)
-                    buf = av_malloc(image_buffer_size);
-                if (!buf) {
-                    // Return the buffer to the queue so it's not lost
-                    append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
-                    return AVERROR(ENOMEM);
-                } else {
-                    buffer->pAppPrivate = buf;
-                    // Mark that pAppPrivate is an av_malloc'ed buffer, not an AVFrame
-                    buffer->pOutputPortPrivate = (void*) 1;
-                    buffer->pBuffer = buf;
-                    need_copy = 1;
-                    buffer->nFilledLen = av_image_fill_arrays(dst, linesize, buffer->pBuffer, avctx->pix_fmt, s->stride, s->plane_size, 1);
-                }
+                memcpy(buffer->pBuffer, frame->data[0], frame->height * frame->width);
+                memcpy(buffer->pBuffer + frame->height * frame->width, frame->data[1], frame->height * frame->width / 2);
             }
+        } else if (s->stride_padding > 0) {
+            omx_line_copy(avctx, frame, buffer->pBuffer);
         } else {
-            need_copy = 1;
+            av_log(avctx, AV_LOG_ERROR, "error stride padding size: %d\n", s->stride_padding);
+            return AVERROR_UNKNOWN;
         }
-        if (need_copy)
-            av_image_copy(dst, linesize, (const uint8_t**) frame->data, frame->linesize, avctx->pix_fmt, avctx->width, avctx->height);
         buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;
         buffer->nOffset = 0;
         // Convert the timestamps to microseconds; some encoders can ignore
@@ -807,6 +1220,7 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
             err = OMX_SetConfig(s->handle, OMX_IndexConfigBrcmVideoRequestIFrame, &config);
             if (err != OMX_ErrorNone) {
                 av_log(avctx, AV_LOG_ERROR, "OMX_SetConfig(RequestIFrame) failed: %x\n", err);
+                return AVERROR_UNKNOWN;
             }
 #else
             OMX_CONFIG_INTRAREFRESHVOPTYPE config = {0, };
@@ -816,6 +1230,7 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
             err = OMX_SetConfig(s->handle, OMX_IndexConfigVideoIntraVOPRefresh, &config);
             if (err != OMX_ErrorNone) {
                 av_log(avctx, AV_LOG_ERROR, "OMX_SetConfig(IntraVOPRefresh) failed: %x\n", err);
+                return AVERROR_UNKNOWN;
             }
 #endif
         }
@@ -845,6 +1260,13 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         // If not flushing, just poll the queue if there's finished packets.
         // If flushing, do a blocking wait until we either get a completed
         // packet, or get EOS.
+        if (s->num_done_out_buffers == 0) {
+            pthread_mutex_lock(&s->output_mutex);
+            clock_gettime(CLOCK_REALTIME, &abs_time);
+            abs_time.tv_sec += 3; // 3s
+            pthread_cond_timedwait(&s->output_cond, &s->output_mutex, &abs_time);
+            pthread_mutex_unlock(&s->output_mutex);
+        }
         buffer = get_buffer(&s->output_mutex, &s->output_cond,
                             &s->num_done_out_buffers, s->done_out_buffers,
                             !frame || had_partial);
@@ -854,8 +1276,9 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         if (buffer->nFlags & OMX_BUFFERFLAG_EOS)
             s->got_eos = 1;
 
-        if (buffer->nFlags & OMX_BUFFERFLAG_CODECCONFIG && avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
-            if ((ret = av_reallocp(&avctx->extradata, avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
+        if (buffer->nFlags & OMX_BUFFERFLAG_CODECCONFIG && avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER && 0) {
+            if ((ret = av_reallocp(&avctx->extradata,
+                                   avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
                 avctx->extradata_size = 0;
                 goto end;
             }
@@ -863,34 +1286,51 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
             avctx->extradata_size += buffer->nFilledLen;
             memset(avctx->extradata + avctx->extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
         } else {
-            int newsize = s->output_buf_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE;
-            if ((ret = av_reallocp(&s->output_buf, newsize)) < 0) {
-                s->output_buf_size = 0;
-                goto end;
-            }
-            memcpy(s->output_buf + s->output_buf_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
-            s->output_buf_size += buffer->nFilledLen;
-            if (buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) {
-                memset(s->output_buf + s->output_buf_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
-                if ((ret = av_packet_from_data(pkt, s->output_buf, s->output_buf_size)) < 0) {
-                    av_freep(&s->output_buf);
+            if (!(buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) || !pkt->data) {
+                // If the output packet isn't preallocated, just concatenate everything in our
+                // own buffer
+                int newsize = s->output_buf_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE;
+                if ((ret = av_reallocp(&s->output_buf, newsize)) < 0) {
                     s->output_buf_size = 0;
                     goto end;
                 }
-                s->output_buf = NULL;
+                memcpy(s->output_buf + s->output_buf_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
+                s->output_buf_size += buffer->nFilledLen;
+                if (buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) {
+                    if ((ret = av_packet_from_data(pkt, s->output_buf, s->output_buf_size)) < 0) {
+                        av_freep(&s->output_buf);
+                        s->output_buf_size = 0;
+                        goto end;
+                    }
+                    s->output_buf = NULL;
+                    s->output_buf_size = 0;
+                }
+#if CONFIG_OMX_RPI
+                had_partial = 1;
+#endif
+            } else {
+                // End of frame, and the caller provided a preallocated frame
+                if ((ret = ff_alloc_packet(avctx, pkt, s->output_buf_size + buffer->nFilledLen)) < 0) {
+                    av_log(avctx, AV_LOG_ERROR, "Error getting output packet of size %d.\n",
+                           (int)(s->output_buf_size + buffer->nFilledLen));
+                    goto end;
+                }
+                memcpy(pkt->data, s->output_buf, s->output_buf_size);
+                memcpy(pkt->data + s->output_buf_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
+                av_freep(&s->output_buf);
                 s->output_buf_size = 0;
+            }
+            if (buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) {
                 pkt->pts = av_rescale_q(from_omx_ticks(buffer->nTimeStamp), AV_TIME_BASE_Q, avctx->time_base);
-                // We don't currently enable B-frames for the encoders, so set
-                // pkt->dts = pkt->pts. (The calling code behaves worse if the encoder
-                // doesn't set the dts).
-                pkt->dts = pkt->pts;
+                if (pkt->pts != s->pts_pre + s->dts_duration) {
+                    pkt->pts = s->pts_pre + s->dts_duration;
+                }
+                s->pts_pre = pkt->pts;
+                pkt->dts = s->dts_now;
+                s->dts_now += s->dts_duration;
                 if (buffer->nFlags & OMX_BUFFERFLAG_SYNCFRAME)
                     pkt->flags |= AV_PKT_FLAG_KEY;
                 *got_packet = 1;
-            } else {
-#if CONFIG_OMX_RPI
-                had_partial = 1;
-#endif
             }
         }
 end:
@@ -907,7 +1347,6 @@ end:
 static av_cold int omx_encode_end(AVCodecContext *avctx)
 {
     OMXCodecContext *s = avctx->priv_data;
-
     cleanup(s);
     return 0;
 }
@@ -919,17 +1358,67 @@ static const AVOption options[] = {
     { "omx_libname", "OpenMAX library name", OFFSET(libname), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
     { "omx_libprefix", "OpenMAX library prefix", OFFSET(libprefix), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
     { "zerocopy", "Try to avoid copying input frames if possible", OFFSET(input_zerocopy), AV_OPT_TYPE_INT, { .i64 = CONFIG_OMX_RPI }, 0, 1, VE },
+    { "gop_size",  "Set the encoding gop_size", OFFSET(gop_size), AV_OPT_TYPE_INT,   { .i64 = 12 }, 0, OMX_VIDEO_AVCLevelMax, VE, "gop_size" },
+    { "bitrate",  "Set the encoding bitrate", OFFSET(bitrate), AV_OPT_TYPE_INT,   { .i64 = 10000000 }, 0, OMX_VIDEO_AVCLevelMax, VE, "bitrate" },
+    { "QpI",  "Set the encoding Qp for I frames", OFFSET(QpI), AV_OPT_TYPE_INT,   { .i64 = 27 }, 0, 51, VE, "QpI" },
+    { "QpP",  "Set the encoding Qp for P frames", OFFSET(QpP), AV_OPT_TYPE_INT,   { .i64 = 27 }, 0, 51, VE, "QpP" },
+    { "profile",  "Set the encoding profile", OFFSET(profile), AV_OPT_TYPE_INT,   { .i64 = FF_PROFILE_UNKNOWN },       FF_PROFILE_UNKNOWN, FF_PROFILE_H264_HIGH, VE, "profile" },
+    { "baseline",    "",                      0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_BASELINE }, 0, 0, VE, "profile" },
+    { "main",        "",                      0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_MAIN },     0, 0, VE, "profile" },
+    { "high",        "",                      0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_HIGH },     0, 0, VE, "profile" },
+    { "level",  "Set the encoding level", OFFSET(level), AV_OPT_TYPE_INT,   { .i64 = FF_LEVEL_UNKNOWN},       FF_LEVEL_UNKNOWN, OMX_VIDEO_AVCLevelMax, VE, "level" },
+    { "level1",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel1 },      0, 0, VE, "level" },
+    { "level1b",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel1b},      0, 0, VE, "level" },
+    { "level11",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel11 },     0, 0, VE, "level" },
+    { "level12",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel12 },     0, 0, VE, "level" },
+    { "level13",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel13 },     0, 0, VE, "level" },
+    { "level2",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel2},       0, 0, VE, "level" },
+    { "level21",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel21 },     0, 0, VE, "level" },
+    { "level22",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel22 },     0, 0, VE, "level" },
+    { "level3",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel3},       0, 0, VE, "level" },
+    { "level31",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel31 },     0, 0, VE, "level" },
+    { "level32",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel32 },     0, 0, VE, "level" },
+    { "level4",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel4},       0, 0, VE, "level" },
+    { "level41",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel41 },     0, 0, VE, "level" },
+    { "level42",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel42 },     0, 0, VE, "level" },
+    { "level5",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel5},       0, 0, VE, "level" },
+    { "level51",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel51 },     0, 0, VE, "level" },
+    { NULL }
+};
+
+static const AVOption options_hevc[] = {
+    { "omx_libname", "OpenMAX library name", OFFSET(libname), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
+    { "omx_libprefix", "OpenMAX library prefix", OFFSET(libprefix), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
+    { "zerocopy", "Try to avoid copying input frames if possible", OFFSET(input_zerocopy), AV_OPT_TYPE_INT, { .i64 = CONFIG_OMX_RPI }, 0, 1, VE },
+    { "gop_size",  "Set the encoding gop_size", OFFSET(gop_size), AV_OPT_TYPE_INT,   { .i64 = 12 }, 0, OMX_VIDEO_AVCLevelMax, VE, "gop_size" },
+    { "bitrate",  "Set the encoding bitrate", OFFSET(bitrate), AV_OPT_TYPE_INT,   { .i64 = 10000000 }, 0, OMX_VIDEO_AVCLevelMax, VE, "bitrate" },
+    { "QpI",  "Set the encoding Qp for I frames", OFFSET(QpI), AV_OPT_TYPE_INT,   { .i64 = 27 }, 0, 51, VE, "QpI" },
+    { "QpP",  "Set the encoding Qp for P frames", OFFSET(QpP), AV_OPT_TYPE_INT,   { .i64 = 27 }, 0, 51, VE, "QpP" },
     { "profile",  "Set the encoding profile", OFFSET(profile), AV_OPT_TYPE_INT,   { .i64 = FF_PROFILE_UNKNOWN },       FF_PROFILE_UNKNOWN, FF_PROFILE_H264_HIGH, VE, "profile" },
-    { "baseline", "",                         0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_BASELINE }, 0, 0, VE, "profile" },
-    { "main",     "",                         0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_MAIN },     0, 0, VE, "profile" },
-    { "high",     "",                         0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_HIGH },     0, 0, VE, "profile" },
+    { "main",        "",                      0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_HEVC_MAIN },     0, 0, VE, "profile" },
+    { "main10",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_HEVC_MAIN_10 },  0, 0, VE, "profile" },
+    { "level",  "Set the encoding level", OFFSET(level), AV_OPT_TYPE_INT,   { .i64 = FF_LEVEL_UNKNOWN},       FF_LEVEL_UNKNOWN, 0xFFFFFFFF, VE, "level" },
+    { "level1",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel1 },     0, 0, VE, "level" },
+    { "level2",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel2},      0, 0, VE, "level" },
+    { "level21",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel21 },    0, 0, VE, "level" },
+    { "level3",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel3 },     0, 0, VE, "level" },
+    { "level31",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel31 },    0, 0, VE, "level" },
+    { "level4",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel4},      0, 0, VE, "level" },
+    { "level41",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel41 },    0, 0, VE, "level" },
+    { "level5",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel5 },     0, 0, VE, "level" },
+    { "level51",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel51},     0, 0, VE, "level" },
+    { "level52",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel52 },    0, 0, VE, "level" },
+    { "level6",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel6 },     0, 0, VE, "level" },
+    { "level61",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel61},     0, 0, VE, "level" },
+    { "level62",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_CSI_VIDEO_HEVCLevel62 },    0, 0, VE, "level" },
     { NULL }
 };
 
 static const enum AVPixelFormat omx_encoder_pix_fmts[] = {
-    AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE
+    AV_PIX_FMT_NV12, AV_PIX_FMT_NONE
 };
 
+// #ifdef MPEG4_OMX
 static const AVClass omx_mpeg4enc_class = {
     .class_name = "mpeg4_omx",
     .item_name  = av_default_item_name,
@@ -937,19 +1426,20 @@ static const AVClass omx_mpeg4enc_class = {
     .version    = LIBAVUTIL_VERSION_INT,
 };
 const FFCodec ff_mpeg4_omx_encoder = {
-    .p.name           = "mpeg4_omx",
-    .p.long_name      = NULL_IF_CONFIG_SMALL("OpenMAX IL MPEG-4 video encoder"),
-    .p.type           = AVMEDIA_TYPE_VIDEO,
-    .p.id             = AV_CODEC_ID_MPEG4,
-    .priv_data_size   = sizeof(OMXCodecContext),
-    .init             = omx_encode_init,
+    .p.name             = "mpeg4_omx",
+    .p.long_name        = NULL_IF_CONFIG_SMALL("OpenMAX IL MPEG-4 video encoder"),
+    .p.type             = AVMEDIA_TYPE_VIDEO,
+    .p.id               = AV_CODEC_ID_MPEG4,
+    .priv_data_size     = sizeof(OMXCodecContext),
+    .init               = omx_encode_init,
     FF_CODEC_ENCODE_CB(omx_encode_frame),
-    .close            = omx_encode_end,
-    .p.pix_fmts       = omx_encoder_pix_fmts,
-    .p.capabilities   = AV_CODEC_CAP_DELAY,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
-    .p.priv_class     = &omx_mpeg4enc_class,
+    .close              = omx_encode_end,
+    .p.pix_fmts         = omx_encoder_pix_fmts,
+    .p.capabilities     = AV_CODEC_CAP_DELAY,
+    .caps_internal      = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .p.priv_class       = &omx_mpeg4enc_class,
 };
+// #endif
 
 static const AVClass omx_h264enc_class = {
     .class_name = "h264_omx",
@@ -958,16 +1448,42 @@ static const AVClass omx_h264enc_class = {
     .version    = LIBAVUTIL_VERSION_INT,
 };
 const FFCodec ff_h264_omx_encoder = {
-    .p.name           = "h264_omx",
-    .p.long_name      = NULL_IF_CONFIG_SMALL("OpenMAX IL H.264 video encoder"),
-    .p.type           = AVMEDIA_TYPE_VIDEO,
-    .p.id             = AV_CODEC_ID_H264,
+    .p.name             = "h264_omx",
+    .p.long_name        = NULL_IF_CONFIG_SMALL("OpenMAX IL H.264 video encoder"),
+    .p.type             = AVMEDIA_TYPE_VIDEO,
+    .p.id               = AV_CODEC_ID_H264,
+    .priv_data_size     = sizeof(OMXCodecContext),
+    .init               = omx_encode_init,
+    FF_CODEC_ENCODE_CB(omx_encode_frame),
+    .close              = omx_encode_end,
+    .p.pix_fmts         = omx_encoder_pix_fmts,
+    .p.capabilities     = AV_CODEC_CAP_DELAY,
+    .caps_internal      = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .p.priv_class       = &omx_h264enc_class,
+};
+
+
+static const AVClass omx_hevcenc_class = {
+    .class_name = "hevc_omx",
+    .item_name  = av_default_item_name,
+    .option     = options_hevc,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+const FFCodec ff_hevc_omx_encoder = {
+    .p.name             = "hevc_omx",
+    .p.long_name        = NULL_IF_CONFIG_SMALL("OpenMAX IL HEVC video encoder"),
+    .p.type             = AVMEDIA_TYPE_VIDEO,
+    .p.id               = AV_CODEC_ID_HEVC,
     .priv_data_size   = sizeof(OMXCodecContext),
     .init             = omx_encode_init,
     FF_CODEC_ENCODE_CB(omx_encode_frame),
     .close            = omx_encode_end,
-    .p.pix_fmts       = omx_encoder_pix_fmts,
-    .p.capabilities   = AV_CODEC_CAP_DELAY,
+    .p.pix_fmts         = omx_encoder_pix_fmts,
+    .p.capabilities     = AV_CODEC_CAP_DELAY,
     .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
-    .p.priv_class     = &omx_h264enc_class,
+    .p.priv_class       = &omx_hevcenc_class,
 };
+
+
+
diff --git a/libavcodec/omxdecoder.c b/libavcodec/omxdecoder.c
new file mode 100644
index 0000000..60edda8
--- /dev/null
+++ b/libavcodec/omxdecoder.c
@@ -0,0 +1,1958 @@
+/*decoders
+*
+* Copyright (c) 2023-2024 Huazhu Sun <sunhuazhu@coocaa.com>
+* Copyright (c) 2023-2024 Kaiyuan Dong <dongkaiyuan.dky@alibaba-inc.com>
+*
+* This file is part of FFmpeg.
+*
+* FFmpeg is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* FFmpeg is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with FFmpeg; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include "config.h"
+#include <dlfcn.h>
+#include <OMX_Core.h>
+#include <OMX_Component.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <stdint.h>
+#include <stdatomic.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <sys/ipc.h>
+#include <sys/msg.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+
+#include <pthread.h>
+
+#include "libavutil/avstring.h"
+#include "libavutil/avutil.h"
+#include "libavutil/common.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/log.h"
+#include "libavutil/opt.h"
+#include "libavutil/avassert.h"
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/pixfmt.h"
+#include "libavutil/internal.h"
+#include <libavutil/pixdesc.h>
+#include "libavutil/time.h"
+#include <libavutil/thread.h>
+
+#include "pthread_internal.h"
+#include "avcodec.h"
+#include "decode.h"
+#include "h264_parse.h"
+#include "h264_ps.h"
+#include "hevc_parse.h"
+#include "hwconfig.h"
+#include "internal.h"
+#include "codec_internal.h"
+
+#include "h264.h"
+#include "libswscale/swscale.h"
+
+#define CSI_OMX_SUPPORT
+#ifdef CSI_OMX_SUPPORT
+#include <omxil/OMX_CsiExt.h>
+#endif
+
+// #include "vsi_vendor_ext.h"
+extern int omx_load_count;
+#define kNumPictureBuffers 6
+#define MAX_TABLE_SIZE 100
+
+#ifdef c920v
+#define __riscv
+#define __riscv_vector
+#include "riscv_vector.h"
+#endif
+typedef enum __DecoderStatus {
+    INITIALIZING,
+    RESETTING,
+    DESTROYING,
+    ERRORING,
+    PortSettingFinished,
+    ILLEGAL_STATE
+} DecoderStatus;
+
+
+#define to_omx_ticks(x) (x)
+#define from_omx_ticks(x) (x)
+
+
+#define INIT_STRUCT(x) do {                                               \
+        x.nSize = sizeof(x);                                              \
+        x.nVersion = s->version;                                          \
+    } while (0)
+#define CHECK(x) do {                                                     \
+        if (x != OMX_ErrorNone) {                                         \
+            av_log(avctx, AV_LOG_ERROR,                                   \
+                   "err %x (%d) on line %d\n", x, x, __LINE__);           \
+            return AVERROR_UNKNOWN;                                       \
+        }                                                                 \
+    } while (0)
+
+typedef struct OMXContext {
+    void *lib;
+    void *lib2;
+    OMX_ERRORTYPE(*ptr_Init)(void);
+    OMX_ERRORTYPE(*ptr_Deinit)(void);
+    OMX_ERRORTYPE(*ptr_ComponentNameEnum)(OMX_STRING, OMX_U32, OMX_U32);
+    OMX_ERRORTYPE(*ptr_GetHandle)(OMX_HANDLETYPE *, OMX_STRING, OMX_PTR, OMX_CALLBACKTYPE *);
+    OMX_ERRORTYPE(*ptr_FreeHandle)(OMX_HANDLETYPE);
+    OMX_ERRORTYPE(*ptr_GetComponentsOfRole)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    OMX_ERRORTYPE(*ptr_GetRolesOfComponent)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    void (*host_init)(void);
+} OMXContext;
+
+static av_cold void *dlsym_prefixed(void *handle, const char *symbol, const char *prefix)
+{
+    char buf[50];
+    snprintf(buf, sizeof(buf), "%s%s", prefix ? prefix : "", symbol);
+    return dlsym(handle, buf);
+}
+
+static av_cold int omx_try_load(OMXContext *s, void *logctx,
+                                const char *libname, const char *prefix,
+                                const char *libname2)
+{
+    av_log(logctx, AV_LOG_WARNING, "omx init libname %s\n", libname);
+
+    s->lib = dlopen(libname, RTLD_NOW | RTLD_GLOBAL);
+    if (!s->lib) {
+        av_log(logctx, AV_LOG_WARNING, "%s not found\n", libname);
+        return AVERROR_DECODER_NOT_FOUND;
+    }
+    s->ptr_Init                = dlsym_prefixed(s->lib, "OMX_Init", prefix);
+    s->ptr_Deinit              = dlsym_prefixed(s->lib, "OMX_Deinit", prefix);
+    s->ptr_ComponentNameEnum   = dlsym_prefixed(s->lib, "OMX_ComponentNameEnum", prefix);
+    s->ptr_GetHandle           = dlsym_prefixed(s->lib, "OMX_GetHandle", prefix);
+    s->ptr_FreeHandle          = dlsym_prefixed(s->lib, "OMX_FreeHandle", prefix);
+    s->ptr_GetComponentsOfRole = dlsym_prefixed(s->lib, "OMX_GetComponentsOfRole", prefix);
+    s->ptr_GetRolesOfComponent = dlsym_prefixed(s->lib, "OMX_GetRolesOfComponent", prefix);
+
+    if (!s->ptr_Init || !s->ptr_Deinit || !s->ptr_ComponentNameEnum ||
+        !s->ptr_GetHandle || !s->ptr_FreeHandle ||
+        !s->ptr_GetComponentsOfRole || !s->ptr_GetRolesOfComponent) {
+        av_log(logctx, AV_LOG_WARNING, "Not all functions found in %s\n", libname);
+        dlclose(s->lib);
+        s->lib = NULL;
+        if (s->lib2)
+            dlclose(s->lib2);
+        s->lib2 = NULL;
+        return AVERROR_DECODER_NOT_FOUND;
+    }
+    return 0;
+}
+
+
+static int print_omx_env(OMXContext *omx_context)
+{
+    OMX_ERRORTYPE err;
+    OMX_U32 numComps = 0;
+    OMX_U8 component[OMX_MAX_STRINGNAME_SIZE];
+    OMX_U8 **roleList;
+
+    if (omx_context == NULL) {
+        //omx_env unready
+        return 0;
+    }
+
+    if (omx_context->ptr_ComponentNameEnum == NULL) {
+        //ptr_ComponentNameEnum unready
+        return 0;
+
+    }
+    numComps = 0;
+    while (err == OMX_ErrorNone) {
+        err = omx_context->ptr_ComponentNameEnum(component, OMX_MAX_STRINGNAME_SIZE, numComps);
+        if (err == OMX_ErrorNone) {
+            OMX_U32 numberofroles = 0;
+            omx_context->ptr_GetRolesOfComponent(component, &numberofroles, NULL);
+
+            if (numberofroles == 1) {
+                roleList = av_mallocz(numberofroles * sizeof(OMX_U8 *));
+                roleList[0] =  malloc(OMX_MAX_STRINGNAME_SIZE);
+                omx_context->ptr_GetRolesOfComponent(component, &numberofroles, roleList);
+                av_free(roleList[0]);
+                av_free(roleList);
+            }
+        }
+        numComps++;
+    }
+    return 0;
+}
+
+static av_cold OMXContext *omx_init(void *logctx, const char *libname, const char *prefix)
+{
+    static const char *const libnames[] = {
+#if 0
+        "/opt/vc/lib/libopenmaxil.so", "/opt/vc/lib/libbcm_host.so",
+#else
+        "libomxil-bellagio.so.0", NULL,
+        "libOMX_Core.so", NULL,
+        "libOmxCore.so", NULL,
+#endif
+        NULL
+    };
+    const char *const *nameptr;
+    int ret = AVERROR_DECODER_NOT_FOUND;
+    OMXContext *omx_context;
+    OMX_ERRORTYPE error;
+    omx_context = av_mallocz(sizeof(*omx_context));
+    if (!omx_context)
+        return NULL;
+    if (libname) {
+
+        ret = omx_try_load(omx_context, logctx, libname, prefix, NULL);
+        if (ret < 0) {
+            av_free(omx_context);
+            return NULL;
+        }
+    } else {
+        for (nameptr = libnames; *nameptr; nameptr += 2)
+            if (!(ret = omx_try_load(omx_context, logctx, nameptr[0], prefix, nameptr[1])))
+                break;
+        if (!*nameptr) {
+            av_free(omx_context);
+            return NULL;
+        }
+    }
+
+    if (omx_context->host_init)
+        omx_context->host_init();
+    av_log(NULL, AV_LOG_WARNING, "OMX_count load %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        error = omx_context->ptr_Init();
+        if (error != OMX_ErrorNone) {
+            av_log(NULL, AV_LOG_WARNING, "OMX Init error\n");
+        }
+    }
+    omx_load_count++;
+    print_omx_env(omx_context);
+    return omx_context;
+}
+
+static av_cold void omx_deinit(OMXContext *omx_context)
+{
+    if (!omx_context)
+        return;
+    omx_load_count--;
+    av_log(NULL, AV_LOG_WARNING, "OMX_count %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        omx_context->ptr_Deinit();
+        dlclose(omx_context->lib);
+    }
+    av_free(omx_context);
+}
+
+typedef struct outport_buffer_table {
+    OMX_BUFFERHEADERTYPE *buffer;
+    int fd;
+    uint8_t *vir_address;
+} outport_buffer_table;
+
+typedef struct OMXCodecDecoderContext {
+    const AVClass *class;
+    char *libname;
+    char *libprefix;
+    OMXContext *omx_context;
+
+    AVCodecContext *avctx;
+    //OmxCodecDecContext *ctx;
+
+    char component_name[OMX_MAX_STRINGNAME_SIZE];
+    OMX_VERSIONTYPE version;
+    OMX_HANDLETYPE handle;
+    int in_port, out_port;
+    //OMX_COLOR_FORMATTYPE color_format;
+    int stride, plane_size;
+
+    int num_in_buffers, num_out_buffers;
+    int in_buffer_size, out_buffer_size;
+    OMX_BUFFERHEADERTYPE **in_buffer_headers;
+    OMX_BUFFERHEADERTYPE **out_buffer_headers;
+    int num_free_in_buffers;
+    OMX_BUFFERHEADERTYPE **free_in_buffers;
+    int num_done_out_buffers;
+    OMX_BUFFERHEADERTYPE **done_out_buffers;
+    pthread_mutex_t input_mutex;
+    pthread_cond_t input_cond;
+
+    pthread_mutex_t output_mutex;
+    pthread_cond_t output_cond;
+
+    pthread_mutex_t state_mutex;
+    pthread_cond_t state_cond;
+
+    pthread_mutex_t eof_mutex;
+    pthread_cond_t eof_cond;
+
+    pthread_mutex_t buffer_control_mutex;
+    pthread_cond_t buffer_control_cond;
+
+    pthread_mutex_t free_mutex;
+
+    OMX_STATETYPE state;
+    OMX_ERRORTYPE error;
+
+    bool mutex_cond_inited;
+
+    int eos_sent, got_eos, draining, need_sendeos, eos_reach;
+
+    int input_zerocopy;
+    int profile;
+    //for receiving frame
+    int flushing;
+    int flush_count;
+    
+    int delay_flush;
+    int fast_render;
+    int mirror;
+    int rotation;/*0 ~3 means 0 90 180 270 degree*/
+    char *crop_expr;
+    char *resize_expr;
+    struct {
+        int left;
+        int top;
+        int right;
+        int bottom;
+    } crop;
+
+    struct {
+        int width;
+        int height;
+    } resize;
+
+    atomic_int serial;
+    int first_pkt;
+    int pkt_sent_num;
+    int pkt_upper_bound;
+    AVPacket buffered_pkt;
+    int out_stride, out_slice_height;
+    int crop_top, crop_left;
+
+    int format_changed;
+    int input_count;
+    int output_count;
+    int render_count;
+    DecoderStatus status;
+    pthread_t input_tid;
+    pthread_t output_tid;
+    //AVThread *thread_out;
+    int portSettingidle;
+    int reconfigPending;
+    int outport_disabled;
+    int pkt_full;
+    int now_pts;
+    int pkt_duration;
+    int resolution_changed;
+    int output_width;
+    int output_height;
+    OMX_COLOR_FORMATTYPE outformat;
+    outport_buffer_table buffer_table[MAX_TABLE_SIZE];
+    //AsyncQueue *pic_queue;
+} OMXCodecDecoderContext;
+
+static uint8_t *find_save_vir_address(OMXCodecDecoderContext *s, OMX_BUFFERHEADERTYPE *buffer, int size, bool with_save)
+{
+    for (int i = 0; i < s->num_out_buffers * 2; i++) {
+        if (s->buffer_table[i].buffer == buffer) {
+            if (s->buffer_table[i].vir_address)
+                return s->buffer_table[i].vir_address;
+        }
+    }
+    if (!with_save) {
+        return NULL;
+    }
+    for (int i = 0; i < s->num_out_buffers * 2; i++) {
+        if (s->buffer_table[i].buffer == NULL) {
+            s->buffer_table[i].buffer = buffer;
+            s->buffer_table[i].vir_address = mmap(NULL, size, PROT_READ, MAP_PRIVATE, buffer->pBuffer, 0);
+            return s->buffer_table[i].vir_address;
+        }
+    }
+    return NULL;
+}
+
+#define OFF(field) offsetof(OMXCodecDecoderContext, field)
+
+static void append_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
+                          int *array_size, OMX_BUFFERHEADERTYPE **array,
+                          OMX_BUFFERHEADERTYPE *buffer)
+{
+    pthread_mutex_lock(mutex);
+    array[(*array_size)++] = buffer;
+    pthread_cond_broadcast(cond);
+    pthread_mutex_unlock(mutex);
+}
+
+/*0 ,return imediately, -1 wait buffer return, else such as 100, mean timeout is 100ms */
+static OMX_BUFFERHEADERTYPE *get_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
+                                        int *array_size, OMX_BUFFERHEADERTYPE ***array,
+                                        int wait)
+{
+    OMX_BUFFERHEADERTYPE *buffer;
+    pthread_mutex_lock(mutex);
+    if (wait) {
+        while (!*array_size)
+            pthread_cond_wait(cond, mutex);
+    }
+    if (*array_size > 0) {
+        buffer = *array[0];
+        (*array_size)--;
+        memmove(&(*array)[0], &(*array)[1], (*array_size) * sizeof(OMX_BUFFERHEADERTYPE *));
+    } else {
+        buffer = NULL;
+    }
+    pthread_mutex_unlock(mutex);
+    return buffer;
+}
+
+static void checkstate(OMXCodecDecoderContext *s, OMX_U32 state)
+{
+    switch (state) {
+    case OMX_StateMax:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StateMax\n");
+        break;
+    case OMX_StateLoaded:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StateLoaded\n");
+        break;
+    case OMX_StateIdle:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StateIdle\n");
+        break;
+    case OMX_StateExecuting:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StateExecuting\n");
+        break;
+    case OMX_StatePause:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StatePause\n");
+        break;
+    case OMX_StateWaitForResources:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StateWaitForResources\n");
+        break;
+    }
+}
+
+static void say(OMXCodecDecoderContext *s, const char *message, ...)
+{
+    va_list args;
+    size_t str_len;
+    char str[1024];
+    memset(str, 0, sizeof(str));
+    va_start(args, message);
+    vsnprintf(str, sizeof(str) - 1, message, args);
+    va_end(args);
+    str_len = strlen(str);
+    if (str[str_len - 1] != '\n') {
+        str[str_len] = '\n';
+    }
+
+    av_log(s->avctx, AV_LOG_INFO, "%s", str);
+}
+
+
+static const char *dump_compression_format(OMXCodecDecoderContext *s, OMX_VIDEO_CODINGTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_VIDEO_CodingUnused:
+        return "not used";
+    case OMX_VIDEO_CodingAutoDetect:
+        return "autodetect";
+    case OMX_VIDEO_CodingMPEG2:
+        return "MPEG2";
+    case OMX_VIDEO_CodingH263:
+        return "H.263";
+    case OMX_VIDEO_CodingMPEG4:
+        return "MPEG4";
+    case OMX_VIDEO_CodingWMV:
+        return "Windows Media Video";
+    case OMX_VIDEO_CodingRV:
+        return "RealVideo";
+    case OMX_VIDEO_CodingAVC:
+        return "H.264/AVC";
+    case OMX_VIDEO_CodingMJPEG:
+        return "Motion JPEG";
+//        case OMX_VIDEO_CodingTheora:     return "OGG Theora";
+
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory\n");
+        }
+        sprintf(f, "format type 0x%08x", c);
+        return f;//maybe memleak
+    }
+}
+
+static const char *dump_color_format(OMXCodecDecoderContext *s, OMX_COLOR_FORMATTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_COLOR_FormatUnused:
+        return "OMX_COLOR_FormatUnused: not used";
+    case OMX_COLOR_FormatMonochrome:
+        return "OMX_COLOR_FormatMonochrome";
+    case OMX_COLOR_Format8bitRGB332:
+        return "OMX_COLOR_Format8bitRGB332";
+    case OMX_COLOR_Format12bitRGB444:
+        return "OMX_COLOR_Format12bitRGB444";
+    case OMX_COLOR_Format16bitARGB4444:
+        return "OMX_COLOR_Format16bitARGB4444";
+    case OMX_COLOR_Format16bitARGB1555:
+        return "OMX_COLOR_Format16bitARGB1555";
+    case OMX_COLOR_Format16bitRGB565:
+        return "OMX_COLOR_Format16bitRGB565";
+    case OMX_COLOR_Format16bitBGR565:
+        return "OMX_COLOR_Format16bitBGR565";
+    case OMX_COLOR_Format18bitRGB666:
+        return "OMX_COLOR_Format18bitRGB666";
+    case OMX_COLOR_Format18bitARGB1665:
+        return "OMX_COLOR_Format18bitARGB1665";
+    case OMX_COLOR_Format19bitARGB1666:
+        return "OMX_COLOR_Format19bitARGB1666";
+    case OMX_COLOR_Format24bitRGB888:
+        return "OMX_COLOR_Format24bitRGB888";
+    case OMX_COLOR_Format24bitBGR888:
+        return "OMX_COLOR_Format24bitBGR888";
+    case OMX_COLOR_Format24bitARGB1887:
+        return "OMX_COLOR_Format24bitARGB1887";
+    case OMX_COLOR_Format25bitARGB1888:
+        return "OMX_COLOR_Format25bitARGB1888";
+    case OMX_COLOR_Format32bitBGRA8888:
+        return "OMX_COLOR_Format32bitBGRA8888";
+    case OMX_COLOR_Format32bitARGB8888:
+        return "OMX_COLOR_Format32bitARGB8888";
+    case OMX_COLOR_FormatYUV411Planar:
+        return "OMX_COLOR_FormatYUV411Planar";
+    case OMX_COLOR_FormatYUV411PackedPlanar:
+        return "OMX_COLOR_FormatYUV411PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420Planar:
+        return "OMX_COLOR_FormatYUV420Planar: Planar YUV, 4:2:0 (I420)";
+    case OMX_COLOR_FormatYUV420PackedPlanar:
+        return "OMX_COLOR_FormatYUV420PackedPlanar: Planar YUV, 4:2:0 (I420), planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420SemiPlanar:
+        return "OMX_COLOR_FormatYUV420SemiPlanar, Planar YUV, 4:2:0 (NV12), U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422Planar:
+        return "OMX_COLOR_FormatYUV422Planar";
+    case OMX_COLOR_FormatYUV422PackedPlanar:
+        return "OMX_COLOR_FormatYUV422PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV422SemiPlanar:
+        return "OMX_COLOR_FormatYUV422SemiPlanar";
+    case OMX_COLOR_FormatYCbYCr:
+        return "OMX_COLOR_FormatYCbYCr";
+    case OMX_COLOR_FormatYCrYCb:
+        return "OMX_COLOR_FormatYCrYCb";
+    case OMX_COLOR_FormatCbYCrY:
+        return "OMX_COLOR_FormatCbYCrY";
+    case OMX_COLOR_FormatCrYCbY:
+        return "OMX_COLOR_FormatCrYCbY";
+    case OMX_COLOR_FormatYUV444Interleaved:
+        return "OMX_COLOR_FormatYUV444Interleaved";
+    case OMX_COLOR_FormatRawBayer8bit:
+        return "OMX_COLOR_FormatRawBayer8bit";
+    case OMX_COLOR_FormatRawBayer10bit:
+        return "OMX_COLOR_FormatRawBayer10bit";
+    case OMX_COLOR_FormatRawBayer8bitcompressed:
+        return "OMX_COLOR_FormatRawBayer8bitcompressed";
+    case OMX_COLOR_FormatL2:
+        return "OMX_COLOR_FormatL2";
+    case OMX_COLOR_FormatL4:
+        return "OMX_COLOR_FormatL4";
+    case OMX_COLOR_FormatL8:
+        return "OMX_COLOR_FormatL8";
+    case OMX_COLOR_FormatL16:
+        return "OMX_COLOR_FormatL16";
+    case OMX_COLOR_FormatL24:
+        return "OMX_COLOR_FormatL24";
+    case OMX_COLOR_FormatL32:
+        return "OMX_COLOR_FormatL32";
+    case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV420PackedSemiPlanar: Planar YUV, 4:2:0 (NV12), planes fragmented when a frame is split in multiple buffers, U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV422PackedSemiPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_Format18BitBGR666:
+        return "OMX_COLOR_Format18BitBGR666";
+    case OMX_COLOR_Format24BitARGB6666:
+        return "OMX_COLOR_Format24BitARGB6666";
+    case OMX_COLOR_Format24BitABGR6666:
+        return "OMX_COLOR_Format24BitABGR6666";
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory\n");
+        }
+        sprintf(f,  "format type 0x%08x", c);
+        return f;
+    }
+}
+
+static void dump_portdef(OMXCodecDecoderContext *s, OMX_PARAM_PORTDEFINITIONTYPE *portdef)
+{
+    OMX_VIDEO_PORTDEFINITIONTYPE *viddef = &portdef->format.video;
+    OMX_IMAGE_PORTDEFINITIONTYPE *imgdef = &portdef->format.image;
+
+    say(s, "Port %d is %s, %s, buffers wants:%d needs:%d, size:%d, pop:%d, aligned:%d",
+        portdef->nPortIndex,
+        (portdef->eDir ==  OMX_DirInput ? "input" : "output"),
+        (portdef->bEnabled == OMX_TRUE ? "enabled" : "disabled"),
+        portdef->nBufferCountActual,
+        portdef->nBufferCountMin,
+        portdef->nBufferSize,
+        portdef->bPopulated,
+        portdef->nBufferAlignment);
+
+
+    switch (portdef->eDomain) {
+    case OMX_PortDomainVideo:
+        say(s, "Video type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tBitrate:\t%d\n"
+            "\tFramerate:\t%.02f\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            viddef->nFrameWidth,
+            viddef->nFrameHeight,
+            viddef->nStride,
+            viddef->nSliceHeight,
+            viddef->nBitrate,
+            ((float)viddef->xFramerate / (float)65536),
+            (viddef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, viddef->eCompressionFormat),
+            dump_color_format(s, viddef->eColorFormat));
+        break;
+    case OMX_PortDomainImage:
+        say(s, "Image type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            imgdef->nFrameWidth,
+            imgdef->nFrameHeight,
+            imgdef->nStride,
+            imgdef->nSliceHeight,
+            (imgdef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, imgdef->eCompressionFormat),
+            dump_color_format(s, imgdef->eColorFormat));
+        break;
+    default:
+        break;
+    }
+}
+
+static av_cold int wait_for_state(OMXCodecDecoderContext *s, OMX_STATETYPE state);
+
+static void OnOutputPortEnabled(OMXCodecDecoderContext *s)
+{
+    av_log(s->avctx, AV_LOG_WARNING, "OnOutputPortEnabled\n");
+    s->outport_disabled = 0;
+    s->reconfigPending = 0;
+}
+
+static int OnOutputPortDisabled(OMXCodecDecoderContext *s)
+{
+    int i;
+    AVCodecContext *avctx = s->avctx;
+    OMX_ERRORTYPE err;
+    OMX_PARAM_PORTDEFINITIONTYPE out_port_params;
+    av_log(s->avctx, AV_LOG_WARNING, "OnOutputPortDisabled\n");
+    if (s->reconfigPending) {
+        INIT_STRUCT(out_port_params);
+        out_port_params.nPortIndex = s->out_port;
+        OMX_GetParameter(
+            s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+
+        s->pkt_upper_bound = out_port_params.nBufferCountMin;
+
+        pthread_mutex_lock(&s->output_mutex);
+        s->num_out_buffers = out_port_params.nBufferCountMin + 5;
+        out_port_params.nBufferCountActual = out_port_params.nBufferCountMin + 5;
+
+        err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+        CHECK(err);
+
+        s->out_buffer_headers = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+        s->done_out_buffers   = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+        if (!s->out_buffer_headers || !s->done_out_buffers) {
+            s->num_done_out_buffers = 0;
+            pthread_mutex_unlock(&s->output_mutex);
+            av_log(s->avctx, AV_LOG_ERROR, "Something wrong with out_buffers.\n");
+            return AVERROR(ENOMEM);
+        }
+        for (i = 0; i < s->num_out_buffers ; i++) {
+            err = OMX_AllocateBuffer(s->handle, &s->out_buffer_headers[i], s->out_port, s, out_port_params.nBufferSize);
+            s->out_buffer_headers[i]->pAppPrivate = s->out_buffer_headers[i]->pOutputPortPrivate = NULL;
+            s->out_buffer_headers[i]->pAppPrivate = NULL;
+            s->out_buffer_headers[i]->nTimeStamp = -1;
+            s->out_buffer_headers[i]->nOutputPortIndex =  s->out_port;
+            CHECK(err);
+        }
+
+        s->num_out_buffers = i;
+        s->num_done_out_buffers = 0;
+        for (i = 0; i < s->num_out_buffers && err == OMX_ErrorNone; i++) {
+            err = OMX_FillThisBuffer(s->handle, s->out_buffer_headers[i]);
+        }
+
+        if (err != OMX_ErrorNone) {
+            av_log(avctx, AV_LOG_WARNING, "FillOutBuffer failed , so set header\n");
+            for (i = 0; i < s->num_out_buffers; i++) {
+                s->done_out_buffers[s->num_done_out_buffers++] = s->out_buffer_headers[i];
+            }
+        }
+
+        av_log(s->avctx, AV_LOG_WARNING, "Send OMX_CommandPortEnable\n");
+        err = OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->out_port, NULL);
+        CHECK(err);
+        pthread_mutex_unlock(&s->output_mutex);
+    }
+    return 0;
+}
+
+static int onPortSettingChanged(OMXCodecDecoderContext *s, OMX_PARAM_PORTDEFINITIONTYPE *out_port_params)
+{
+    AVCodecContext *avctx = s->avctx;
+
+    av_log(s->avctx, AV_LOG_WARNING, "onPortSettingChanged\n");
+
+    OMX_ERRORTYPE err;
+    int i = 0;
+    s->outport_disabled = 1;
+    av_log(s->avctx, AV_LOG_WARNING, "nBufferCountActual modify!\n");
+    err = OMX_SendCommand(s->handle, OMX_CommandPortDisable, s->out_port, NULL);
+    CHECK(err);
+    s->reconfigPending = 1;
+    pthread_mutex_lock(&s->output_mutex);
+    if (&s->out_buffer_headers) {
+        av_freep(&s->out_buffer_headers);
+    }
+    if (&s->done_out_buffers) {
+        av_freep(&s->done_out_buffers);
+    }
+    s->num_out_buffers = 0;
+    s->num_done_out_buffers = 0;
+    pthread_mutex_unlock(&s->output_mutex);
+
+    return 0;
+}
+
+static int onIdleState(OMXCodecDecoderContext *s)
+{
+    if (s->portSettingidle == 1) {
+        av_log(s->avctx, AV_LOG_INFO, "onIdleState after portSettingidle\n");
+
+        if (OMX_ErrorNone != OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateExecuting, NULL)) {
+            av_log(s->avctx, AV_LOG_ERROR, "unable to set OMX_StateExecuting state\n");
+            return -1;
+        }
+
+        s->portSettingidle = 0;
+    }
+
+    return  0;
+}
+
+static OMX_ERRORTYPE event_handler(OMX_HANDLETYPE component, OMX_PTR app_data, OMX_EVENTTYPE event,
+                                   OMX_U32 data1, OMX_U32 data2, OMX_PTR event_data)
+{
+    OMXCodecDecoderContext *s = app_data;
+    // This uses casts in the printfs, since OMX_U32 actually is a typedef for
+    // unsigned long in official header versions (but there are also modified
+    // versions where it is something else).
+    //av_log(s->avctx, AV_LOG_WARNING, "event_handler OMXCodecDecoderContext %p\n", s);
+    switch (event) {
+    case OMX_EventError:
+        pthread_mutex_lock(&s->state_mutex);
+        s->error = data1;
+        pthread_cond_broadcast(&s->state_cond);
+        pthread_mutex_unlock(&s->state_mutex);
+
+        switch (data1) {
+        case OMX_ErrorInsufficientResources:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorInsufficientResources, stop decode!\n");
+            break;
+        case OMX_ErrorInvalidState:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorInvalidState!\n");
+            s->state = OMX_StateInvalid;
+            break;
+        case OMX_ErrorNotReady:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorNotReady!\n");
+            break;
+        case OMX_ErrorIncorrectStateOperation:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorIncorrectStateOperation!\n");
+            break;
+        case OMX_ErrorTimeout:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorTimeout!\n");
+            break;
+        case OMX_ErrorIncorrectStateTransition:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorTimeout!\n");
+            break;
+        default:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX error %"PRIx32"\n", (uint32_t) data1);
+            break;
+        }
+        return OMX_ErrorNone;
+    case OMX_EventCmdComplete:
+        if (data1 == OMX_CommandStateSet) {
+            pthread_mutex_lock(&s->state_mutex);
+            s->state = data2;
+            checkstate(s, data2);
+            if (data2 == OMX_StateIdle) {
+                onIdleState(s);
+            }
+
+            pthread_cond_broadcast(&s->state_cond);
+            pthread_mutex_unlock(&s->state_mutex);
+        } else if (data1 == OMX_CommandPortDisable) {
+            av_log(s->avctx, AV_LOG_INFO, "OMX port %"PRIu32" disabled\n", (uint32_t) data2);
+            if (data2 == s->out_port) {
+                OnOutputPortDisabled(s);
+            }
+        } else if (data1 == OMX_CommandPortEnable) {
+            av_log(s->avctx, AV_LOG_INFO, "OMX port %"PRIu32" enabled\n", (uint32_t) data2);
+            if (data2 == s->out_port) {
+                OnOutputPortEnabled(s);
+            }
+        } else if (data1 == OMX_CommandFlush) {
+            av_log(s->avctx, AV_LOG_WARNING, "OMX port %"PRIu32" flushed\n", (uint32_t) data2);
+        } else {
+            av_log(s->avctx, AV_LOG_WARNING, "OMX command complete, command %"PRIu32", value %"PRIu32"\n",
+                   (uint32_t) data1, (uint32_t) data2);
+        }
+        break;
+    case OMX_EventPortSettingsChanged:
+        if ((int)data1 == OMX_DirOutput) { //out is OMX_DirOutput
+            OMX_PARAM_PORTDEFINITIONTYPE out_port_params;
+            av_log(s->avctx, AV_LOG_INFO, "OMX outport settings changed: out_port: %d\n", s->out_port);
+
+            INIT_STRUCT(out_port_params);
+            out_port_params.nPortIndex = s->out_port;
+            OMX_GetParameter(
+                s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+            dump_portdef(s, &out_port_params);
+            s->outformat = out_port_params.format.video.eColorFormat ;
+
+            s->out_stride       = out_port_params.format.video.nStride;
+            s->out_slice_height = out_port_params.format.video.nSliceHeight;
+
+            onPortSettingChanged(s, &out_port_params);
+
+        } else if (data1 == s->out_port && data2 == OMX_IndexConfigCommonOutputCrop) {
+            // TODO: Handle video crop rect.
+        } else if (data1 == s->out_port && data2 == OMX_IndexConfigCommonScale) {
+            // TODO: Handle video SAR change.
+        } else {
+            av_log(s->avctx, AV_LOG_WARNING, "error event \n");
+        }
+
+        break;
+    case OMX_EventBufferFlag:
+        if (data1 == s->out_port) {
+            //
+        }
+        break;
+    default:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX event %d %"PRIx32" %"PRIx32"\n",
+               event, (uint32_t) data1, (uint32_t) data2);
+        break;
+    }
+    return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE empty_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                       OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecDecoderContext *s = app_data;
+    append_buffer(&s->input_mutex, &s->input_cond,
+                  &s->num_free_in_buffers, s->free_in_buffers, buffer);
+    pthread_mutex_lock(&s->buffer_control_mutex);
+    pthread_cond_broadcast(&s->buffer_control_cond);
+    pthread_mutex_unlock(&s->buffer_control_mutex);
+    return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE fill_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                      OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMX_ERRORTYPE err;
+    OMXCodecDecoderContext *s = app_data;
+
+    if (!buffer->nFilledLen) {
+        int i = 0;
+        for (i = 0; i < s->num_out_buffers; i++) {
+            if (s->out_buffer_headers[i] == buffer && s->out_buffer_headers[i]) {
+                break;
+            }
+        }
+
+        if (i == s->num_out_buffers) {
+            err = OMX_FreeBuffer(s->handle, 1, buffer);
+            return err;
+        }
+    }
+    append_buffer(&s->output_mutex, &s->output_cond,
+                  &s->num_done_out_buffers, s->done_out_buffers, buffer);
+    pthread_mutex_lock(&s->buffer_control_mutex);
+    pthread_cond_broadcast(&s->buffer_control_cond);
+    pthread_mutex_unlock(&s->buffer_control_mutex);
+    return OMX_ErrorNone;
+}
+
+static const OMX_CALLBACKTYPE decoder_callbacks = {
+    event_handler,
+    empty_buffer_done,
+    fill_buffer_done
+};
+
+static av_cold int omx_dec_find_component(OMXContext *omx_context, void *logctx,
+        const char *role, char *str, int str_size)
+{
+    OMX_U32 i, num = 0;
+    char **components;
+    int ret = 0;
+
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, NULL);
+    if (!num) {
+        av_log(logctx, AV_LOG_WARNING, "No component for role %s found\n", role);
+        return AVERROR_DECODER_NOT_FOUND;
+    }
+    components = av_calloc(num, sizeof(*components));
+    if (!components)
+        return AVERROR(ENOMEM);
+    for (i = 0; i < num; i++) {
+        components[i] = av_mallocz(OMX_MAX_STRINGNAME_SIZE);
+        if (!components[i]) {
+            ret = AVERROR(ENOMEM);
+            goto end;
+        }
+    }
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, (OMX_U8 **) components);
+    av_strlcpy(str, components[0], str_size);
+end:
+    for (i = 0; i < num; i++)
+        av_free(components[i]);
+    av_free(components);
+    return ret;
+}
+
+static av_cold int wait_for_state(OMXCodecDecoderContext *s, OMX_STATETYPE state)
+{
+    int ret = 0;
+    pthread_mutex_lock(&s->state_mutex);
+    while (s->state != state && s->error == OMX_ErrorNone)
+        pthread_cond_wait(&s->state_cond, &s->state_mutex);
+    if (s->error != OMX_ErrorNone)
+        ret = AVERROR_DECODER_NOT_FOUND;
+    pthread_mutex_unlock(&s->state_mutex);
+    return ret;
+}
+
+static av_cold int wait_for_eof(OMXCodecDecoderContext *s)
+{
+    int ret = 0;
+    pthread_mutex_lock(&s->eof_mutex);
+    while (s->got_eos != 1)
+        pthread_cond_wait(&s->eof_cond, &s->eof_mutex);
+
+    pthread_mutex_unlock(&s->eof_mutex);
+    return ret;
+}
+
+static int omx_send_extradata(AVCodecContext *avctx)
+{
+    OMX_BUFFERHEADERTYPE *buffer;
+    OMX_ERRORTYPE err;
+    if (avctx->extradata_size > 0) {
+        int64_t timeout = 60;
+        OMXCodecDecoderContext *s = avctx->priv_data;
+
+        buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                            &s->num_free_in_buffers, &s->free_in_buffers, timeout);
+        buffer->nFilledLen = avctx->extradata_size;
+        buffer->nFlags = OMX_BUFFERFLAG_EXTRADATA;
+        buffer->nOffset = 0;
+        memcpy(buffer->pBuffer, avctx->extradata, avctx->extradata_size);
+        err = OMX_EmptyThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "omx_send_extradata OMX_EmptyThisBuffer failed: %x\n", err);
+            return -1;
+        }
+
+        av_log(avctx, AV_LOG_INFO, "omx_send_extradata finished: %x\n");
+    }
+    return 0;
+}
+
+#define FORMAT_NV12
+static int omx_try_fillbuffer(OMXCodecDecoderContext *s, OMX_BUFFERHEADERTYPE *buffer);
+
+static int copyNV12toDst(OMXCodecDecoderContext *s, AVFrame *avframe, OMX_BUFFERHEADERTYPE *buffer)
+{
+    avframe->width = (OMX_U32) s->avctx->width;
+    avframe->height = (OMX_U32) s->avctx->height;
+    avframe->linesize[0] = avframe->width;
+    avframe->linesize[1] = avframe->width;
+    int y_size = avframe->linesize[0] * avframe->height;
+    int uv_size = y_size / 2;
+    int src_stride = s->out_stride;
+    uint8_t *y_src = NULL;
+
+    y_src = find_save_vir_address(s, buffer, y_size * 3 / 2, true);
+    s->out_buffer_size = y_size * 3 / 2;
+    if (y_src == MAP_FAILED || y_src == NULL) {
+        av_log(s->avctx, AV_LOG_ERROR, "Failed to get fd:%d 's virtual address.\n", buffer->pBuffer);
+        return -1;
+    }
+    uint8_t *y_dst = avframe->data[0];
+    uint8_t *uv_src = y_src + y_size;
+    uint8_t *uv_dst = avframe->data[1];
+    if (!s->resolution_changed) {
+        av_freep(&avframe->data);
+        av_freep(&avframe->buf);
+        avframe->data[0] = y_src;
+        avframe->data[1] = uv_src;
+        avframe->opaque = buffer;
+        avframe->buf[0] = av_buffer_create(avframe->opaque,
+                                           sizeof(OMX_BUFFERHEADERTYPE),
+                                           omx_try_fillbuffer,
+                                           s, AV_BUFFER_FLAG_READONLY);
+        buffer->pAppPrivate = avframe;
+    } else {
+        for (int i = 0; i < avframe->height; i++) {
+            memcpy(y_dst + i * avframe->linesize[0], y_src + i * src_stride, avframe->linesize[0]);
+        }
+        for (int i = 0; i < avframe->height / 2; i++) {
+            memcpy(uv_dst + i * avframe->linesize[1], y_src + src_stride * avframe->height + i * src_stride, avframe->linesize[1]);
+        }
+        buffer->pAppPrivate = avframe;
+    }
+    //else {
+    //    memcpy(y_dst, y_src, avframe->width *  avframe->height);
+    //    memcpy(uv_dst, uv_src, uv_size);
+    //}
+    return 0;
+}
+
+static int convertNV12toYUV420(OMXCodecDecoderContext *s, AVFrame *avframe, OMX_BUFFERHEADERTYPE *buffer)
+{
+#ifdef __OMX_ENABLE_SWCALE
+    const uint8_t *src_data[3];
+    int srclinesize[3];
+
+    srclinesize[0] = avframe->width;
+    srclinesize[1] = avframe->width;
+    srclinesize[2] = 0;
+
+    src_data[0] = (uint8_t *)(buffer->pBuffer);
+    src_data[1] = (uint8_t *)(buffer->pBuffer) + (avframe->width *  avframe->height) ;
+    src_data[2] = 0;
+
+    if (m_pSwsCtx == NULL) {
+        m_pSwsCtx = sws_getContext(avctx->width,
+                                   avctx->height,
+                                   AV_PIX_FMT_NV12,
+                                   avctx->width,
+                                   avctx->height,
+                                   AV_PIX_FMT_YUV420P, SWS_FAST_BILINEAR, NULL, NULL, NULL);
+    }
+
+    if (m_pSwsCtx == NULL) {
+        printf("Error converting\n");
+    } else {
+        sws_scale(m_pSwsCtx, src_data, srclinesize, 0,  avframe->height, avframe->data, avframe->linesize);
+    }
+#else
+    avframe->width = (OMX_U32) s->avctx->width;
+    avframe->height = (OMX_U32) s->avctx->height;
+    avframe->linesize[0] = avframe->width;
+    avframe->linesize[1] = avframe->width / 2;
+    avframe->linesize[2] = avframe->width / 2;
+    uint8_t *y_src = (uint8_t *)(buffer->pBuffer);
+    uint8_t *y_dst = avframe->data[0];
+
+    uint8_t *uv_src, *u_dst, *v_dst;
+    int src_stride = s->out_stride;
+    int y_src_size =  s->out_stride *  s->out_slice_height;
+    uint8_t *uv_src_start = (uint8_t *)(buffer->pBuffer) + y_src_size;
+
+    for (int i = 0; i < avframe->height; i++) {
+        memcpy(y_dst + i * avframe->linesize[0], y_src + i * src_stride, src_stride);
+    }
+
+    for (int i = 0; i < avframe->height / 2; i++) {
+        u_dst = avframe->data[1] + i * avframe->linesize[1];
+        v_dst = avframe->data[2] + i * avframe->linesize[2];
+        uv_src = uv_src_start + i *  src_stride ;
+
+        for (int j = 0; j < (avframe->width + 1) / 2; j++) {
+            *(u_dst++) = *(uv_src++);
+            *(v_dst++) = *(uv_src++);
+        }
+    }
+#endif
+    return 0;
+}
+
+static int omx_try_fillbuffer(OMXCodecDecoderContext *s, OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMX_ERRORTYPE err;
+    pthread_mutex_lock(&s->free_mutex);
+    if (buffer->pAppPrivate) {
+        err = OMX_FillThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->output_mutex, &s->output_cond, &s->num_done_out_buffers, s->done_out_buffers, buffer);
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+            return err;
+        }
+        buffer->pAppPrivate = NULL;
+    }
+    pthread_mutex_unlock(&s->free_mutex);
+    pthread_mutex_lock(&s->buffer_control_mutex);
+    pthread_cond_broadcast(&s->buffer_control_cond);
+    pthread_mutex_unlock(&s->buffer_control_mutex);
+    return 0;
+}
+
+static int check_buffer_outsize(OMXCodecDecoderContext *s)
+{
+    OMX_ERRORTYPE err;
+    AVCodecContext *avctx = s->avctx;
+    OMX_PARAM_PORTDEFINITIONTYPE out_port_params = {0};
+    INIT_STRUCT(out_port_params);
+    out_port_params.nPortIndex = s->out_port;
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+    CHECK(err);
+    if (avctx->width != out_port_params.format.video.nFrameWidth ||
+        avctx->height != out_port_params.format.video.nFrameHeight) {
+        avctx->width = out_port_params.format.video.nFrameWidth;
+        avctx->height = out_port_params.format.video.nFrameHeight;
+        avctx->coded_width = out_port_params.format.video.nFrameWidth;
+        avctx->coded_height = out_port_params.format.video.nFrameHeight;
+        s->resolution_changed = 1;
+        for (int i = 0; i < s->num_out_buffers; i++) {
+            OMX_BUFFERHEADERTYPE *buffer = s->out_buffer_headers[i];
+            err = omx_try_fillbuffer(s, buffer);
+            if (err != OMX_ErrorNone) {
+                av_log(avctx, AV_LOG_ERROR, "Fill buffer failed when resolution changed.\n");
+                return err;
+            }
+        }
+    }
+    return 0;
+}
+
+static int ff_omx_dec_receive(AVCodecContext *avctx, OMXCodecDecoderContext *s,
+                              AVFrame *avframe, bool wait)
+{
+    OMX_ERRORTYPE err;
+    int ret;
+    OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                                   &s->num_done_out_buffers, &s->done_out_buffers,
+                                   -1);
+    if (!buffer) {
+        //omx_outputbuffer_thread  error
+        return AVERROR(EAGAIN);
+    }
+
+    if (buffer->nFlags & OMX_BUFFERFLAG_EOS) {
+        av_log(avctx, AV_LOG_WARNING, "OMX_BUFFERFLAG_EOS reached\n");
+
+        pthread_mutex_lock(&s->eof_mutex);
+        s->got_eos = 1;
+        pthread_cond_broadcast(&s->eof_cond);
+        pthread_mutex_unlock(&s->eof_mutex);
+    }
+
+    if (buffer->nFilledLen == 0) {
+        err = OMX_FillThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->output_mutex, &s->output_cond, &s->num_done_out_buffers, s->done_out_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+        }
+        return AVERROR(EAGAIN);
+    }
+
+    s->output_count++;
+    ret = check_buffer_outsize(s);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Check buffer outsize in receive function failed: %x\n", ret);
+        return ret;
+    }
+#ifdef FORMAT_NV12
+    avctx->pix_fmt = AV_PIX_FMT_NV12;
+#endif
+    ret = ff_get_buffer(avctx, avframe, AV_GET_BUFFER_FLAG_REF);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "ff_get_buffer failed: %x\n", ret);
+        return ret;
+    }
+
+    if (buffer->nFlags == OMX_BUFFERFLAG_SYNCFRAME) {
+        avframe->flags |= AV_PICTURE_TYPE_I;
+    }
+    avframe->pts = av_rescale_q(from_omx_ticks(buffer->nTimeStamp), AV_TIME_BASE_Q, avctx->time_base);
+    avframe->pkt_dts = AV_NOPTS_VALUE;
+    if (avframe->pts <= 0 && s->pkt_duration) {
+        avframe->pts = s->now_pts;
+        s->now_pts += s->pkt_duration;
+    }
+
+#ifdef FORMAT_NV12
+    ret = copyNV12toDst(s, avframe, buffer);
+#else
+    ret = convertNV12toYUV420(s, avframe, buffer);
+#endif
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Format output failed: %x\n", ret);
+        return ret;
+    }
+    if (s->resolution_changed) {
+        ret = omx_try_fillbuffer(s, buffer);
+        if (ret != OMX_ErrorNone) {
+            av_log(avctx, AV_LOG_ERROR, "Reture buffer in resolution changed mode failed: %x\n", ret);
+            return AVERROR_UNKNOWN;
+        }
+    }
+    //OMX_FillThisBuffer finished
+    return 0;
+}
+
+static av_cold int omx_component_init_decoder(AVCodecContext *avctx, const char *role)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    OMX_PARAM_COMPONENTROLETYPE role_params = { 0 };
+    OMX_PORT_PARAM_TYPE video_port_params = { 0 };
+    OMX_PARAM_PORTDEFINITIONTYPE in_port_params = { 0 }, out_port_params = { 0 };
+    OMX_VIDEO_PARAM_PORTFORMATTYPE formatIn = {0};
+    OMX_CSI_BUFFER_MODE_CONFIGTYPE bufferMode = {0};
+
+    OMX_ERRORTYPE err;
+    int i;
+
+    s->version.s.nVersionMajor = 1;
+    s->version.s.nVersionMinor = 1;
+    s->version.s.nRevision     = 2;
+    s->input_count  = 0;
+    s->portSettingidle = 0;
+
+    s->crop_left = 0;
+    s->crop_top = 0;
+    s->status = INITIALIZING;
+#if 1
+    //set component_name OMX.hantro.VC8000D.video.decoder for test
+    av_log(avctx, AV_LOG_INFO, "OMX_GetHandle with component name %s \n", s->component_name);
+
+#endif
+    err = s->omx_context->ptr_GetHandle(&s->handle, s->component_name, s, (OMX_CALLBACKTYPE *) &decoder_callbacks);
+    if (err != OMX_ErrorNone) {
+        av_log(avctx, AV_LOG_ERROR, "OMX_GetHandle(%s) failed: %x\n", s->component_name, err);
+        return AVERROR_UNKNOWN;
+    }
+
+    // This one crashes the mediaserver on qcom, if used over IOMX
+    INIT_STRUCT(role_params);
+    av_strlcpy(role_params.cRole, role, sizeof(role_params.cRole));
+    // Intentionally ignore errors on this one
+    err = OMX_SetParameter(s->handle, OMX_IndexParamStandardComponentRole, &role_params);
+    CHECK(err);
+
+    INIT_STRUCT(video_port_params);
+    err = OMX_GetParameter(s->handle, OMX_IndexParamVideoInit, &video_port_params);
+    CHECK(err);
+
+    s->in_port = s->out_port = -1;
+    s->format_changed = 0;
+    s->reconfigPending = 0;
+    s->outport_disabled = 0;
+    s->pkt_full = 0;
+    s->now_pts = 0;
+    s->resolution_changed = 0;
+    s->pkt_sent_num = 0;
+    memset(s->buffer_table, 0, sizeof(outport_buffer_table)*MAX_TABLE_SIZE);
+    if (avctx->framerate.num) {
+        s->pkt_duration = abs(avctx->pkt_timebase.den / avctx->framerate.num);
+    } else {
+        s->pkt_duration = 0;
+    }
+    if (s->output_width)
+        avctx->width = s->output_width;
+    if (s->output_height)
+        avctx->height = s->output_height;
+
+
+
+    INIT_STRUCT(in_port_params);
+    in_port_params.nPortIndex =  s->in_port = OMX_DirInput;
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &in_port_params);
+    CHECK(err);
+
+    INIT_STRUCT(out_port_params);
+    out_port_params.nPortIndex = s->out_port = OMX_DirOutput;
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+    CHECK(err);
+
+    in_port_params.format.video.nFrameWidth  = (OMX_U32) avctx->width;
+    in_port_params.format.video.nFrameHeight = (OMX_U32) avctx->height;
+    in_port_params.format.video.nStride      = (OMX_U32) avctx->width;
+    in_port_params.format.video.nSliceHeight = (OMX_U32) avctx->height;
+    in_port_params.nBufferCountActual    = kNumPictureBuffers;
+    in_port_params.nBufferCountMin       = kNumPictureBuffers;
+
+
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &in_port_params);
+    CHECK(err);
+
+    out_port_params.format.video.nFrameWidth   = avctx->width;
+    out_port_params.format.video.nFrameHeight  = avctx->height;
+    out_port_params.format.video.nStride      = (OMX_U32) avctx->width;
+    out_port_params.format.video.nSliceHeight = (OMX_U32) avctx->height;
+    out_port_params.nBufferCountActual   = kNumPictureBuffers;
+    out_port_params.nBufferCountMin      = kNumPictureBuffers;
+    out_port_params.nBufferSize = (OMX_U32) avctx->width * (OMX_U32) avctx->height * 3;
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+    CHECK(err);
+
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &in_port_params);
+    CHECK(err);
+
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+    CHECK(err);
+
+    s->stride         = in_port_params.format.video.nStride;
+    s->plane_size     = in_port_params.format.video.nSliceHeight;
+    s->num_in_buffers = in_port_params.nBufferCountMin;
+    s->in_buffer_size = in_port_params.nBufferSize;
+    s->num_out_buffers = out_port_params.nBufferCountMin + 5;
+    s->out_buffer_size = out_port_params.nBufferSize;
+    s->out_stride       = out_port_params.format.video.nStride;
+    s->out_slice_height = out_port_params.format.video.nSliceHeight;
+
+    in_port_params.nBufferCountActual = in_port_params.nBufferCountMin;
+    out_port_params.nBufferCountActual = out_port_params.nBufferCountMin + 5;
+
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &in_port_params);
+    CHECK(err);
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+    CHECK(err);
+
+    s->pkt_upper_bound = out_port_params.nBufferCountMin;
+    dump_portdef(s, &in_port_params);
+    dump_portdef(s, &out_port_params);
+
+    INIT_STRUCT(formatIn);
+    formatIn.nPortIndex = s->in_port;
+    err = OMX_GetParameter(s->handle, OMX_IndexParamVideoPortFormat, &formatIn);
+
+    switch (avctx->codec->id) {
+    case AV_CODEC_ID_MPEG4:
+        formatIn.eCompressionFormat = OMX_VIDEO_CodingMPEG4;
+        break;
+    case AV_CODEC_ID_H264:
+        formatIn.eCompressionFormat = OMX_VIDEO_CodingAVC;
+        break;
+    case AV_CODEC_ID_RV10:
+    case AV_CODEC_ID_RV20:
+    case AV_CODEC_ID_RV30:
+        formatIn.eCompressionFormat = OMX_VIDEO_CodingAVC;
+        break;
+
+    case AV_CODEC_ID_HEVC:
+        formatIn.eCompressionFormat = OMX_CSI_VIDEO_CodingHEVC;
+        break;
+    case AV_CODEC_ID_VP9:
+        formatIn.eCompressionFormat = OMX_CSI_VIDEO_CodingVP9;
+        break;
+    default:
+        formatIn.eCompressionFormat = OMX_VIDEO_CodingAutoDetect;
+        break;
+
+    }
+
+    formatIn.eColorFormat = OMX_COLOR_FormatUnused;
+    formatIn.xFramerate = (OMX_U32)av_q2d(avctx->framerate);
+    err = OMX_SetParameter(s->handle, OMX_IndexParamVideoPortFormat, &formatIn);
+
+    INIT_STRUCT(bufferMode);
+    bufferMode.nPortIndex = s->out_port;
+    bufferMode.eMode = OMX_CSI_BUFFER_MODE_DMA;
+    err = OMX_SetParameter(s->handle, OMX_CSI_IndexParamBufferMode, &bufferMode);
+    if (err != OMX_ErrorNone) {
+        av_log(avctx, AV_LOG_ERROR, "Unable to set DMA mode at port %d\n", s->out_port);
+        return AVERROR_UNKNOWN;
+    } else
+        av_log(avctx, AV_LOG_INFO, "Set DMA mode at port %d\n", s->out_port);
+
+    if (OMX_ErrorNone != OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL)) {
+        av_log(avctx, AV_LOG_ERROR, "Unable to set IDLE state\n");
+        return AVERROR_UNKNOWN;
+    }
+
+    //allocate input buffers
+    s->in_buffer_headers  = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_in_buffers);
+    s->free_in_buffers    = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_in_buffers);
+    if (!s->in_buffer_headers || !s->free_in_buffers)
+        return AVERROR(ENOMEM);
+
+    for (i = 0; i < s->num_in_buffers && err == OMX_ErrorNone; i++) {
+        err = OMX_AllocateBuffer(s->handle, &s->in_buffer_headers[i],  s->in_port,  s, in_port_params.nBufferSize);
+        if (err == OMX_ErrorNone) {
+            s->in_buffer_headers[i]->nInputPortIndex = s->in_port;
+            s->in_buffer_headers[i]->nOffset = 0;
+            s->in_buffer_headers[i]->nFlags  = 0;
+        } else {
+            av_log(avctx, AV_LOG_ERROR, "OMX_AllocateBuffer for input[%d] failed\n", i);
+            return AVERROR_UNKNOWN;
+        }
+    }
+
+    CHECK(err);
+    s->num_in_buffers = i;
+    for (i = 0; i < s->num_in_buffers; i++) {
+        s->free_in_buffers[i] = s->in_buffer_headers[i];
+    }
+    s->num_free_in_buffers =  s->num_in_buffers;
+    av_log(avctx, AV_LOG_INFO, "OMX_AllocateBuffer for inputs %d finished\n", s->num_free_in_buffers);
+
+    //allocate output buffers
+    s->out_buffer_headers = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+    s->done_out_buffers   = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+    if (!s->out_buffer_headers || !s->done_out_buffers)
+        return AVERROR(ENOMEM);
+    for (i = 0; i < s->num_out_buffers && err == OMX_ErrorNone; i++) {
+        err = OMX_AllocateBuffer(s->handle, &s->out_buffer_headers[i], s->out_port, s, out_port_params.nBufferSize);
+        s->out_buffer_headers[i]->pAppPrivate = s->out_buffer_headers[i]->pOutputPortPrivate = NULL;
+        s->out_buffer_headers[i]->pAppPrivate = NULL;
+        s->out_buffer_headers[i]->nTimeStamp = -1;
+        s->out_buffer_headers[i]->nOutputPortIndex =  s->out_port;
+        CHECK(err);
+    }
+
+    s->num_out_buffers = i;
+
+#if 0
+    //check if port enabled
+    if (in_port_params.bEnabled == OMX_FALSE) {
+        OMX_SendCommand(s->handle, OMX_CommandPortEnable, OMX_DirInput, NULL);
+    }
+
+    if (out_port_params.bEnabled == OMX_FALSE) {
+        OMX_SendCommand(s->handle, OMX_CommandPortEnable, OMX_DirOutput, NULL);
+    }
+#endif
+
+    if (wait_for_state(s, OMX_StateIdle) < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Didn't get OMX_StateIdle\n");
+        return AVERROR_UNKNOWN;
+    }
+
+    err = OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateExecuting, NULL);
+    CHECK(err);
+    if (wait_for_state(s, OMX_StateExecuting) < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Didn't get OMX_StateExecuting\n");
+        return AVERROR_UNKNOWN;
+    }
+
+
+    for (i = 0; i < s->num_out_buffers && err == OMX_ErrorNone; i++) {
+        err = OMX_FillThisBuffer(s->handle, s->out_buffer_headers[i]);
+    }
+
+    if (err != OMX_ErrorNone) {
+        av_log(avctx, AV_LOG_WARNING, "FillOutBuffer failed , so set header\n");
+        for (; i < s->num_out_buffers; i++) {
+            s->done_out_buffers[s->num_done_out_buffers++] = s->out_buffer_headers[i];
+        }
+    }
+#ifdef MPEG4_OMX
+    omx_send_extradata(avctx);
+#endif
+    return err != OMX_ErrorNone ? AVERROR_UNKNOWN : 0;
+}
+
+static av_cold void omx_cleanup(OMXCodecDecoderContext *s)
+{
+    int executing;
+    av_log(s->avctx, AV_LOG_WARNING, "OMX Cleanup\n");
+    /* If the mutexes/condition variables have not been properly initialized,
+     * nothing has been initialized and locking the mutex might be unsafe. */
+    if (s->mutex_cond_inited) {
+        pthread_mutex_lock(&s->state_mutex);
+        executing = s->state == OMX_StateExecuting;
+        pthread_mutex_unlock(&s->state_mutex);
+        if (executing) {
+            OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
+            wait_for_state(s, OMX_StateIdle);
+            OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateLoaded, NULL);
+
+            for (int i = 0; i < s->num_in_buffers; i++) {
+                OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                                               &s->num_free_in_buffers, &s->free_in_buffers, -1);
+                OMX_FreeBuffer(s->handle, s->in_port, buffer);
+            }
+
+            for (int i = 0; i < s->num_out_buffers; i++) {
+                OMX_BUFFERHEADERTYPE *buffer = s->out_buffer_headers[i];
+                pthread_mutex_lock(&s->free_mutex);
+                if (buffer->pAppPrivate) {
+                    buffer->pAppPrivate = NULL;
+                }
+                pthread_mutex_unlock(&s->free_mutex);
+                if (find_save_vir_address(s, buffer, 0, false))
+                    munmap(find_save_vir_address(s, buffer, 0, false), s->out_buffer_size);
+                OMX_FreeBuffer(s->handle, s->out_port, buffer);
+            }
+            pthread_mutex_lock(&s->output_mutex);
+            s->num_out_buffers = 0;
+            s->num_done_out_buffers = 0;
+            pthread_mutex_unlock(&s->output_mutex);
+            wait_for_state(s, OMX_StateLoaded);
+        }
+
+        if (s->handle) {
+            s->omx_context->ptr_FreeHandle(s->handle);
+            s->handle = NULL;
+        }
+
+        omx_deinit(s->omx_context);
+        s->omx_context = NULL;
+        av_freep(&s->in_buffer_headers);
+        av_freep(&s->out_buffer_headers);
+        av_freep(&s->free_in_buffers);
+        av_freep(&s->done_out_buffers);
+
+    }
+    if (s->mutex_cond_inited) {
+        pthread_cond_destroy(&s->state_cond);
+        pthread_mutex_destroy(&s->state_mutex);
+        pthread_cond_destroy(&s->input_cond);
+        pthread_mutex_destroy(&s->input_mutex);
+        pthread_cond_destroy(&s->output_cond);
+        pthread_mutex_destroy(&s->output_mutex);
+        pthread_cond_destroy(&s->eof_cond);
+        pthread_mutex_destroy(&s->eof_mutex);
+        pthread_cond_destroy(&s->buffer_control_cond);
+        pthread_mutex_destroy(&s->buffer_control_mutex);
+        pthread_mutex_destroy(&s->free_mutex);
+        s->mutex_cond_inited = false;
+    }
+}
+
+static av_cold int omx_decode_init(AVCodecContext *avctx)
+{
+
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    int ret = AVERROR_DECODER_NOT_FOUND;
+    const char *role;
+    av_log(avctx, AV_LOG_INFO, "omx_decode_init enter\n");
+    /* cleanup relies on the mutexes/conditions being initialized first. */
+    s->omx_context = omx_init(avctx, s->libname, s->libprefix);
+    if (!s->omx_context)
+        return AVERROR_DECODER_NOT_FOUND;
+
+    pthread_mutex_init(&s->state_mutex, NULL);
+    pthread_cond_init(&s->state_cond, NULL);
+    pthread_mutex_init(&s->input_mutex, NULL);
+    pthread_cond_init(&s->input_cond, NULL);
+    pthread_mutex_init(&s->output_mutex, NULL);
+    pthread_cond_init(&s->output_cond, NULL);
+    pthread_mutex_init(&s->eof_mutex, NULL);
+    pthread_cond_init(&s->eof_cond, NULL);
+    pthread_mutex_init(&s->buffer_control_mutex, NULL);
+    pthread_cond_init(&s->buffer_control_cond, NULL);
+    pthread_mutex_init(&s->free_mutex, NULL);
+    s->mutex_cond_inited = true;
+    s->avctx = avctx;
+    s->state = OMX_StateLoaded;
+    s->error = OMX_ErrorNone;
+    s->first_pkt = 1;
+
+    switch (avctx->codec->id) {
+    case AV_CODEC_ID_MPEG4:
+        role = "video_decoder.mpeg4";
+        break;
+    case AV_CODEC_ID_H263:
+        role = "video_decoder.h263";
+        break;
+    case AV_CODEC_ID_H264:
+        role = "video_decoder.avc";
+        break;
+    case AV_CODEC_ID_HEVC:
+        role = "video_decoder.hevc";
+        break;
+    case AV_CODEC_ID_WMV1:
+    case AV_CODEC_ID_WMV2:
+    case AV_CODEC_ID_WMV3:
+        role = "video_decoder.wmv";
+        break;
+    case AV_CODEC_ID_VP6:
+        role = "video_decoder.vp6";
+        break;
+    case AV_CODEC_ID_VP8:
+        role = "video_decoder.vp8";
+        break;
+    case AV_CODEC_ID_VP9:
+        role = "video_decoder.vp9";
+        break;
+    default:
+        return AVERROR(ENOSYS);
+    }
+
+    ret = omx_dec_find_component(s->omx_context, avctx, role, s->component_name, sizeof(s->component_name));
+    if (ret < 0) {
+        return ret;
+    }
+
+    av_log(avctx, AV_LOG_INFO, "Using %s\n", s->component_name);
+    ret =  omx_component_init_decoder(avctx, role);
+    if (ret < 0) {
+        return ret;
+    }
+
+    av_log(avctx, AV_LOG_INFO, "%p, omx_decode_init:num_done_out_buffers %d, num_free_in_buffers %d\n", s,
+           s->num_out_buffers, s->num_free_in_buffers);
+    return 0;
+}
+
+static int ff_omx_dec_send(AVCodecContext *avctx, OMXCodecDecoderContext *s,
+                           AVPacket *pkt, bool wait)
+{
+    OMX_BUFFERHEADERTYPE *buffer;
+    OMX_ERRORTYPE err;
+    int need_draining = 0;
+    int64_t timeout = 0;
+
+    if (wait) {
+        timeout = 80;
+    }
+
+    if (pkt->size == 0) {
+        need_draining = 1;
+    }
+
+    if (s->draining && s->got_eos) {
+        av_log(avctx, AV_LOG_INFO, "got eof:%d\n", s->got_eos);
+        return AVERROR_EOF;
+    }
+
+    if (s->reconfigPending) {
+        //    av_usleep(1000);
+        return AVERROR_EOF;
+    }
+
+    if (pkt->data) {
+        buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                            &s->num_free_in_buffers, &s->free_in_buffers, timeout);
+
+        if (buffer == NULL) {
+            return AVERROR(EAGAIN);
+        }
+
+        buffer->nFilledLen = pkt->size;
+        buffer->nAllocLen = buffer->nFilledLen;
+        buffer->nFlags = 0;
+
+        if (pkt->flags & AV_PKT_FLAG_KEY) {
+            buffer->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;
+        }
+        if (pkt->flags & AV_PKT_FLAG_DISCARD) {
+            av_log(avctx, AV_LOG_WARNING, "AV_PKT_FLAG_DISCARD\n");
+        } else if (pkt->flags & AV_PKT_FLAG_CORRUPT) {
+            av_log(avctx, AV_LOG_WARNING, "AV_PKT_FLAG_CORRUPT\n");
+        } else {
+            buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
+        }
+
+        buffer->nOffset = 0;
+        buffer->nTimeStamp = to_omx_ticks(av_rescale_q(pkt->pts, avctx->time_base, AV_TIME_BASE_Q));
+        memcpy(buffer->pBuffer, pkt->data, pkt->size);
+        err = OMX_EmptyThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_EmptyThisBuffer failed: %x\n", err);
+            return AVERROR_UNKNOWN;
+        }
+        s->input_count++;
+    } else if (!s->eos_sent) {
+        //flush, end of stream
+        //ff_omx_dec_send reach eos
+        buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                            &s->num_free_in_buffers, &s->free_in_buffers, timeout);
+
+        buffer->nFilledLen = 0;
+        buffer->nFlags = OMX_BUFFERFLAG_EOS;
+        buffer->pAppPrivate = buffer->pOutputPortPrivate = NULL;
+        err = OMX_EmptyThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_EmptyThisBuffer failed: %x\n", err);
+            return AVERROR_UNKNOWN;
+        }
+        s->eos_sent = 1;
+    }
+    return 0;
+}
+
+static int ff_omx_dec_flush(AVCodecContext *avctx, OMXCodecDecoderContext *s)
+{
+    OMX_ERRORTYPE err;
+    OMX_BUFFERHEADERTYPE *buffer;
+    int i = 0;
+
+    s->draining = 0;
+    if (!s->flushing) {
+        s->flushing = 1;
+        s->pkt_sent_num = 0;
+        av_log(avctx, AV_LOG_INFO, "ff_omx_dec_flush\n");
+        if (OMX_ErrorNone != OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL)) {
+            av_log(avctx, AV_LOG_ERROR, "Unable to set IDLE state before flush data\n");
+            return AVERROR_UNKNOWN;
+        }
+
+        err = OMX_SendCommand(s->handle, OMX_CommandFlush, s->in_port, NULL);
+        if (err != OMX_ErrorNone)
+            return -1;
+
+        err = OMX_SendCommand(s->handle, OMX_CommandFlush, s->out_port, NULL);
+        if (err != OMX_ErrorNone)
+            return -1;
+
+        while (s->num_done_out_buffers > 0) {
+            buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                                &s->num_done_out_buffers, &s->done_out_buffers,
+                                -1);
+            if (!buffer) {
+                //omx_outputbuffer_thread  error
+                return AVERROR(EAGAIN);
+            }
+            err = OMX_FillThisBuffer(s->handle, buffer);
+            if (err != OMX_ErrorNone) {
+                append_buffer(&s->output_mutex, &s->output_cond, &s->num_done_out_buffers, s->done_out_buffers, buffer);
+                av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+                return AVERROR_UNKNOWN;
+            }
+        }
+        if (wait_for_state(s, OMX_StateIdle) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Didn't get OMX_StateIdle after flushing\n");
+            return AVERROR_UNKNOWN;
+        }
+        err = OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateExecuting, NULL);
+        CHECK(err);
+        if (wait_for_state(s, OMX_StateExecuting) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Didn't get OMX_StateExecuting after flushing\n");
+            return AVERROR_UNKNOWN;
+        }
+    } else {
+        av_usleep(100);
+    }
+    return 0;
+}
+
+static int omx_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    int ret;
+    /* feed decoder */
+    while (1) {
+        if (s->num_done_out_buffers > 0) {
+            ret = ff_omx_dec_receive(avctx, s, frame, false);
+            if (ret == 0) {
+                //receive success!
+                s->flushing = 0;
+                s->pkt_sent_num--;
+                return ret;
+            }
+        } else if (s->num_done_out_buffers == 0 && s->got_eos && s->eos_sent) {
+            return AVERROR_EOF;
+        }
+
+        if (s->num_free_in_buffers == 0 && s->num_done_out_buffers == 0 && !s->flushing && !s->eos_sent) {
+            pthread_mutex_lock(&s->buffer_control_mutex);
+            pthread_cond_wait(&s->buffer_control_cond, &s->buffer_control_mutex);
+            pthread_mutex_unlock(&s->buffer_control_mutex);
+        }
+
+        ret = check_buffer_outsize(s);
+        if (ret < 0) {
+            return AVERROR_UNKNOWN;
+        }
+        /* try to flush any buffered packet data */
+        if (s->buffered_pkt.size > 0 && !s->outport_disabled && s->pkt_sent_num < s->pkt_upper_bound) {
+            ret = ff_omx_dec_send(avctx, s, &s->buffered_pkt, true);
+            if (ret >= 0) {
+                //ff_omx_dec_send success
+                s->pkt_full = 0;
+                s->pkt_sent_num++;
+                av_packet_unref(&s->buffered_pkt);
+            } else if (ret < 0 && ret != AVERROR(EAGAIN)) {
+                return ret;
+            }
+            /* poll for space again */
+            continue;
+        }
+
+        /* fetch new packet or eof */
+        if (s->pkt_full == 0 && !s->eos_reach) {
+            ret = ff_decode_get_packet(avctx, &s->buffered_pkt);
+            if (ret == AVERROR_EOF) {
+                AVPacket null_pkt = { 0 };
+                ret = ff_omx_dec_send(avctx, s, &null_pkt, true);
+                if (ret < 0) {
+                    s->need_sendeos = 1;
+                    return ret;
+                }
+
+                s->need_sendeos = 0;
+                s->eos_reach = 1;
+                continue;
+
+            } else if (ret < 0) {
+                return ret;
+            } else {
+                //success
+                s->pkt_full = 1;
+            }
+        }
+    }
+    return AVERROR(EAGAIN);
+}
+
+
+static void omx_decode_flush(AVCodecContext *avctx)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    if (s->buffered_pkt.size > 0) {
+        av_packet_unref(&s->buffered_pkt);
+        s->buffered_pkt.size = 0;
+    }
+    ff_omx_dec_flush(avctx, s);
+}
+
+static av_cold int omx_decode_end(AVCodecContext *avctx)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+
+    omx_cleanup(s);
+    return 0;
+}
+
+#define OFFSET(x) offsetof(OMXCodecDecoderContext, x)
+#define VDE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+#define VE  AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+#define VD  AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM
+
+
+static const AVCodecHWConfigInternal *const omx_hw_configs[] = {
+    &(const AVCodecHWConfigInternal)
+    {
+        .public          = {
+            .pix_fmt     = AV_PIX_FMT_NV12,
+            .methods     = AV_CODEC_HW_CONFIG_METHOD_AD_HOC |
+            AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX,
+            .device_type = AV_HWDEVICE_TYPE_OMX,
+        },
+        .hwaccel         = NULL,
+    },
+    NULL
+};
+
+
+static const AVOption ff_omxcodec_vdec_options[] = {
+    { "output_width", "output width(must smaller than the original width)",  OFFSET(output_width), AV_OPT_TYPE_INT,       {.i64 = 0}, 0, 0xFFFFFFFF, VD},
+    { "output_height", "output height(must smaller than the original height)",  OFFSET(output_height), AV_OPT_TYPE_INT,       {.i64 = 0}, 0, 0xFFFFFFFF, VD},
+    { NULL }
+};
+
+
+
+#define DECLARE_OMX_VCLASS(short_name)                          \
+static const AVClass ff_##short_name##_omxcodec_dec_class = {   \
+    .class_name = #short_name "_libomx",                        \
+    .item_name  = av_default_item_name,                         \
+    .option     = ff_omxcodec_vdec_options,                     \
+    .version    = LIBAVUTIL_VERSION_INT,                        \
+};
+
+#ifdef FORMAT_NV12
+#define DECLARE_OMX_VDEC(short_name, full_name, codec_id, bsf)                                 \
+DECLARE_OMX_VCLASS(short_name)                                                                 \
+const FFCodec ff_ ## short_name ## _omx_decoder = {                                            \
+    .p.name           = #short_name "_omx",                                                    \
+    .p.long_name      = NULL_IF_CONFIG_SMALL("OpenMAX IL decoder"),                            \
+    .p.type           = AVMEDIA_TYPE_VIDEO,                                                    \
+    .p.id             = codec_id,                                                              \
+    .p.priv_class     = &ff_##short_name##_omxcodec_dec_class,                                 \
+    .priv_data_size = sizeof(OMXCodecDecoderContext),                                          \
+    .init           = omx_decode_init,                                                         \
+    FF_CODEC_RECEIVE_FRAME_CB(omx_receive_frame),                                              \
+    .close          = omx_decode_end,                                                          \
+    .flush          = omx_decode_flush,                                                        \
+    .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING ,                        \
+    .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS ,                                              \
+    .bsfs           = bsf,                                                                     \
+    .hw_configs    = (const AVCodecHWConfigInternal *const []) { NULL },                       \
+    .p.wrapper_name = "omxcodec",                                                              \
+    .p.pix_fmts       = (const enum AVPixelFormat[]) {                                         \
+                                 AV_PIX_FMT_NV12,                                              \
+                                 AV_PIX_FMT_NONE },                                            \
+};
+
+#else
+#define DECLARE_OMX_VDEC(short_name, full_name, codec_id, bsf)                                 \
+DECLARE_OMX_VCLASS(short_name)                                                                 \
+const FFCodec ff_ ## short_name ## _omx_decoder = {                                            \
+    .p.name           = #short_name "_omx",                                                    \
+    .p.long_name      = NULL_IF_CONFIG_SMALL("OpenMAX IL decoder"),                            \
+    .p.type           = AVMEDIA_TYPE_VIDEO,                                                    \
+    .p.id             = codec_id,                                                              \
+    .p.priv_class     = &ff_##short_name##_omxcodec_dec_class,                                 \
+    .priv_data_size = sizeof(OMXCodecDecoderContext),                                          \
+    .init           = omx_decode_init,                                                         \
+    FF_CODEC_RECEIVE_FRAME_CB(omx_receive_frame),                                              \
+    .close          = omx_decode_end,                                                          \
+    .flush          = omx_decode_flush,                                                        \
+    .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING ,                        \
+    .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS ,                                              \
+    .bsfs           = bsf,                                                                     \
+    .hw_configs    = (const AVCodecHWConfigInternal *const []) { NULL },                       \
+    .p.wrapper_name = "omxcodec",                                                              \
+};
+
+#endif
+
+
+
+DECLARE_OMX_VDEC(h264, "H.264", AV_CODEC_ID_H264, "h264_mp4toannexb")
+DECLARE_OMX_VDEC(hevc, "H.265", AV_CODEC_ID_HEVC, "hevc_mp4toannexb")
+DECLARE_OMX_VDEC(mpeg4, "MPEG-4 part 2", AV_CODEC_ID_MPEG4, NULL)
+DECLARE_OMX_VDEC(vp9, "VP9", AV_CODEC_ID_VP9, NULL)
+
+#ifdef MPEG4_OMX
+DECLARE_OMX_VDEC(mpeg4, "MPEG4", AV_CODEC_ID_MPEG4, NULL)
+#endif
diff --git a/libavcodec/omxjpegdecoder.c b/libavcodec/omxjpegdecoder.c
new file mode 100644
index 0000000..b07ca19
--- /dev/null
+++ b/libavcodec/omxjpegdecoder.c
@@ -0,0 +1,1089 @@
+/*decoders
+*
+* Copyright (c) 2023-2024 Huazhu Sun <sunhuazhu@coocaa.com>
+* Copyright (c) 2023-2024 Kaiyuan Dong <dongkaiyuan.dky@alibaba-inc.com>
+*
+* This file is part of FFmpeg.
+*
+* FFmpeg is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* FFmpeg is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with FFmpeg; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <time.h>
+#include <stdint.h>
+#include <stdatomic.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <sys/ipc.h>
+#include <sys/msg.h>
+#include <dlfcn.h>
+#include <string.h>
+#include <stdarg.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+
+#include "libavutil/avstring.h"
+#include "libavutil/avutil.h"
+#include "libavutil/common.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/log.h"
+#include "libavutil/opt.h"
+#include "libavutil/avassert.h"
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/pixfmt.h"
+#include "libavutil/internal.h"
+#include <libavutil/pixdesc.h>
+#include "libavutil/time.h"
+#include <libavutil/thread.h>
+#include <libavcodec/pthread_internal.h>
+
+#include <OMX_Core.h>
+#include <OMX_Component.h>
+
+#include "avcodec.h"
+#include "decode.h"
+#include "h264_parse.h"
+#include "h264_ps.h"
+#include "hevc_parse.h"
+#include "hwconfig.h"
+#include "internal.h"
+#include "codec_internal.h"
+#include <omxil/OMX_CsiExt.h>
+extern int omx_load_count;
+#define DEBUG_NO_OMX
+
+#define TIMEOUT_MS 1000
+
+#define kNumPictureBuffers 2
+#define INIT_STRUCT(x) do {                                               \
+        x.nSize = sizeof(x);                                              \
+        x.nVersion = s->version;                                          \
+    } while (0)
+#define CHECK(x) do {                                                     \
+        if (x != OMX_ErrorNone) {                                         \
+            av_log(s->avctx, AV_LOG_ERROR,                                \
+                   "err %x (%d) on line %d\n", x, x, __LINE__);           \
+            return -1;                                       \
+        }                                                                 \
+    } while (0)
+
+typedef struct OMXContext {
+    void *lib;
+    void *lib2;
+    OMX_ERRORTYPE(*ptr_Init)(void);
+    OMX_ERRORTYPE(*ptr_Deinit)(void);
+    OMX_ERRORTYPE(*ptr_ComponentNameEnum)(OMX_STRING, OMX_U32, OMX_U32);
+    OMX_ERRORTYPE(*ptr_GetHandle)(OMX_HANDLETYPE *, OMX_STRING, OMX_PTR, OMX_CALLBACKTYPE *);
+    OMX_ERRORTYPE(*ptr_FreeHandle)(OMX_HANDLETYPE);
+    OMX_ERRORTYPE(*ptr_GetComponentsOfRole)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    OMX_ERRORTYPE(*ptr_GetRolesOfComponent)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    void (*host_init)(void);
+} OMXContext;
+
+
+typedef struct OMXCodecDecoderContext {
+    char *libname;
+    char *libprefix;
+    OMXContext *omx_context;
+    AVCodecContext *avctx;
+    char component_name[OMX_MAX_STRINGNAME_SIZE];
+    OMX_VERSIONTYPE version;
+    OMX_HANDLETYPE handle;
+    int in_port, out_port;
+    int width, height;
+    int stride, plane_size;
+    int filelen;
+    int num_in_buffers, num_out_buffers;
+    int in_buffer_size, out_buffer_size;
+    OMX_BUFFERHEADERTYPE **in_buffer_headers;
+    OMX_BUFFERHEADERTYPE **out_buffer_headers;
+
+    int num_free_in_buffers;
+    OMX_BUFFERHEADERTYPE **free_in_buffers;
+    int num_done_out_buffers;
+    OMX_BUFFERHEADERTYPE **done_out_buffers;
+
+    int in_fill_index;
+    int out_fill_index;
+    pthread_mutex_t input_mutex;
+    pthread_cond_t input_cond;
+
+    pthread_mutex_t output_mutex;
+    pthread_cond_t output_cond;
+
+    pthread_mutex_t state_mutex;
+    pthread_cond_t state_cond;
+    OMX_EVENTTYPE event;
+    OMX_COMMANDTYPE cmd;
+    OMX_STATETYPE state;
+
+    OMX_ERRORTYPE error;
+    int have_init;
+    int crop_top, crop_left;
+    int portSettingChanged;
+} OMXCodecDecoderContext;
+
+
+static void say(OMXCodecDecoderContext *s, const char *message, ...)
+{
+    va_list args;
+    size_t str_len;
+    char str[1024];
+    memset(str, 0, sizeof(str));
+    va_start(args, message);
+    vsnprintf(str, sizeof(str) - 1, message, args);
+    va_end(args);
+    str_len = strlen(str);
+    if (str[str_len - 1] != '\n') {
+        str[str_len] = '\n';
+    }
+
+    av_log(s->avctx, AV_LOG_INFO, "%s", str);
+}
+
+
+static const char *dump_compression_format(OMXCodecDecoderContext *s, OMX_VIDEO_CODINGTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_VIDEO_CodingUnused:
+        return "not used";
+    case OMX_VIDEO_CodingAutoDetect:
+        return "autodetect";
+    case OMX_VIDEO_CodingMPEG2:
+        return "MPEG2";
+    case OMX_VIDEO_CodingH263:
+        return "H.263";
+    case OMX_VIDEO_CodingMPEG4:
+        return "MPEG4";
+    case OMX_VIDEO_CodingWMV:
+        return "Windows Media Video";
+    case OMX_VIDEO_CodingRV:
+        return "RealVideo";
+    case OMX_VIDEO_CodingAVC:
+        return "H.264/AVC";
+    case OMX_VIDEO_CodingMJPEG:
+        return "Motion JPEG";
+//        case OMX_VIDEO_CodingTheora:     return "OGG Theora";
+
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f, "format type 0x%08x", c);
+        return f;//maybe memleak
+    }
+}
+
+static const char *dump_color_format(OMXCodecDecoderContext *s, OMX_COLOR_FORMATTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_COLOR_FormatUnused:
+        return "OMX_COLOR_FormatUnused: not used";
+    case OMX_COLOR_FormatMonochrome:
+        return "OMX_COLOR_FormatMonochrome";
+    case OMX_COLOR_Format8bitRGB332:
+        return "OMX_COLOR_Format8bitRGB332";
+    case OMX_COLOR_Format12bitRGB444:
+        return "OMX_COLOR_Format12bitRGB444";
+    case OMX_COLOR_Format16bitARGB4444:
+        return "OMX_COLOR_Format16bitARGB4444";
+    case OMX_COLOR_Format16bitARGB1555:
+        return "OMX_COLOR_Format16bitARGB1555";
+    case OMX_COLOR_Format16bitRGB565:
+        return "OMX_COLOR_Format16bitRGB565";
+    case OMX_COLOR_Format16bitBGR565:
+        return "OMX_COLOR_Format16bitBGR565";
+    case OMX_COLOR_Format18bitRGB666:
+        return "OMX_COLOR_Format18bitRGB666";
+    case OMX_COLOR_Format18bitARGB1665:
+        return "OMX_COLOR_Format18bitARGB1665";
+    case OMX_COLOR_Format19bitARGB1666:
+        return "OMX_COLOR_Format19bitARGB1666";
+    case OMX_COLOR_Format24bitRGB888:
+        return "OMX_COLOR_Format24bitRGB888";
+    case OMX_COLOR_Format24bitBGR888:
+        return "OMX_COLOR_Format24bitBGR888";
+    case OMX_COLOR_Format24bitARGB1887:
+        return "OMX_COLOR_Format24bitARGB1887";
+    case OMX_COLOR_Format25bitARGB1888:
+        return "OMX_COLOR_Format25bitARGB1888";
+    case OMX_COLOR_Format32bitBGRA8888:
+        return "OMX_COLOR_Format32bitBGRA8888";
+    case OMX_COLOR_Format32bitARGB8888:
+        return "OMX_COLOR_Format32bitARGB8888";
+    case OMX_COLOR_FormatYUV411Planar:
+        return "OMX_COLOR_FormatYUV411Planar";
+    case OMX_COLOR_FormatYUV411PackedPlanar:
+        return "OMX_COLOR_FormatYUV411PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420Planar:
+        return "OMX_COLOR_FormatYUV420Planar: Planar YUV, 4:2:0 (I420)";
+    case OMX_COLOR_FormatYUV420PackedPlanar:
+        return "OMX_COLOR_FormatYUV420PackedPlanar: Planar YUV, 4:2:0 (I420), planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420SemiPlanar:
+        return "OMX_COLOR_FormatYUV420SemiPlanar, Planar YUV, 4:2:0 (NV12), U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422Planar:
+        return "OMX_COLOR_FormatYUV422Planar";
+    case OMX_COLOR_FormatYUV422PackedPlanar:
+        return "OMX_COLOR_FormatYUV422PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV422SemiPlanar:
+        return "OMX_COLOR_FormatYUV422SemiPlanar";
+    case OMX_COLOR_FormatYCbYCr:
+        return "OMX_COLOR_FormatYCbYCr";
+    case OMX_COLOR_FormatYCrYCb:
+        return "OMX_COLOR_FormatYCrYCb";
+    case OMX_COLOR_FormatCbYCrY:
+        return "OMX_COLOR_FormatCbYCrY";
+    case OMX_COLOR_FormatCrYCbY:
+        return "OMX_COLOR_FormatCrYCbY";
+    case OMX_COLOR_FormatYUV444Interleaved:
+        return "OMX_COLOR_FormatYUV444Interleaved";
+    case OMX_COLOR_FormatRawBayer8bit:
+        return "OMX_COLOR_FormatRawBayer8bit";
+    case OMX_COLOR_FormatRawBayer10bit:
+        return "OMX_COLOR_FormatRawBayer10bit";
+    case OMX_COLOR_FormatRawBayer8bitcompressed:
+        return "OMX_COLOR_FormatRawBayer8bitcompressed";
+    case OMX_COLOR_FormatL2:
+        return "OMX_COLOR_FormatL2";
+    case OMX_COLOR_FormatL4:
+        return "OMX_COLOR_FormatL4";
+    case OMX_COLOR_FormatL8:
+        return "OMX_COLOR_FormatL8";
+    case OMX_COLOR_FormatL16:
+        return "OMX_COLOR_FormatL16";
+    case OMX_COLOR_FormatL24:
+        return "OMX_COLOR_FormatL24";
+    case OMX_COLOR_FormatL32:
+        return "OMX_COLOR_FormatL32";
+    case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV420PackedSemiPlanar: Planar YUV, 4:2:0 (NV12), planes fragmented when a frame is split in multiple buffers, U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV422PackedSemiPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_Format18BitBGR666:
+        return "OMX_COLOR_Format18BitBGR666";
+    case OMX_COLOR_Format24BitARGB6666:
+        return "OMX_COLOR_Format24BitARGB6666";
+    case OMX_COLOR_Format24BitABGR6666:
+        return "OMX_COLOR_Format24BitABGR6666";
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f,  "format type 0x%08x", c);
+        return f;
+    }
+}
+
+static void dump_portdef(OMXCodecDecoderContext *s, OMX_PARAM_PORTDEFINITIONTYPE *portdef)
+{
+    OMX_VIDEO_PORTDEFINITIONTYPE *viddef = &portdef->format.video;
+    OMX_IMAGE_PORTDEFINITIONTYPE *imgdef = &portdef->format.image;
+
+    say(s, "Port %d is %s, %s, buffers wants:%d needs:%d, size:%d, pop:%d, aligned:%d",
+        portdef->nPortIndex,
+        (portdef->eDir ==  OMX_DirInput ? "input" : "output"),
+        (portdef->bEnabled == OMX_TRUE ? "enabled" : "disabled"),
+        portdef->nBufferCountActual,
+        portdef->nBufferCountMin,
+        portdef->nBufferSize,
+        portdef->bPopulated,
+        portdef->nBufferAlignment);
+
+
+    switch (portdef->eDomain) {
+    case OMX_PortDomainVideo:
+        say(s, "Video type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tBitrate:\t%d\n"
+            "\tFramerate:\t%.02f\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            viddef->nFrameWidth,
+            viddef->nFrameHeight,
+            viddef->nStride,
+            viddef->nSliceHeight,
+            viddef->nBitrate,
+            ((float)viddef->xFramerate / (float)65536),
+            (viddef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, viddef->eCompressionFormat),
+            dump_color_format(s, viddef->eColorFormat));
+        break;
+    case OMX_PortDomainImage:
+        say(s, "Image type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            imgdef->nFrameWidth,
+            imgdef->nFrameHeight,
+            imgdef->nStride,
+            imgdef->nSliceHeight,
+            (imgdef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, imgdef->eCompressionFormat),
+            dump_color_format(s, imgdef->eColorFormat));
+        break;
+    default:
+        break;
+    }
+}
+
+static OMX_ERRORTYPE empty_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                       OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecDecoderContext *s = app_data;
+    pthread_mutex_lock(&s->input_mutex);
+    s->num_free_in_buffers++;
+    pthread_mutex_unlock(&s->input_mutex);
+    return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE fill_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                      OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMX_ERRORTYPE err;
+    OMXCodecDecoderContext *s = app_data;
+    pthread_mutex_lock(&s->output_mutex);
+    s->num_done_out_buffers++;
+    pthread_mutex_unlock(&s->output_mutex);
+
+    return OMX_ErrorNone;
+}
+
+static void OnDecoderOutputChanged(OMXCodecDecoderContext *s)
+{
+    OMX_ERRORTYPE err;
+    OMX_PARAM_PORTDEFINITIONTYPE portdef;
+    av_log(s->avctx, AV_LOG_INFO, "OnDecoderOutputChanged\n");
+
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex = s->out_port;
+    OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    s->out_buffer_size = portdef.nBufferCountMin;
+    portdef.nBufferCountActual = portdef.nBufferCountMin;
+    OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+
+    dump_portdef(s, &portdef);
+    s->avctx->width = portdef.format.image.nFrameWidth;
+    s->width = portdef.format.image.nFrameWidth;
+    s->avctx->height = portdef.format.image.nFrameHeight;
+    s->height = portdef.format.image.nFrameHeight;
+    s->stride = portdef.format.image.nStride;
+    s->plane_size = portdef.format.image.nSliceHeight;
+    OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->out_port, NULL);
+
+    s->out_buffer_headers = malloc(s->out_buffer_size * sizeof(OMX_BUFFERHEADERTYPE *));
+    for (int i = 0; i < s->out_buffer_size; i++) {
+        err = OMX_AllocateBuffer(s->handle, &s->out_buffer_headers[i],  s->out_port,  s, portdef.nBufferSize);
+    }
+
+    for (int i = 0; i < s->out_buffer_size; i++) {
+        err = OMX_FillThisBuffer(s->handle, s->out_buffer_headers[i]);
+    }
+
+    s->portSettingChanged = 1;
+}
+
+static OMX_ERRORTYPE event_handler(OMX_HANDLETYPE component, OMX_PTR app_data, OMX_EVENTTYPE event,
+                                   OMX_U32 data1, OMX_U32 data2, OMX_PTR event_data)
+{
+    OMXCodecDecoderContext *s = app_data;
+
+    switch (event) {
+    case OMX_EventError:
+        pthread_mutex_lock(&s->state_mutex);
+        s->error = data1;
+        pthread_cond_broadcast(&s->state_cond);
+        pthread_mutex_unlock(&s->state_mutex);
+        switch (data1) {
+        case OMX_ErrorInsufficientResources:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorInsufficientResources, stop decode!\n");
+            break;
+        case OMX_ErrorInvalidState:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorInvalidState!\n");
+            s->state = OMX_StateInvalid;
+            break;
+        case OMX_ErrorNotReady:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorNotReady!\n");
+            break;
+        case OMX_ErrorIncorrectStateOperation:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorIncorrectStateOperation!\n");
+            break;
+        case OMX_ErrorTimeout:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorTimeout!\n");
+            break;
+        case OMX_ErrorIncorrectStateTransition:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorTimeout!\n");
+            break;
+        default:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX error 0x%x\n", (uint32_t) data1);
+            break;
+        }
+        return OMX_ErrorNone;
+    case OMX_EventCmdComplete:
+        if (data1 == OMX_CommandStateSet) {
+            switch (data2) {
+            case  OMX_StateIdle:
+                av_log(s->avctx, AV_LOG_INFO, "OMX_StateIdle\n");
+                break;
+            case OMX_StateLoaded:
+                av_log(s->avctx, AV_LOG_INFO, "OMX_StateLoaded\n");
+                break;
+            case OMX_StateExecuting:
+                av_log(s->avctx, AV_LOG_INFO, "OMX_StateExecuting\n");
+                break;
+            case OMX_StatePause:
+                av_log(s->avctx, AV_LOG_INFO, "OMX_StatePause\n");
+                break;
+            default:
+                av_log(s->avctx, AV_LOG_INFO, "OMX_State %X\n", data2);
+                break;
+            }
+
+        } else if (data1 == OMX_CommandPortDisable) {
+            av_log(s->avctx, AV_LOG_INFO, "OMX port%ld disabled\n", (uint32_t) data2);
+        } else if (data1 == OMX_CommandPortEnable) {
+            av_log(s->avctx, AV_LOG_INFO, "OMX port %ld enabled\n", (uint32_t) data2);
+        } else if (data1 == OMX_CommandFlush) {
+            av_log(s->avctx, AV_LOG_INFO, "OMX port %ld flushed\n", (uint32_t) data2);
+        } else {
+            av_log(s->avctx, AV_LOG_INFO, "OMX command complete, command %ld, value %ld\n",
+                   (uint32_t) data1, (uint32_t) data2);
+        }
+        break;
+    case OMX_EventPortSettingsChanged:
+        if ((int)data1 == OMX_DirOutput) { //out is OMX_DirOutput
+            OnDecoderOutputChanged(s);
+
+        } else if (data1 == s->out_port && data2 == OMX_IndexConfigCommonOutputCrop) {
+
+        } else if (data1 == s->out_port && data2 == OMX_IndexConfigCommonScale) {
+
+        } else {
+            av_log(s->avctx, AV_LOG_ERROR, "error event \n");
+        }
+
+        break;
+    case OMX_EventBufferFlag:
+        if (data1 == s->out_port) {
+            //
+        }
+        break;
+    default:
+        av_log(s->avctx, AV_LOG_INFO, "OMX event %d %ld %ld\n",
+               event, (uint32_t) data1, (uint32_t) data2);
+        break;
+    }
+
+    pthread_mutex_lock(&s->state_mutex);
+
+    s->event = event;
+    s->state = data2;
+    s->cmd = data1;
+
+    pthread_cond_broadcast(&s->state_cond);
+    pthread_mutex_unlock(&s->state_mutex);
+    return OMX_ErrorNone;
+}
+
+
+static const OMX_CALLBACKTYPE decoder_callbacks = {
+    event_handler,
+    empty_buffer_done,
+    fill_buffer_done
+};
+
+static av_cold int wait_for_state(OMXCodecDecoderContext *s, OMX_STATETYPE state)
+{
+    int ret = 0;
+    pthread_mutex_lock(&s->state_mutex);
+    while (s->state != state && s->error == OMX_ErrorNone)
+        pthread_cond_wait(&s->state_cond, &s->state_mutex);
+    if (s->error != OMX_ErrorNone)
+        ret = AVERROR_DECODER_NOT_FOUND;
+    pthread_mutex_unlock(&s->state_mutex);
+    return ret;
+}
+
+static int wait_for_event(AVCodecContext *avctx, OMX_EVENTTYPE event, OMX_COMMANDTYPE cmd, OMX_STATETYPE state,
+                          int timeout)
+{
+    int ret = 0;
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    pthread_mutex_lock(&s->state_mutex);
+    while ((s->state != state ||  s->cmd != cmd  || s->event != event) && s->error == OMX_ErrorNone) {
+        pthread_cond_wait(&s->state_cond, &s->state_mutex);
+    }
+    if (s->error != OMX_ErrorNone)
+        ret = -1;
+    pthread_mutex_unlock(&s->state_mutex);
+    return ret;
+}
+
+static  void *dlsym_prefixed(void *handle, const char *symbol, const char *prefix)
+{
+    char buf[50];
+    snprintf(buf, sizeof(buf), "%s%s", prefix ? prefix : "", symbol);
+    return dlsym(handle, buf);
+}
+
+
+static int omx_try_load(OMXContext *s, void *logctx,
+                        const char *libname, const char *prefix,
+                        const char *libname2)
+{
+    s->lib = dlopen(libname, RTLD_NOW | RTLD_GLOBAL);
+    if (!s->lib) {
+        av_log(logctx, AV_LOG_ERROR, "%s not found\n", libname);
+        return -1;
+    }
+    s->ptr_Init                = dlsym_prefixed(s->lib, "OMX_Init", prefix);
+    s->ptr_Deinit              = dlsym_prefixed(s->lib, "OMX_Deinit", prefix);
+    s->ptr_ComponentNameEnum   = dlsym_prefixed(s->lib, "OMX_ComponentNameEnum", prefix);
+    s->ptr_GetHandle           = dlsym_prefixed(s->lib, "OMX_GetHandle", prefix);
+    s->ptr_FreeHandle          = dlsym_prefixed(s->lib, "OMX_FreeHandle", prefix);
+    s->ptr_GetComponentsOfRole = dlsym_prefixed(s->lib, "OMX_GetComponentsOfRole", prefix);
+    s->ptr_GetRolesOfComponent = dlsym_prefixed(s->lib, "OMX_GetRolesOfComponent", prefix);
+
+    if (!s->ptr_Init || !s->ptr_Deinit || !s->ptr_ComponentNameEnum ||
+        !s->ptr_GetHandle || !s->ptr_FreeHandle ||
+        !s->ptr_GetComponentsOfRole || !s->ptr_GetRolesOfComponent) {
+        av_log(logctx, AV_LOG_ERROR, "Not all functions found in %s\n", libname);
+        dlclose(s->lib);
+        s->lib = NULL;
+        if (s->lib2)
+            dlclose(s->lib2);
+        s->lib2 = NULL;
+        return -1;
+    }
+    return 0;
+}
+
+
+static int print_omx_env(OMXContext *omx_context)
+{
+    OMX_ERRORTYPE err;
+    OMX_U32 numComps = 0;
+    OMX_U8 component[OMX_MAX_STRINGNAME_SIZE];
+    OMX_U8 **roleList;
+
+    if (omx_context == NULL) {
+        return 0;
+    }
+
+    if (omx_context->ptr_ComponentNameEnum == NULL) {
+        return 0;
+    }
+    numComps = 0;
+    while (err == OMX_ErrorNone) {
+        err = omx_context->ptr_ComponentNameEnum(component, OMX_MAX_STRINGNAME_SIZE, numComps);
+        if (err == OMX_ErrorNone) {
+            OMX_U32 numberofroles = 0;
+            err = omx_context->ptr_GetRolesOfComponent(component, &numberofroles, NULL);
+            if (numberofroles == 1) {
+                roleList = malloc(numberofroles * sizeof(OMX_U8 *));
+                roleList[0] =  malloc(OMX_MAX_STRINGNAME_SIZE);
+                omx_context->ptr_GetRolesOfComponent(component, &numberofroles, roleList);
+                free(roleList[0]);
+                free(roleList);
+            }
+        }
+        numComps++;
+    }
+
+    return 0;
+}
+
+static OMXContext *omx_init(void *logctx,  const char *prefix)
+{
+    static const char *const libnames[] = {
+        "libomxil-bellagio.so.0", NULL,
+        "libOMX_Core.so", NULL,
+        "libOmxCore.so", NULL,
+        NULL
+    };
+    const char *const *nameptr;
+    int ret = -1;
+    OMXContext *omx_context;
+    OMX_ERRORTYPE error;
+    omx_context = malloc(sizeof(*omx_context));
+    if (!omx_context)
+        return NULL;
+    memset((void *)omx_context, 0, sizeof(*omx_context));
+
+    for (nameptr = libnames; *nameptr; nameptr += 2)
+        if (!(ret = omx_try_load(omx_context, logctx, nameptr[0], prefix, nameptr[1])))
+            break;
+    if (!*nameptr) {
+        free(omx_context);
+        return NULL;
+    }
+
+
+    if (omx_context->host_init)
+        omx_context->host_init();
+    av_log(NULL, AV_LOG_INFO, "OMX_count load %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        error = omx_context->ptr_Init();
+        if (error != OMX_ErrorNone) {
+            av_log(NULL, AV_LOG_WARNING, "OMX Init error\n");
+        }
+    }
+    omx_load_count++;
+    return omx_context;
+}
+
+static int omx_dec_find_component(OMXContext *omx_context,
+                                  const char *role, char *str, int str_size)
+{
+    OMX_U32 i, num = 0;
+    char **components;
+    int ret = 0;
+//OMX.hantro.VC8000D.image.decoder.jpeg
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, NULL);
+    if (!num) {
+        return -1;
+    }
+    components = calloc(num, sizeof(*components));
+    if (!components)
+        return -1;
+
+    memset((void *)components, 0, num * sizeof(*components));
+    for (i = 0; i < num; i++) {
+        components[i] = malloc(OMX_MAX_STRINGNAME_SIZE);
+        if (!components[i]) {
+            ret = -1;
+            goto end;
+        }
+        memset((void *)components[i], 0, OMX_MAX_STRINGNAME_SIZE);
+    }
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, (OMX_U8 **) components);
+    strncpy(str, components[0], str_size);
+end:
+    for (i = 0; i < num; i++)
+        free(components[i]);
+    free(components);
+    return ret;
+}
+
+
+static void omx_deinit(OMXContext *omx_context)
+{
+    if (!omx_context)
+        return;
+    omx_load_count--;
+    av_log(NULL, AV_LOG_INFO, "OMX_count %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        omx_context->ptr_Deinit();
+        dlclose(omx_context->lib);
+    }
+    free(omx_context);
+}
+
+
+
+static int omx_component_init_decoder(AVCodecContext *avctx)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    OMX_PARAM_COMPONENTROLETYPE role_params = { 0 };
+    OMX_PARAM_PORTDEFINITIONTYPE in_port_params = { 0 }, out_port_params = { 0 };
+
+    OMX_PARAM_PORTDEFINITIONTYPE portdef;
+    OMX_IMAGE_PARAM_PORTFORMATTYPE imagePortFormat;
+    OMX_PORT_PARAM_TYPE port;
+    OMX_CSI_BUFFER_MODE_CONFIGTYPE bufferMode = {0};
+
+    OMX_ERRORTYPE err;
+    int i;
+
+    s->version.s.nVersionMajor = 1;
+    s->version.s.nVersionMinor = 1;
+    s->version.s.nRevision     = 2;
+    err = s->omx_context->ptr_GetHandle(&s->handle, s->component_name, s, (OMX_CALLBACKTYPE *) &decoder_callbacks);
+    if (err != OMX_ErrorNone) {
+        av_log(s->avctx, AV_LOG_ERROR, "OMX_GetHandle(%s) failed: %x\n", s->component_name, err);
+        return -1;
+    }
+
+    s->crop_left = 0;
+    s->crop_top = 0;
+    s->have_init = 1;
+    s->portSettingChanged = 0;
+    INIT_STRUCT(port);
+    OMX_GetParameter(s->handle, OMX_IndexParamImageInit, &port);
+    if (port.nPorts != 2) {
+        return -1;
+    }
+
+    s->in_port = port.nStartPortNumber;
+    s->out_port = port.nStartPortNumber + 1;
+
+    OMX_SendCommand(s->handle, OMX_CommandPortDisable, s->in_port, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortDisable, s->in_port, TIMEOUT_MS);
+    OMX_SendCommand(s->handle, OMX_CommandPortDisable, s->out_port, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortDisable, s->out_port, TIMEOUT_MS);
+
+    memset((void *)&imagePortFormat, 0, sizeof(imagePortFormat));
+    INIT_STRUCT(imagePortFormat);
+
+    imagePortFormat.nPortIndex = s->in_port;
+    imagePortFormat.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+
+    OMX_SetParameter(s->handle, OMX_IndexParamImagePortFormat, &imagePortFormat);
+
+    memset((void *)&portdef, 0, sizeof(portdef));
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex =  s->in_port;
+
+    OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    int iBufferCount = portdef.nBufferCountMin;
+    portdef.nBufferCountActual = portdef.nBufferCountMin;
+    int iBufferSize = portdef.nBufferSize;
+    if (s->stride != 0) {
+        portdef.format.image.nFrameWidth = s->stride;
+        portdef.format.image.nFrameHeight = s->plane_size;
+    }
+
+    if (s->filelen >  4096 * 1024) {
+        portdef.nBufferSize = s->filelen;
+    } else {
+        portdef.nBufferSize = 4096 * 1024;
+    }
+    iBufferSize = portdef.nBufferSize;
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    if (err != OMX_ErrorNone) {
+        av_log(s->avctx, AV_LOG_ERROR, "set error failed\n");
+        return AVERROR_UNKNOWN;
+    }
+    dump_portdef(s, &portdef);
+    memset((void *)&portdef, 0, sizeof(portdef));
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex =  s->out_port;
+
+    OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    dump_portdef(s, &portdef);
+    if (s->stride != 0) {
+        portdef.format.image.nFrameWidth = s->stride;
+        portdef.format.image.nFrameHeight = s->plane_size;
+        OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    }
+
+    INIT_STRUCT(bufferMode);
+    bufferMode.nPortIndex = s->out_port;
+    bufferMode.eMode = OMX_CSI_BUFFER_MODE_DMA;
+    err = OMX_SetParameter(s->handle, OMX_CSI_IndexParamBufferMode, &bufferMode);
+    if (err != OMX_ErrorNone) {
+        av_log(avctx, AV_LOG_ERROR, "Unable to set DMA mode at port %d\n", s->out_port);
+        return AVERROR_UNKNOWN;
+    } else
+        av_log(avctx, AV_LOG_INFO, "Set DMA mode at port %d\n", s->out_port);
+
+    OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet,  OMX_StateIdle, TIMEOUT_MS);
+
+    OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->in_port, NULL);
+
+    s->num_free_in_buffers = s->in_buffer_size = iBufferCount;
+    s->num_done_out_buffers = 0;
+    s->in_buffer_headers = malloc(iBufferCount * sizeof(OMX_BUFFERHEADERTYPE *));
+    for (int i = 0; i < iBufferCount; i++) {
+        OMX_AllocateBuffer(s->handle, &s->in_buffer_headers[i],  s->in_port,  s, iBufferSize);
+    }
+
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortEnable, s->in_port, TIMEOUT_MS);
+    OMX_SendCommand(s->handle,  OMX_CommandStateSet, OMX_StateExecuting, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet, OMX_StateExecuting, TIMEOUT_MS);
+
+    av_log(s->avctx, AV_LOG_INFO, "finish omx_component_init_decoder\n");
+    return 0;
+}
+
+
+static int omx_decode_init2(AVCodecContext *avctx)
+{
+    av_log(avctx, AV_LOG_INFO, "jpeg_omxcodec decoder init...\n");
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    int ret = -1;
+    const char *role = "image_decoder.jpeg";
+    memset((void *)s, 0, sizeof(OMXCodecDecoderContext));
+
+    s->avctx = avctx;
+    s->width = 0;
+    s->height = 0;
+    s->omx_context = omx_init(s->libname, s->libprefix);
+    if (!s->omx_context)
+        return -1;
+    pthread_mutex_init(&s->state_mutex, NULL);
+    pthread_cond_init(&s->state_cond, NULL);
+    pthread_mutex_init(&s->input_mutex, NULL);
+    pthread_cond_init(&s->input_cond, NULL);
+    pthread_mutex_init(&s->output_mutex, NULL);
+    pthread_cond_init(&s->output_cond, NULL);
+
+    s->state = OMX_StateLoaded;
+    s->error = OMX_ErrorNone;
+
+    strcpy(s->component_name, "OMX.hantro.VC8000D.image.decoder.jpeg");
+    return 0;
+}
+
+static int omx_decode_init(AVCodecContext *avctx, int len)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    int ret = -1;
+    s->filelen = len;
+    av_log(avctx, AV_LOG_INFO, "Input File Len: %d\n", len);
+    ret =  omx_component_init_decoder(avctx);
+    if (ret < 0) {
+        return ret;
+    }
+    return 0;
+}
+
+
+
+static int omx_decode_uninit(AVCodecContext *avctx)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    if (s->state == OMX_StateExecuting) {
+        OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
+        wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet, OMX_StateIdle, TIMEOUT_MS);
+        OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateLoaded, NULL);
+
+        for (int i = 0; i < s->num_in_buffers; i++) {
+            OMX_BUFFERHEADERTYPE *buffer = s->in_buffer_headers[i];
+            OMX_FreeBuffer(s->handle, s->in_port, buffer);
+        }
+
+        for (int i = 0; i < s->num_out_buffers; i++) {
+            OMX_BUFFERHEADERTYPE *buffer = s->out_buffer_headers[i];
+            OMX_FreeBuffer(s->handle, s->out_port, buffer);
+        }
+        wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet, OMX_StateLoaded, TIMEOUT_MS);
+        //wait_for_state(s, OMX_StateLoaded);
+    }
+
+    if (s->handle) {
+        s->omx_context->ptr_FreeHandle(s->handle);
+        s->handle = NULL;
+    }
+
+    omx_deinit(s->omx_context);
+    s->omx_context = NULL;
+    free(s->in_buffer_headers);
+    free(s->out_buffer_headers);
+    free(s->free_in_buffers);
+    free(s->done_out_buffers);
+
+    pthread_cond_destroy(&s->state_cond);
+    pthread_mutex_destroy(&s->state_mutex);
+    pthread_cond_destroy(&s->input_cond);
+    pthread_mutex_destroy(&s->input_mutex);
+    pthread_cond_destroy(&s->output_cond);
+    pthread_mutex_destroy(&s->output_mutex);
+    av_log(avctx, AV_LOG_INFO, "jpeg_omxcodec decoder finish...\n");
+    return 0;
+}
+
+static int omx_try_fillbuffer(OMXCodecDecoderContext *s, OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMX_ERRORTYPE err;
+    err = OMX_FillThisBuffer(s->handle, buffer);
+    if (err != OMX_ErrorNone) {
+        av_log(s->avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+        return AVERROR_UNKNOWN;
+    }
+    return 0;
+}
+
+#define FORMAT_NV12
+
+static int get_data_from_buffer(AVCodecContext *avctx, AVFrame *avframe, OMX_BUFFERHEADERTYPE *buffer)
+{
+    int ret = 0;
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    int y_size =  s->width * s->height;
+    int uv_size = y_size / 2;
+
+    //uint8_t *y_src = (uint8_t *)(buffer->pBuffer);
+    uint8_t *y_src = (uint8_t *)mmap(NULL, y_size * 3 / 2, PROT_READ, MAP_PRIVATE, buffer->pBuffer, 0);
+    if (y_src == MAP_FAILED) {
+        av_log(s->avctx, AV_LOG_ERROR, "Failed to map fd:%d to y_src.\n", buffer->pBuffer);
+        return -1;
+    }
+
+    uint8_t *uv_src = y_src + y_size;
+    int  outsize = s->width * s->height * 3 / 2;
+
+    avframe->format =  AV_PIX_FMT_NV12;
+    avframe->width = s->width;
+    avframe->height = s->height;
+
+    avframe->linesize[0] = avframe->width;
+    avframe->linesize[1] = avframe->width;
+    uint8_t *y_dst = avframe->data[0];
+    uint8_t *u_dst = avframe->data[1];
+    uint8_t *v_dst = avframe->data[2];
+
+    av_freep(&avframe->data);
+    av_freep(&avframe->buf);
+    avframe->data[0] = y_src;
+    avframe->data[1] = uv_src;
+    //memcpy(y_dst, y_src, avframe->width * avframe->height);
+    //memcpy(u_dst, uv_src, avframe->width * avframe->height / 2);
+    avframe->opaque = buffer;
+    avframe->buf[0] = av_buffer_create(avframe->opaque,
+                                       sizeof(OMX_BUFFERHEADERTYPE),
+                                       omx_try_fillbuffer,
+                                       s, AV_BUFFER_FLAG_READONLY);
+    return 0;
+}
+
+
+
+static int omx_decode_image(AVCodecContext *avctx, void *data, int len, AVFrame *frame)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+
+    int done = 0;
+    int in_pos = 0;
+    int out_pos = 0;
+    int in_index = 0;
+    int out_index = 0;
+    int ret = 0;
+    OMX_BUFFERHEADERTYPE *pBufHeader = NULL;
+
+    while (!done) {
+        if ((s->num_free_in_buffers > 0) && (in_pos < len)) {
+            pBufHeader = s->in_buffer_headers[in_index];
+            in_index++;
+            pthread_mutex_lock(&s->input_mutex);
+            s->num_free_in_buffers--;
+            pthread_mutex_unlock(&s->input_mutex);
+            if (in_index >= s->in_buffer_size) {
+                in_index = 0;
+            }
+            pBufHeader->nOffset = 0;
+            pBufHeader->nFlags = 0;
+
+            if ((in_pos + pBufHeader->nAllocLen) < len) {
+                av_log(s->avctx, AV_LOG_INFO, "total len %d, currnet Filled buffer size %d, still %d left\n", len,
+                       pBufHeader->nAllocLen, len - in_pos);
+                memcpy(pBufHeader->pBuffer,  data + in_pos, pBufHeader->nAllocLen);
+                pBufHeader->nFilledLen = pBufHeader->nAllocLen;
+                in_pos +=  pBufHeader->nAllocLen;
+            } else {
+                memcpy(pBufHeader->pBuffer,  data + in_pos, len - in_pos);
+                pBufHeader->nFilledLen = len - in_pos;
+                pBufHeader->nFlags = OMX_BUFFERFLAG_EOS;
+                pBufHeader->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
+                in_pos = len;
+                av_log(s->avctx, AV_LOG_INFO, "input EOS reached\n");
+            }
+            OMX_EmptyThisBuffer(s->handle, pBufHeader);
+        }
+
+        if (s->portSettingChanged) {
+            while (s->num_done_out_buffers > 0) {
+                pBufHeader = s->out_buffer_headers[out_index];
+                out_index++;
+                if (out_index >= s->out_buffer_size) {
+                    out_index = 0;
+                }
+                pthread_mutex_lock(&s->output_mutex);
+                s->num_done_out_buffers--;
+                pthread_mutex_unlock(&s->output_mutex);
+                if (pBufHeader->nFilledLen > 0) {
+                    done = 1;
+                    av_log(s->avctx, AV_LOG_INFO, "Output YUV-NV12 len: %d\n", pBufHeader->nFilledLen);
+                }
+                if (pBufHeader->nFlags & OMX_BUFFERFLAG_EOS) {
+                    done = 1;
+                }
+                if (pBufHeader->nFilledLen == 0)
+                    OMX_FillThisBuffer(s->handle, pBufHeader);
+            }
+        } else {
+            usleep(1);
+        }
+    }
+
+#ifdef FORMAT_NV12
+    avctx->pix_fmt = AV_PIX_FMT_NV12;
+#endif
+    ret = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "ff_get_buffer failed: %x\n", ret);
+        return ret;
+    }
+    ret = get_data_from_buffer(avctx, frame, pBufHeader);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "get data from buffer failed: %x\n", ret);
+        return ret;
+    }
+    return 0;
+}
+
+static int omx_decode_rec_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    AVFrame *frame = data;
+    int ret = 0;
+    int filelen = avpkt->size;
+    *got_frame = 0;
+    if (filelen) {
+        if (avpkt->data[158] == 0xff && avpkt->data[159] == 0xc2) {
+            av_log(s->avctx, AV_LOG_ERROR, "error: decoder not support progressive jpeg.\n");
+            return AVERROR_EOF;
+        }
+        omx_decode_init(avctx, filelen);
+        omx_decode_image(avctx, avpkt->data, filelen, frame);
+        *got_frame = 1;
+        return AVERROR(EAGAIN);
+    }
+    return AVERROR_EOF;
+}
+
+
+const FFCodec ff_jpeg_omx_decoder = {
+    .p.name           = "jpeg_omx",
+    .p.long_name      = NULL_IF_CONFIG_SMALL("OpenMAX IL decoder"),
+    .p.type           = AVMEDIA_TYPE_VIDEO,
+    .p.id             = AV_CODEC_ID_MJPEG,
+    .p.capabilities   = AV_CODEC_CAP_DR1,
+    .priv_data_size = sizeof(OMXCodecDecoderContext),
+    .init           = omx_decode_init2,
+    FF_CODEC_DECODE_CB(omx_decode_rec_frame),
+    .close          = omx_decode_uninit,
+    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+};
diff --git a/libavcodec/omxjpegencoder.c b/libavcodec/omxjpegencoder.c
new file mode 100644
index 0000000..b6c17bb
--- /dev/null
+++ b/libavcodec/omxjpegencoder.c
@@ -0,0 +1,1203 @@
+/* OMX Video encoder
+* Copyright (C) 2011 Martin Storsjo
+*
+* This file is part of FFmpeg.
+*
+* FFmpeg is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* FFmpeg is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with FFmpeg; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include "config.h"
+
+#if CONFIG_OMX_RPI
+#define OMX_SKIP64BIT
+#endif
+
+#include <dlfcn.h>
+#include <OMX_Core.h>
+#include <OMX_Component.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+
+#include "libavutil/avstring.h"
+#include "libavutil/avutil.h"
+#include "libavutil/common.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/log.h"
+#include "libavutil/opt.h"
+#include "libavutil/time.h"
+#include "avcodec.h"
+#include "h264.h"
+#include "internal.h"
+#include "codec_internal.h"
+#include "encode.h"
+
+#include <omxil/OMX_CsiExt.h>
+// #include "vsi_vendor_ext.h"
+extern int omx_load_count;
+#define TIMEOUT_MS 1000
+#ifdef OMX_SKIP64BIT
+static OMX_TICKS to_omx_ticks(int64_t value)
+{
+    OMX_TICKS s;
+    s.nLowPart  = value & 0xffffffff;
+    s.nHighPart = value >> 32;
+    return s;
+}
+static int64_t from_omx_ticks(OMX_TICKS value)
+{
+    return (((int64_t)value.nHighPart) << 32) | value.nLowPart;
+}
+#else
+#define to_omx_ticks(x) (x)
+#define from_omx_ticks(x) (x)
+#endif
+
+#define INIT_STRUCT(x) do {                                               \
+        x.nSize = sizeof(x);                                              \
+        x.nVersion = s->version;                                          \
+    } while (0)
+#define CHECK(x) do {                                                     \
+        if (x != OMX_ErrorNone) {                                         \
+            av_log(avctx, AV_LOG_ERROR,                                   \
+                   "err %x (%d) on line %d\n", x, x, __LINE__);           \
+            return AVERROR_UNKNOWN;                                       \
+        }                                                                 \
+    } while (0)
+
+typedef struct OMXContext {
+    void *lib;
+    void *lib2;
+    OMX_ERRORTYPE(*ptr_Init)(void);
+    OMX_ERRORTYPE(*ptr_Deinit)(void);
+    OMX_ERRORTYPE(*ptr_ComponentNameEnum)(OMX_STRING, OMX_U32, OMX_U32);
+    OMX_ERRORTYPE(*ptr_GetHandle)(OMX_HANDLETYPE *, OMX_STRING, OMX_PTR, OMX_CALLBACKTYPE *);
+    OMX_ERRORTYPE(*ptr_FreeHandle)(OMX_HANDLETYPE);
+    OMX_ERRORTYPE(*ptr_GetComponentsOfRole)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    OMX_ERRORTYPE(*ptr_GetRolesOfComponent)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    void (*host_init)(void);
+} OMXContext;
+
+static av_cold void *dlsym_prefixed(void *handle, const char *symbol, const char *prefix)
+{
+    char buf[50];
+    snprintf(buf, sizeof(buf), "%s%s", prefix ? prefix : "", symbol);
+    return dlsym(handle, buf);
+}
+
+static av_cold int omx_try_load(OMXContext *s, void *logctx,
+                                const char *libname, const char *prefix,
+                                const char *libname2)
+{
+    if (libname2) {
+        s->lib2 = dlopen(libname2, RTLD_NOW | RTLD_GLOBAL);
+        if (!s->lib2) {
+            av_log(logctx, AV_LOG_WARNING, "%s not found\n", libname2);
+            return AVERROR_ENCODER_NOT_FOUND;
+        }
+        s->host_init = dlsym(s->lib2, "bcm_host_init");
+        if (!s->host_init) {
+            av_log(logctx, AV_LOG_WARNING, "bcm_host_init not found\n");
+            dlclose(s->lib2);
+            s->lib2 = NULL;
+            return AVERROR_ENCODER_NOT_FOUND;
+        }
+    }
+    s->lib = dlopen(libname, RTLD_NOW | RTLD_GLOBAL);
+    if (!s->lib) {
+        av_log(logctx, AV_LOG_WARNING, "%s not found\n", libname);
+        return AVERROR_ENCODER_NOT_FOUND;
+    }
+    s->ptr_Init                = dlsym_prefixed(s->lib, "OMX_Init", prefix);
+    s->ptr_Deinit              = dlsym_prefixed(s->lib, "OMX_Deinit", prefix);
+    s->ptr_ComponentNameEnum   = dlsym_prefixed(s->lib, "OMX_ComponentNameEnum", prefix);
+    s->ptr_GetHandle           = dlsym_prefixed(s->lib, "OMX_GetHandle", prefix);
+    s->ptr_FreeHandle          = dlsym_prefixed(s->lib, "OMX_FreeHandle", prefix);
+    s->ptr_GetComponentsOfRole = dlsym_prefixed(s->lib, "OMX_GetComponentsOfRole", prefix);
+    s->ptr_GetRolesOfComponent = dlsym_prefixed(s->lib, "OMX_GetRolesOfComponent", prefix);
+    if (!s->ptr_Init || !s->ptr_Deinit || !s->ptr_ComponentNameEnum ||
+        !s->ptr_GetHandle || !s->ptr_FreeHandle ||
+        !s->ptr_GetComponentsOfRole || !s->ptr_GetRolesOfComponent) {
+        av_log(logctx, AV_LOG_WARNING, "Not all functions found in %s\n", libname);
+        dlclose(s->lib);
+        s->lib = NULL;
+        if (s->lib2)
+            dlclose(s->lib2);
+        s->lib2 = NULL;
+        return AVERROR_ENCODER_NOT_FOUND;
+    }
+    return 0;
+}
+
+static av_cold OMXContext *omx_init(void *logctx, const char *libname, const char *prefix)
+{
+    static const char *const libnames[] = {
+#if CONFIG_OMX_RPI
+        "/opt/vc/lib/libopenmaxil.so", "/opt/vc/lib/libbcm_host.so",
+#else
+        "libomxil-bellagio.so.0", NULL,
+        "libOMX_Core.so", NULL,
+        "libOmxCore.so", NULL,
+#endif
+        NULL
+    };
+    const char *const *nameptr;
+    int ret = AVERROR_ENCODER_NOT_FOUND;
+    OMXContext *omx_context;
+    OMX_ERRORTYPE error;
+    omx_context = av_mallocz(sizeof(*omx_context));
+    if (!omx_context)
+        return NULL;
+    if (libname) {
+        ret = omx_try_load(omx_context, logctx, libname, prefix, NULL);
+        if (ret < 0) {
+            av_free(omx_context);
+            return NULL;
+        }
+    } else {
+        for (nameptr = libnames; *nameptr; nameptr += 2)
+            if (!(ret = omx_try_load(omx_context, logctx, nameptr[0], prefix, nameptr[1])))
+                break;
+        if (!*nameptr) {
+            av_free(omx_context);
+            return NULL;
+        }
+    }
+
+    if (omx_context->host_init)
+        omx_context->host_init();
+    av_log(NULL, AV_LOG_INFO, "OMX_count load %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        error = omx_context->ptr_Init();
+        if (error != OMX_ErrorNone) {
+            av_log(NULL, AV_LOG_WARNING, "OMX Init error\n");
+        }
+    }
+    omx_load_count++;
+    return omx_context;
+}
+
+static av_cold void omx_deinit(OMXContext *omx_context)
+{
+    if (!omx_context)
+        return;
+    omx_load_count--;
+    av_log(NULL, AV_LOG_INFO, "OMX_count %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        omx_context->ptr_Deinit();
+        dlclose(omx_context->lib);
+    }
+    av_free(omx_context);
+}
+
+typedef struct OMXCodecContext {
+    const AVClass *class;
+    char *libname;
+    char *libprefix;
+    OMXContext *omx_context;
+
+    AVCodecContext *avctx;
+
+    char component_name[OMX_MAX_STRINGNAME_SIZE];
+    OMX_VERSIONTYPE version;
+    OMX_HANDLETYPE handle;
+    int in_port, out_port;
+    OMX_COLOR_FORMATTYPE color_format;
+    int stride, plane_size;
+
+    int num_in_buffers, num_out_buffers;
+    OMX_BUFFERHEADERTYPE **in_buffer_headers;
+    OMX_BUFFERHEADERTYPE **out_buffer_headers;
+    int num_free_in_buffers;
+    OMX_BUFFERHEADERTYPE **free_in_buffers;
+    int num_done_out_buffers;
+    OMX_BUFFERHEADERTYPE **done_out_buffers;
+
+    pthread_mutex_t input_mutex;
+    pthread_cond_t input_cond;
+    pthread_mutex_t output_mutex;
+    pthread_cond_t output_cond;
+
+    pthread_mutex_t state_mutex;
+    pthread_cond_t state_cond;
+    OMX_STATETYPE state;
+    OMX_ERRORTYPE error;
+    OMX_EVENTTYPE event;
+    OMX_COMMANDTYPE cmd;
+
+    int mutex_cond_inited;
+
+    int eos_sent, got_eos;
+
+    uint8_t *output_buf;
+    int output_buf_size;
+
+    int input_zerocopy;
+    int QFactor;
+    int maxpts;
+    int stride_padding;
+} OMXCodecContext;
+
+static void say(OMXCodecContext *s, const char *message, ...)
+{
+    va_list args;
+    size_t str_len;
+    char str[1024];
+    memset(str, 0, sizeof(str));
+    va_start(args, message);
+    vsnprintf(str, sizeof(str) - 1, message, args);
+    va_end(args);
+    str_len = strlen(str);
+    if (str[str_len - 1] != '\n') {
+        str[str_len] = '\n';
+    }
+    av_log(s->avctx, AV_LOG_INFO, "%s", str);
+}
+
+static const char *dump_compression_format(OMXCodecContext *s, OMX_VIDEO_CODINGTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_VIDEO_CodingUnused:
+        return "not used";
+    case OMX_VIDEO_CodingAutoDetect:
+        return "autodetect";
+    case OMX_VIDEO_CodingH263:
+        return "H.263";
+    case OMX_VIDEO_CodingMPEG4:
+        return "MPEG4";
+    case OMX_VIDEO_CodingWMV:
+        return "Windows Media Video";
+    case OMX_VIDEO_CodingRV:
+        return "RealVideo";
+    case OMX_VIDEO_CodingAVC:
+        return "H.264/AVC";
+    case OMX_VIDEO_CodingMJPEG:
+        return "Motion JPEG";
+    case OMX_IMAGE_CodingJPEG:
+        return "JPEG";
+//        case OMX_VIDEO_CodingTheora:     return "OGG Theora";
+
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f, "format type 0x%08x", c);
+        return f;//maybe memleak
+    }
+}
+
+static const char *dump_color_format(OMXCodecContext *s, OMX_COLOR_FORMATTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_COLOR_FormatUnused:
+        return "OMX_COLOR_FormatUnused: not used";
+    case OMX_COLOR_FormatMonochrome:
+        return "OMX_COLOR_FormatMonochrome";
+    case OMX_COLOR_Format8bitRGB332:
+        return "OMX_COLOR_Format8bitRGB332";
+    case OMX_COLOR_Format12bitRGB444:
+        return "OMX_COLOR_Format12bitRGB444";
+    case OMX_COLOR_Format16bitARGB4444:
+        return "OMX_COLOR_Format16bitARGB4444";
+    case OMX_COLOR_Format16bitARGB1555:
+        return "OMX_COLOR_Format16bitARGB1555";
+    case OMX_COLOR_Format16bitRGB565:
+        return "OMX_COLOR_Format16bitRGB565";
+    case OMX_COLOR_Format16bitBGR565:
+        return "OMX_COLOR_Format16bitBGR565";
+    case OMX_COLOR_Format18bitRGB666:
+        return "OMX_COLOR_Format18bitRGB666";
+    case OMX_COLOR_Format18bitARGB1665:
+        return "OMX_COLOR_Format18bitARGB1665";
+    case OMX_COLOR_Format19bitARGB1666:
+        return "OMX_COLOR_Format19bitARGB1666";
+    case OMX_COLOR_Format24bitRGB888:
+        return "OMX_COLOR_Format24bitRGB888";
+    case OMX_COLOR_Format24bitBGR888:
+        return "OMX_COLOR_Format24bitBGR888";
+    case OMX_COLOR_Format24bitARGB1887:
+        return "OMX_COLOR_Format24bitARGB1887";
+    case OMX_COLOR_Format25bitARGB1888:
+        return "OMX_COLOR_Format25bitARGB1888";
+    case OMX_COLOR_Format32bitBGRA8888:
+        return "OMX_COLOR_Format32bitBGRA8888";
+    case OMX_COLOR_Format32bitARGB8888:
+        return "OMX_COLOR_Format32bitARGB8888";
+    case OMX_COLOR_FormatYUV411Planar:
+        return "OMX_COLOR_FormatYUV411Planar";
+    case OMX_COLOR_FormatYUV411PackedPlanar:
+        return "OMX_COLOR_FormatYUV411PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420Planar:
+        return "OMX_COLOR_FormatYUV420Planar: Planar YUV, 4:2:0 (I420)";
+    case OMX_COLOR_FormatYUV420PackedPlanar:
+        return "OMX_COLOR_FormatYUV420PackedPlanar: Planar YUV, 4:2:0 (I420), planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420SemiPlanar:
+        return "OMX_COLOR_FormatYUV420SemiPlanar, Planar YUV, 4:2:0 (NV12), U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422Planar:
+        return "OMX_COLOR_FormatYUV422Planar";
+    case OMX_COLOR_FormatYUV422PackedPlanar:
+        return "OMX_COLOR_FormatYUV422PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV422SemiPlanar:
+        return "OMX_COLOR_FormatYUV422SemiPlanar";
+    case OMX_COLOR_FormatYCbYCr:
+        return "OMX_COLOR_FormatYCbYCr";
+    case OMX_COLOR_FormatYCrYCb:
+        return "OMX_COLOR_FormatYCrYCb";
+    case OMX_COLOR_FormatCbYCrY:
+        return "OMX_COLOR_FormatCbYCrY";
+    case OMX_COLOR_FormatCrYCbY:
+        return "OMX_COLOR_FormatCrYCbY";
+    case OMX_COLOR_FormatYUV444Interleaved:
+        return "OMX_COLOR_FormatYUV444Interleaved";
+    case OMX_COLOR_FormatRawBayer8bit:
+        return "OMX_COLOR_FormatRawBayer8bit";
+    case OMX_COLOR_FormatRawBayer10bit:
+        return "OMX_COLOR_FormatRawBayer10bit";
+    case OMX_COLOR_FormatRawBayer8bitcompressed:
+        return "OMX_COLOR_FormatRawBayer8bitcompressed";
+    case OMX_COLOR_FormatL2:
+        return "OMX_COLOR_FormatL2";
+    case OMX_COLOR_FormatL4:
+        return "OMX_COLOR_FormatL4";
+    case OMX_COLOR_FormatL8:
+        return "OMX_COLOR_FormatL8";
+    case OMX_COLOR_FormatL16:
+        return "OMX_COLOR_FormatL16";
+    case OMX_COLOR_FormatL24:
+        return "OMX_COLOR_FormatL24";
+    case OMX_COLOR_FormatL32:
+        return "OMX_COLOR_FormatL32";
+    case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV420PackedSemiPlanar: Planar YUV, 4:2:0 (NV12), planes fragmented when a frame is split in multiple buffers, U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV422PackedSemiPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_Format18BitBGR666:
+        return "OMX_COLOR_Format18BitBGR666";
+    case OMX_COLOR_Format24BitARGB6666:
+        return "OMX_COLOR_Format24BitARGB6666";
+    case OMX_COLOR_Format24BitABGR6666:
+        return "OMX_COLOR_Format24BitABGR6666";
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f,  "format type 0x%08x", c);
+        return f;
+    }
+}
+
+static void dump_portdef(OMXCodecContext *s, OMX_PARAM_PORTDEFINITIONTYPE *portdef)
+{
+    OMX_VIDEO_PORTDEFINITIONTYPE *viddef = &portdef->format.video;
+    OMX_IMAGE_PORTDEFINITIONTYPE *imgdef = &portdef->format.image;
+
+    say(s, "Port %d is %s, %s, buffers wants:%d needs:%d, size:%d, pop:%d, aligned:%d",
+        portdef->nPortIndex,
+        (portdef->eDir ==  OMX_DirInput ? "input" : "output"),
+        (portdef->bEnabled == OMX_TRUE ? "enabled" : "disabled"),
+        portdef->nBufferCountActual,
+        portdef->nBufferCountMin,
+        portdef->nBufferSize,
+        portdef->bPopulated,
+        portdef->nBufferAlignment);
+
+
+    switch (portdef->eDomain) {
+    case OMX_PortDomainVideo:
+        say(s, "Video type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tBitrate:\t%d\n"
+            "\tFramerate:\t%.02f\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            viddef->nFrameWidth,
+            viddef->nFrameHeight,
+            viddef->nStride,
+            viddef->nSliceHeight,
+            viddef->nBitrate,
+            ((float)viddef->xFramerate / (float)65536),
+            (viddef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, viddef->eCompressionFormat),
+            dump_color_format(s, viddef->eColorFormat));
+        break;
+    case OMX_PortDomainImage:
+        say(s, "Image type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            imgdef->nFrameWidth,
+            imgdef->nFrameHeight,
+            imgdef->nStride,
+            imgdef->nSliceHeight,
+            (imgdef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, imgdef->eCompressionFormat),
+            dump_color_format(s, imgdef->eColorFormat));
+        break;
+    default:
+        break;
+    }
+}
+
+
+static void append_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
+                          int *array_size, OMX_BUFFERHEADERTYPE **array,
+                          OMX_BUFFERHEADERTYPE *buffer)
+{
+    pthread_mutex_lock(mutex);
+    array[(*array_size)++] = buffer;
+    pthread_cond_broadcast(cond);
+    pthread_mutex_unlock(mutex);
+}
+
+static OMX_BUFFERHEADERTYPE *get_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
+                                        int *array_size, OMX_BUFFERHEADERTYPE **array,
+                                        int wait)
+{
+    OMX_BUFFERHEADERTYPE *buffer;
+    pthread_mutex_lock(mutex);
+    if (wait) {
+        while (!*array_size)
+            pthread_cond_wait(cond, mutex);
+    }
+    if (*array_size > 0) {
+        buffer = array[0];
+        (*array_size)--;
+        memmove(&array[0], &array[1], (*array_size) * sizeof(OMX_BUFFERHEADERTYPE *));
+    } else {
+        buffer = NULL;
+    }
+    pthread_mutex_unlock(mutex);
+    return buffer;
+
+}
+
+static int OnPortOutputChanged(OMXCodecContext *s)
+{
+    OMX_ERRORTYPE err;
+    OMX_PARAM_PORTDEFINITIONTYPE portdef;
+    av_log(s->avctx, AV_LOG_INFO, "OnEventOutputChanged\n");
+
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex = s->out_port;
+    OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+
+    dump_portdef(s, &portdef);
+    //s->stride = portdef.format.image.nStride;
+    //s->plane_size = portdef.format.image.nSliceHeight;
+    s->num_out_buffers = portdef.nBufferCountActual;
+    err = OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->out_port, NULL);
+    s->out_buffer_headers = av_mallocz(s->num_out_buffers * sizeof(OMX_BUFFERHEADERTYPE *));
+    for (int i = 0; i < s->num_out_buffers; i++) {
+        err = OMX_AllocateBuffer(s->handle, &s->out_buffer_headers[i],  s->out_port,  s, portdef.nBufferSize);
+    }
+
+    for (int i = 0; i < s->num_out_buffers; i++) {
+        err = OMX_FillThisBuffer(s->handle, s->out_buffer_headers[i]);
+    }
+    return 0 ;
+}
+
+static OMX_ERRORTYPE event_handler(OMX_HANDLETYPE component, OMX_PTR app_data, OMX_EVENTTYPE event,
+                                   OMX_U32 data1, OMX_U32 data2, OMX_PTR event_data)
+{
+    OMXCodecContext *s = app_data;
+    // This uses casts in the printfs, since OMX_U32 actually is a typedef for
+    // unsigned long in official header versions (but there are also modified
+    // versions where it is something else).
+    switch (event) {
+    case OMX_EventError:
+        pthread_mutex_lock(&s->state_mutex);
+        av_log(s->avctx, AV_LOG_ERROR, "OMX error %"PRIx32"\n", (uint32_t) data1);
+        s->error = data1;
+        pthread_cond_broadcast(&s->state_cond);
+        pthread_mutex_unlock(&s->state_mutex);
+        break;
+    case OMX_EventCmdComplete:
+        if (data1 == OMX_CommandStateSet) {
+            pthread_mutex_lock(&s->state_mutex);
+            s->state = data2;
+            av_log(s->avctx, AV_LOG_VERBOSE, "OMX state changed to %"PRIu32"\n", (uint32_t) data2);
+            pthread_cond_broadcast(&s->state_cond);
+            pthread_mutex_unlock(&s->state_mutex);
+        } else if (data1 == OMX_CommandPortDisable) {
+            av_log(s->avctx, AV_LOG_VERBOSE, "OMX port %"PRIu32" disabled\n", (uint32_t) data2);
+        } else if (data1 == OMX_CommandPortEnable) {
+            av_log(s->avctx, AV_LOG_VERBOSE, "OMX port %"PRIu32" enabled\n", (uint32_t) data2);
+        } else {
+            av_log(s->avctx, AV_LOG_VERBOSE, "OMX command complete, command %"PRIu32", value %"PRIu32"\n",
+                   (uint32_t) data1, (uint32_t) data2);
+        }
+        break;
+    case OMX_EventPortSettingsChanged:
+        av_log(s->avctx, AV_LOG_VERBOSE, "OMX port %"PRIu32" settings changed\n", (uint32_t) data1);
+        break;
+    default:
+        av_log(s->avctx, AV_LOG_VERBOSE, "OMX event %d %"PRIx32" %"PRIx32"\n",
+               event, (uint32_t) data1, (uint32_t) data2);
+        break;
+    }
+    pthread_mutex_lock(&s->state_mutex);
+
+    s->event = event;
+    s->state = data2;
+    s->cmd = data1;
+
+    pthread_cond_broadcast(&s->state_cond);
+    pthread_mutex_unlock(&s->state_mutex);
+
+    return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE empty_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                       OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecContext *s = app_data;
+    if (s->input_zerocopy) {
+        if (buffer->pAppPrivate) {
+            if (buffer->pOutputPortPrivate)
+                av_free(buffer->pAppPrivate);
+            else
+                av_frame_free((AVFrame **)&buffer->pAppPrivate);
+            buffer->pAppPrivate = NULL;
+        }
+    }
+    append_buffer(&s->input_mutex, &s->input_cond,
+                  &s->num_free_in_buffers, s->free_in_buffers, buffer);
+    return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE fill_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                      OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecContext *s = app_data;
+    append_buffer(&s->output_mutex, &s->output_cond,
+                  &s->num_done_out_buffers, s->done_out_buffers, buffer);
+    return OMX_ErrorNone;
+}
+
+static const OMX_CALLBACKTYPE callbacks = {
+    event_handler,
+    empty_buffer_done,
+    fill_buffer_done
+};
+
+static av_cold int find_component(OMXContext *omx_context, void *logctx,
+                                  const char *role, char *str, int str_size)
+{
+    OMX_U32 i, num = 0;
+    char **components;
+    int ret = 0;
+
+#if CONFIG_OMX_RPI
+    if (av_strstart(role, "video_encoder.", NULL)) {
+        av_strlcpy(str, "OMX.broadcom.video_encode", str_size);
+        return 0;
+    }
+#endif
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, NULL);
+    if (!num) {
+        av_log(logctx, AV_LOG_WARNING, "No component for role %s found\n", role);
+        return AVERROR_ENCODER_NOT_FOUND;
+    }
+    components = av_mallocz_array(num, sizeof(*components));
+    if (!components)
+        return AVERROR(ENOMEM);
+    for (i = 0; i < num; i++) {
+        components[i] = av_mallocz(OMX_MAX_STRINGNAME_SIZE);
+        if (!components[i]) {
+            ret = AVERROR(ENOMEM);
+            goto end;
+        }
+    }
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, (OMX_U8 **) components);
+    av_strlcpy(str, components[0], str_size);
+end:
+    for (i = 0; i < num; i++)
+        av_free(components[i]);
+    av_free(components);
+    return ret;
+}
+
+static av_cold int wait_for_state(OMXCodecContext *s, OMX_STATETYPE state)
+{
+    int ret = 0;
+    pthread_mutex_lock(&s->state_mutex);
+    while (s->state != state && s->error == OMX_ErrorNone)
+        pthread_cond_wait(&s->state_cond, &s->state_mutex);
+    if (s->error != OMX_ErrorNone)
+        ret = AVERROR_ENCODER_NOT_FOUND;
+    pthread_mutex_unlock(&s->state_mutex);
+    return ret;
+}
+
+static int wait_for_event(AVCodecContext *avctx, OMX_EVENTTYPE event, OMX_COMMANDTYPE cmd, OMX_STATETYPE state,
+                          int timeout)
+{
+    int ret = 0;
+    OMXCodecContext *s = avctx->priv_data;
+    pthread_mutex_lock(&s->state_mutex);
+    while ((s->state != state ||  s->cmd != cmd  || s->event != event) && s->error == OMX_ErrorNone) {
+        pthread_cond_wait(&s->state_cond, &s->state_mutex);
+    }
+    if (s->error != OMX_ErrorNone)
+        ret = -1;
+    pthread_mutex_unlock(&s->state_mutex);
+    return ret;
+}
+
+static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    OMX_PARAM_COMPONENTROLETYPE role_params = { 0 };
+    OMX_PARAM_PORTDEFINITIONTYPE in_port_params = { 0 }, out_port_params = { 0 };
+
+    OMX_PARAM_PORTDEFINITIONTYPE portdef;
+    OMX_IMAGE_PARAM_PORTFORMATTYPE imagePortFormat;
+    OMX_PORT_PARAM_TYPE port;
+    OMX_IMAGE_PARAM_QFACTORTYPE qfactor;
+    OMX_CSI_BUFFER_MODE_CONFIGTYPE bufferMode;
+
+    OMX_ERRORTYPE err;
+    int i;
+
+    s->maxpts = 0;
+    s->version.s.nVersionMajor = 1;
+    s->version.s.nVersionMinor = 1;
+    s->version.s.nRevision     = 2;
+    err = s->omx_context->ptr_GetHandle(&s->handle, s->component_name, s, (OMX_CALLBACKTYPE *) &callbacks);
+    if (err != OMX_ErrorNone) {
+        av_log(s->avctx, AV_LOG_ERROR, "OMX_GetHandle(%s) failed: %x\n", s->component_name, err);
+        return -1;
+    }
+
+    INIT_STRUCT(port);
+    OMX_GetParameter(s->handle, OMX_IndexParamImageInit, &port);
+    if (port.nPorts != 2) {
+        return -1;
+    }
+
+    s->in_port = port.nStartPortNumber;
+    s->out_port = port.nStartPortNumber + 1;
+
+    err = OMX_SendCommand(s->handle, OMX_CommandPortDisable, s->in_port, NULL);
+    CHECK(err);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortDisable, s->in_port, TIMEOUT_MS);
+    err = OMX_SendCommand(s->handle, OMX_CommandPortDisable, s->out_port, NULL);
+    CHECK(err);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortDisable, s->out_port, TIMEOUT_MS);
+
+
+    memset((void *)&imagePortFormat, 0, sizeof(imagePortFormat));
+    INIT_STRUCT(imagePortFormat);
+
+    imagePortFormat.nPortIndex = s->in_port;
+    imagePortFormat.eCompressionFormat = OMX_IMAGE_CodingUnused;
+
+    OMX_SetParameter(s->handle, OMX_IndexParamImagePortFormat, &imagePortFormat);
+
+    s->stride = (avctx->width / 64 * 64) < avctx->width ? ((avctx->width / 64 + 1) * 64) : avctx->width;
+    s->stride_padding = s->stride - avctx->width;
+
+    memset((void *)&portdef, 0, sizeof(portdef));
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex =  s->in_port;
+
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    CHECK(err);
+    int iBufferCount = portdef.nBufferCountActual;
+    int iBufferSize = portdef.nBufferSize;
+    portdef.nBufferAlignment = 64;
+    portdef.format.image.nFrameWidth = avctx->width;
+    portdef.format.image.nFrameHeight = avctx->height;
+    portdef.format.image.nStride = s->stride;
+    portdef.format.image.nSliceHeight = 0;
+    portdef.nBufferSize = s->stride * avctx->height * 3 / 2;
+    portdef.format.image.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
+    portdef.eDomain = OMX_PortDomainImage;
+    portdef.nBufferCountActual = 1 + 2;
+
+    iBufferSize = portdef.nBufferSize;
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    dump_portdef(s, &portdef);
+
+    memset((void *)&portdef, 0, sizeof(portdef));
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex =  s->out_port;
+
+    OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    portdef.format.image.nFrameWidth = avctx->width;
+    portdef.format.image.nFrameHeight = avctx->height;
+    portdef.format.image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+    portdef.nBufferSize = avctx->width * avctx->height * 3 / 2;
+    portdef.nBufferCountActual = 3;
+    OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    CHECK(err);
+    dump_portdef(s, &portdef);
+
+    //OMX_IMAGE_PARAM_QFACTORTYPE qfactor;
+    INIT_STRUCT(qfactor);
+    qfactor.nPortIndex = s->out_port;
+    err = OMX_GetParameter(s->handle, OMX_IndexParamQFactor, &qfactor);
+    CHECK(err);
+    qfactor.nPortIndex = s->out_port;
+    qfactor.nQFactor = s->QFactor;
+    err = OMX_SetParameter(s->handle, OMX_IndexParamQFactor, &qfactor);
+    CHECK(err);
+
+    if (s->input_zerocopy) {
+        INIT_STRUCT(bufferMode);
+        bufferMode.nPortIndex = s->in_port;
+        bufferMode.eMode = OMX_CSI_BUFFER_MODE_DMA;
+        err = OMX_SetParameter(s->handle, OMX_CSI_IndexParamBufferMode, &bufferMode);
+        if (err != OMX_ErrorNone)
+            av_log(avctx, AV_LOG_ERROR, "Unable to set DMA mode at port %d\n", s->in_port);
+        else
+            av_log(avctx, AV_LOG_INFO, "Set DMA mode at port %d\n", s->in_port);
+    }
+
+    OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet,  OMX_StateIdle, TIMEOUT_MS);
+
+    s->num_in_buffers = iBufferCount = 1 + 2;
+    s->in_buffer_headers = av_mallocz(iBufferCount * sizeof(OMX_BUFFERHEADERTYPE *));
+    for (int i = 0; i < iBufferCount; i++) {
+        OMX_AllocateBuffer(s->handle, &s->in_buffer_headers[i],  s->in_port,  s, iBufferSize);
+    }
+    s->num_free_in_buffers = 0;
+    s->num_done_out_buffers = 0;
+    s->free_in_buffers    = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_in_buffers);
+    s->done_out_buffers   = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+    if (!s->free_in_buffers || !s->done_out_buffers)
+        return AVERROR(ENOMEM);
+    for (i = 0; i < s->num_in_buffers; i++)
+        s->free_in_buffers[s->num_free_in_buffers++] = s->in_buffer_headers[i];
+
+    s->num_out_buffers = 3;
+    s->out_buffer_headers = av_mallocz(s->num_out_buffers * sizeof(OMX_BUFFERHEADERTYPE *));
+    for (int i = 0; i < s->num_out_buffers; i++) {
+        OMX_AllocateBuffer(s->handle, &s->out_buffer_headers[i],  s->out_port,  s, iBufferSize);
+    }
+
+    OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->in_port, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortEnable, s->in_port, TIMEOUT_MS);
+    //OMX_SendCommand(s->handle,OMX_CommandPortEnable, s->out_port, NULL);
+    //wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortEnable, s->out_port, TIMEOUT_MS);
+
+    err = OMX_SendCommand(s->handle,  OMX_CommandStateSet, OMX_StateExecuting, NULL);
+    CHECK(err);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet, OMX_StateExecuting, TIMEOUT_MS);
+    OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->out_port, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortEnable, s->out_port, TIMEOUT_MS);
+    for (int i = 0; i < s->num_out_buffers; i++) {
+        err = OMX_FillThisBuffer(s->handle, s->out_buffer_headers[i]);
+    }
+    av_log(s->avctx, AV_LOG_INFO, "finish omx_component_init_encoder\n");
+    return 0;
+}
+
+static av_cold void cleanup(OMXCodecContext *s)
+{
+    int i, executing;
+
+    pthread_mutex_lock(&s->state_mutex);
+    executing = s->state == OMX_StateExecuting;
+    pthread_mutex_unlock(&s->state_mutex);
+    if (executing || s->input_zerocopy) {
+        OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
+        wait_for_state(s, OMX_StateIdle);
+        OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateLoaded, NULL);
+        for (i = 0; i < s->num_in_buffers; i++) {
+            OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                                           &s->num_free_in_buffers, s->free_in_buffers, 1);
+            if (s->input_zerocopy)
+                buffer->pBuffer = NULL;
+            OMX_FreeBuffer(s->handle, s->in_port, buffer);
+        }
+        for (i = 0; i < s->num_out_buffers; i++) {
+            OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                                           &s->num_done_out_buffers, s->done_out_buffers, 1);
+            OMX_FreeBuffer(s->handle, s->out_port, buffer);
+        }
+        wait_for_state(s, OMX_StateLoaded);
+    }
+    if (s->handle) {
+        s->omx_context->ptr_FreeHandle(s->handle);
+        s->handle = NULL;
+    }
+
+    omx_deinit(s->omx_context);
+    s->omx_context = NULL;
+    if (s->mutex_cond_inited) {
+        pthread_cond_destroy(&s->state_cond);
+        pthread_mutex_destroy(&s->state_mutex);
+        pthread_cond_destroy(&s->input_cond);
+        pthread_mutex_destroy(&s->input_mutex);
+        pthread_cond_destroy(&s->output_cond);
+        pthread_mutex_destroy(&s->output_mutex);
+        s->mutex_cond_inited = 0;
+    }
+
+    av_freep(&s->in_buffer_headers);
+    av_freep(&s->out_buffer_headers);
+    av_freep(&s->free_in_buffers);
+    av_freep(&s->done_out_buffers);
+    av_freep(&s->output_buf);
+
+}
+
+static av_cold int omx_encode_init(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    int ret = AVERROR_ENCODER_NOT_FOUND;
+    const char *role;
+    OMX_BUFFERHEADERTYPE *buffer;
+    OMX_ERRORTYPE err;
+
+    s->omx_context = omx_init(avctx, s->libname, s->libprefix);
+    if (!s->omx_context)
+        return AVERROR_ENCODER_NOT_FOUND;
+
+    pthread_mutex_init(&s->state_mutex, NULL);
+    pthread_cond_init(&s->state_cond, NULL);
+    pthread_mutex_init(&s->input_mutex, NULL);
+    pthread_cond_init(&s->input_cond, NULL);
+    pthread_mutex_init(&s->output_mutex, NULL);
+    pthread_cond_init(&s->output_cond, NULL);
+    s->mutex_cond_inited = 1;
+    s->avctx = avctx;
+    s->state = OMX_StateLoaded;
+    s->error = OMX_ErrorNone;
+
+    switch (avctx->codec->id) {
+    case AV_CODEC_ID_MJPEG:
+        role = "image_encoder.jpeg";
+        break;
+    default:
+        return AVERROR(ENOSYS);
+    }
+
+    if ((ret = find_component(s->omx_context, avctx, role, s->component_name, sizeof(s->component_name))) < 0)
+        goto fail;
+
+    av_log(avctx, AV_LOG_INFO, "Using %s\n", s->component_name);
+
+    if ((ret = omx_component_init(avctx, role)) < 0)
+        goto fail;
+#if 0
+    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+        while (1) {
+            buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                                &s->num_done_out_buffers, s->done_out_buffers, 1);
+            if (buffer->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
+                if ((ret = av_reallocp(&avctx->extradata,
+                                       avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
+                    avctx->extradata_size = 0;
+                    goto fail;
+                }
+                memcpy(avctx->extradata + avctx->extradata_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
+                avctx->extradata_size += buffer->nFilledLen;
+                memset(avctx->extradata + avctx->extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+            }
+            err = OMX_FillThisBuffer(s->handle, buffer);
+            if (err != OMX_ErrorNone) {
+                append_buffer(&s->output_mutex, &s->output_cond,
+                              &s->num_done_out_buffers, s->done_out_buffers, buffer);
+                av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+                ret = AVERROR_UNKNOWN;
+                goto fail;
+            }
+            if (avctx->codec->id == AV_CODEC_ID_H264) {
+                // For H.264, the extradata can be returned in two separate buffers
+                // (the videocore encoder on raspberry pi does this);
+                // therefore check that we have got both SPS and PPS before continuing.
+                int nals[32] = { 0 };
+                int i;
+                for (i = 0; i + 4 < avctx->extradata_size; i++) {
+                    if (!avctx->extradata[i + 0] &&
+                        !avctx->extradata[i + 1] &&
+                        !avctx->extradata[i + 2] &&
+                        avctx->extradata[i + 3] == 1) {
+                        nals[avctx->extradata[i + 4] & 0x1f]++;
+                    }
+                }
+                if (nals[H264_NAL_SPS] && nals[H264_NAL_PPS])
+                    break;
+            } else {
+                if (avctx->extradata_size > 0)
+                    break;
+            }
+        }
+    }
+#endif
+
+    return 0;
+fail:
+    return ret;
+}
+
+static int omx_line_copy(AVCodecContext *avctx, const AVFrame *frame, OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    memset(buffer->pBuffer, 0, s->stride * frame->height * 3 / 2);
+    for (int i = 0; i < frame->height; i++) {
+        memcpy(buffer->pBuffer + i * s->stride, frame->data[0] + i * frame->width, frame->width);
+    }
+    for (int i = 0; i < frame->height / 2; i++) {
+        memcpy(buffer->pBuffer + s->stride * frame->height + i * s->stride, frame->data[1] + +i * frame->width, frame->width);
+    }
+    return 0;
+}
+
+static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
+                            const AVFrame *frame, int *got_packet)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    int ret = 0;
+    OMX_BUFFERHEADERTYPE *buffer;
+    OMX_ERRORTYPE err;
+    AVFrame *local = NULL;
+    int had_partial = 0;
+
+    if (frame) {
+        uint8_t *dst[4];
+        int linesize[4];
+        int need_copy;
+        buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                            &s->num_free_in_buffers, s->free_in_buffers, 1);
+
+        //buffer->nFilledLen = av_image_fill_arrays(dst, linesize, buffer->pBuffer, avctx->pix_fmt, s->stride, s->plane_size, 1);
+        buffer->nFilledLen = s->stride * frame->height * 3 / 2;
+        buffer->nAllocLen = buffer->nFilledLen;
+
+        if (s->stride_padding == 0) {
+            if (s->input_zerocopy) {
+                AVFrame *local = av_frame_clone(frame);
+                buffer->pAppPrivate = local;
+                buffer->pOutputPortPrivate = NULL;
+                buffer->pBuffer = ((OMX_BUFFERHEADERTYPE *)(local->opaque))->pBuffer;
+            } else {
+                memcpy(buffer->pBuffer, frame->data[0], frame->height * frame->width);
+                memcpy(buffer->pBuffer + frame->height * frame->width, frame->data[1], frame->height * frame->width / 2);
+            }
+        } else if (s->stride_padding > 0) {
+            omx_line_copy(avctx, frame, buffer);
+        } else {
+            av_log(avctx, AV_LOG_ERROR, "error stride padding size: %d\n", s->stride_padding);
+            return AVERROR_UNKNOWN;
+        }
+        buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;
+        buffer->nOffset = 0;
+        // Convert the timestamps to microseconds; some encoders can ignore
+        // the framerate and do VFR bit allocation based on timestamps.
+        buffer->nTimeStamp = to_omx_ticks(av_rescale_q(frame->pts, avctx->time_base, AV_TIME_BASE_Q));
+        if (frame->pict_type == AV_PICTURE_TYPE_I) {
+#if CONFIG_OMX_RPI
+            OMX_CONFIG_BOOLEANTYPE config = {0, };
+            INIT_STRUCT(config);
+            config.bEnabled = OMX_TRUE;
+            err = OMX_SetConfig(s->handle, OMX_IndexConfigBrcmVideoRequestIFrame, &config);
+            if (err != OMX_ErrorNone) {
+                av_log(avctx, AV_LOG_ERROR, "OMX_SetConfig(RequestIFrame) failed: %x\n", err);
+                return AVERROR_UNKNOWN;
+            }
+#else
+            OMX_CONFIG_INTRAREFRESHVOPTYPE config = {0, };
+            INIT_STRUCT(config);
+            config.nPortIndex = s->out_port;
+            config.IntraRefreshVOP = OMX_TRUE;
+            err = OMX_SetConfig(s->handle, OMX_IndexConfigVideoIntraVOPRefresh, &config);
+            if (err != OMX_ErrorNone) {
+                av_log(avctx, AV_LOG_ERROR, "OMX_SetConfig(IntraVOPRefresh) failed: %x\n", err);
+                return AVERROR_UNKNOWN;
+            }
+#endif
+        }
+        err = OMX_EmptyThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_EmptyThisBuffer failed: %x\n", err);
+            return AVERROR_UNKNOWN;
+        }
+    } else if (!s->eos_sent) {
+#if 1
+        buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                            &s->num_free_in_buffers, s->free_in_buffers, 1);
+
+        buffer->nFilledLen = 0;
+        buffer->nFlags = OMX_BUFFERFLAG_EOS;
+        buffer->pAppPrivate = buffer->pOutputPortPrivate = NULL;
+        err = OMX_EmptyThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_EmptyThisBuffer failed: %x\n", err);
+            return AVERROR_UNKNOWN;
+        }
+        s->eos_sent = 1;
+#endif
+    }
+
+    while (!*got_packet && ret == 0 && !s->got_eos) {
+        // If not flushing, just poll the queue if there's finished packets.
+        // If flushing, do a blocking wait until we either get a completed
+        // packet, or get EOS.
+        buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                            &s->num_done_out_buffers, s->done_out_buffers,
+                            !frame || had_partial);
+        if (!buffer)
+            break;
+
+        if (buffer->nFlags & OMX_BUFFERFLAG_EOS)
+            s->got_eos = 1;
+
+        if (buffer->nFlags & OMX_BUFFERFLAG_CODECCONFIG && avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER && 0) {
+            if ((ret = av_reallocp(&avctx->extradata,
+                                   avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
+                avctx->extradata_size = 0;
+                goto end;
+            }
+            memcpy(avctx->extradata + avctx->extradata_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
+            avctx->extradata_size += buffer->nFilledLen;
+            memset(avctx->extradata + avctx->extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+        } else {
+            if (!(buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) || !pkt->data) {
+                // If the output packet isn't preallocated, just concatenate everything in our
+                // own buffer
+                int newsize = s->output_buf_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE;
+                if ((ret = av_reallocp(&s->output_buf, newsize)) < 0) {
+                    s->output_buf_size = 0;
+                    goto end;
+                }
+                memcpy(s->output_buf + s->output_buf_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
+                s->output_buf_size += buffer->nFilledLen;
+                if (!s->output_buf_size) {
+                    av_freep(pkt);
+                    av_freep(&s->output_buf);
+                    s->output_buf_size = 0;
+                    goto end;
+                }
+                if (buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) {
+                    if ((ret = av_packet_from_data(pkt, s->output_buf, s->output_buf_size)) < 0) {
+                        av_freep(&s->output_buf);
+                        s->output_buf_size = 0;
+                        goto end;
+                    }
+                    s->output_buf = NULL;
+                    s->output_buf_size = 0;
+                }
+#if CONFIG_OMX_RPI
+                had_partial = 1;
+#endif
+            } else {
+                // End of frame, and the caller provided a preallocated frame
+                if ((ret = ff_alloc_packet(avctx, pkt, s->output_buf_size + buffer->nFilledLen)) < 0) {
+                    av_log(avctx, AV_LOG_ERROR, "Error getting output packet of size %d.\n",
+                           (int)(s->output_buf_size + buffer->nFilledLen));
+                    goto end;
+                }
+                memcpy(pkt->data, s->output_buf, s->output_buf_size);
+                memcpy(pkt->data + s->output_buf_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
+                av_freep(&s->output_buf);
+                s->output_buf_size = 0;
+            }
+            if (buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) {
+                pkt->pts = av_rescale_q(from_omx_ticks(buffer->nTimeStamp), AV_TIME_BASE_Q, avctx->time_base);
+                // We don't currently enable B-frames for the encoders, so set
+                // pkt->dts = pkt->pts. (The calling code behaves worse if the encoder
+                // doesn't set the dts).
+                if (pkt->pts < s->maxpts) {
+                    pkt->pts = s->maxpts + 1;
+                }
+                s->maxpts = (s->maxpts > pkt->pts) ? s->maxpts : pkt->pts;
+                pkt->dts = pkt->pts;
+                if (buffer->nFlags & OMX_BUFFERFLAG_SYNCFRAME)
+                    pkt->flags |= AV_PKT_FLAG_KEY;
+                *got_packet = 1;
+            }
+        }
+end:
+        err = OMX_FillThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->output_mutex, &s->output_cond, &s->num_done_out_buffers, s->done_out_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+            ret = AVERROR_UNKNOWN;
+        }
+    }
+    return ret;
+}
+
+static av_cold int omx_encode_end(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    cleanup(s);
+    return 0;
+}
+
+#define OFFSET(x) offsetof(OMXCodecContext, x)
+#define VDE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+#define VE  AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+static const AVOption options_jpeg[] = {
+    { "omx_libname", "OpenMAX library name", OFFSET(libname), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
+    { "omx_libprefix", "OpenMAX library prefix", OFFSET(libprefix), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
+    { "zerocopy", "Try to avoid copying input frames if possible", OFFSET(input_zerocopy), AV_OPT_TYPE_INT, { .i64 = CONFIG_OMX_RPI }, 0, 1, VE },
+    { "QFactor",  "Set the encoding QFactor", OFFSET(QFactor), AV_OPT_TYPE_INT,   {2}, 0, 10, VE},
+    { NULL }
+};
+
+
+
+static const enum AVPixelFormat omx_encoder_pix_fmts[] = {
+    AV_PIX_FMT_NV12, AV_PIX_FMT_NONE
+};
+
+
+static const AVClass omx_jpegenc_class = {
+    .class_name = "jpeg_omx",
+    .item_name  = av_default_item_name,
+    .option     = options_jpeg,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+const FFCodec ff_jpeg_omx_encoder = {
+    .p.name             = "jpeg_omx",
+    .p.long_name      = NULL_IF_CONFIG_SMALL("OpenMAX IL JPEG video encoder"),
+    .p.type             = AVMEDIA_TYPE_VIDEO,
+    .p.id               = AV_CODEC_ID_MJPEG,
+    .p.pix_fmts         = omx_encoder_pix_fmts,
+    .p.capabilities     = AV_CODEC_CAP_DELAY,
+    .p.priv_class       = &omx_jpegenc_class,
+    .priv_data_size   = sizeof(OMXCodecContext),
+    .init             = omx_encode_init,
+    FF_CODEC_ENCODE_CB(omx_encode_frame),
+    .close            = omx_encode_end,
+    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .p.wrapper_name = "jpeg_omx",
+};
+
+
diff --git a/libavutil/Makefile b/libavutil/Makefile
index 9435a0b..2342aaf 100644
--- a/libavutil/Makefile
+++ b/libavutil/Makefile
@@ -189,6 +189,7 @@ OBJS-$(CONFIG_DXVA2)                    += hwcontext_dxva2.o
 OBJS-$(CONFIG_LIBDRM)                   += hwcontext_drm.o
 OBJS-$(CONFIG_MACOS_KPERF)              += macos_kperf.o
 OBJS-$(CONFIG_MEDIACODEC)               += hwcontext_mediacodec.o
+OBJS-$(CONFIG_OMX)                      += hwcontext_omx.o
 OBJS-$(CONFIG_OPENCL)                   += hwcontext_opencl.o
 OBJS-$(CONFIG_QSV)                      += hwcontext_qsv.o
 OBJS-$(CONFIG_VAAPI)                    += hwcontext_vaapi.o
diff --git a/libavutil/cpu.c b/libavutil/cpu.c
index 0035e92..b8506f3 100644
--- a/libavutil/cpu.c
+++ b/libavutil/cpu.c
@@ -43,7 +43,7 @@
 #include <sys/param.h>
 #endif
 #include <sys/types.h>
-#include <sys/sysctl.h>
+#include <linux/sysctl.h>
 #endif
 #if HAVE_UNISTD_H
 #include <unistd.h>
diff --git a/libavutil/hwcontext.h b/libavutil/hwcontext.h
index c18b7e1..5c07e86 100644
--- a/libavutil/hwcontext.h
+++ b/libavutil/hwcontext.h
@@ -34,6 +34,7 @@ enum AVHWDeviceType {
     AV_HWDEVICE_TYPE_VIDEOTOOLBOX,
     AV_HWDEVICE_TYPE_D3D11VA,
     AV_HWDEVICE_TYPE_DRM,
+    AV_HWDEVICE_TYPE_OMX,
     AV_HWDEVICE_TYPE_OPENCL,
     AV_HWDEVICE_TYPE_MEDIACODEC,
     AV_HWDEVICE_TYPE_VULKAN,
diff --git a/libavutil/hwcontext_omx.c b/libavutil/hwcontext_omx.c
new file mode 100755
index 0000000..f0ff9ec
--- /dev/null
+++ b/libavutil/hwcontext_omx.c
@@ -0,0 +1,75 @@
+#include <dlfcn.h>
+
+#include "config.h"
+#include "buffer.h"
+#include "common.h"
+#include "hwcontext.h"
+#include "hwcontext_internal.h"
+//#include "hwcontext_omx.h"
+
+typedef struct OMXDeviceContext {
+    //AVOMXDeviceContext ctx;
+
+    void *libmedia;
+    //media_status_t (*create_surface)(ANativeWindow **surface);
+} OMXDeviceContext;
+
+
+static int omx_device_create(AVHWDeviceContext *ctx, const char *device,
+                             AVDictionary *opts, int flags)
+{
+    //const AVDictionaryEntry *entry = NULL;
+    //OMXDeviceContext *s = ctx->hwctx;
+    //AVOMXDeviceContext *dev = &s->ctx;
+
+    if (device && device[0]) {
+        av_log(ctx, AV_LOG_ERROR, "Device selection unsupported.\n");
+        return AVERROR_UNKNOWN;
+    }
+
+
+    return 0;
+}
+
+static int omx_device_init(AVHWDeviceContext *ctx)
+{
+    OMXDeviceContext *s = ctx->hwctx;
+    //AVOMXDeviceContext *dev = (AVOMXDeviceContext *)s;
+
+    s->libmedia = dlopen("libomxil-bellagio.so", RTLD_NOW);
+    if (!s->libmedia)
+        return AVERROR_UNKNOWN;
+
+    return 0;
+}
+
+static void omx_device_uninit(AVHWDeviceContext *ctx)
+{
+    OMXDeviceContext *s = ctx->hwctx;
+    //AVOMXDeviceContext *dev = ctx->hwctx;
+    if (!s->libmedia)
+        return;
+
+
+    dlclose(s->libmedia);
+    s->libmedia = NULL;
+}
+
+const HWContextType ff_hwcontext_type_OMX = {
+    .type                 = AV_HWDEVICE_TYPE_OMX,
+    .name                 = "openmax",
+
+    .device_hwctx_size    = sizeof(OMXDeviceContext),
+
+    .device_create        = omx_device_create,
+    .device_init          = omx_device_init,
+    .device_uninit        = omx_device_uninit,
+
+    .pix_fmts = (const enum AVPixelFormat[])
+    {
+        AV_PIX_FMT_NV12,
+        AV_PIX_FMT_NONE
+    },
+};
+
+
diff --git a/tests/api/Makefile b/tests/api/Makefile
index c96e636..62ff4d0 100644
--- a/tests/api/Makefile
+++ b/tests/api/Makefile
@@ -1,9 +1,9 @@
 APITESTPROGS-$(call ENCDEC, FLAC, FLAC) += api-flac
 APITESTPROGS-$(call DEMDEC, H264, H264) += api-h264
 APITESTPROGS-$(call DEMDEC, H264, H264) += api-h264-slice
-APITESTPROGS-yes += api-seek
+# APITESTPROGS-yes += api-seek
 APITESTPROGS-$(call DEMDEC, H263, H263) += api-band
-APITESTPROGS-$(HAVE_THREADS) += api-threadmessage
+# APITESTPROGS-$(HAVE_THREADS) += api-threadmessage
 APITESTPROGS += $(APITESTPROGS-yes)
 
 APITESTOBJS  := $(APITESTOBJS:%=$(APITESTSDIR)%) $(APITESTPROGS:%=$(APITESTSDIR)/%-test.o)
@@ -14,6 +14,8 @@ $(APITESTOBJS): | $(sort $(dir $(APITESTOBJS)))
 $(APITESTOBJS) $(APITESTOBJS:.o=.i): CPPFLAGS += -DTEST
 $(APITESTOBJS) $(APITESTOBJS:.o=.i): CFLAGS += -Umain
 
+all:$(APITESTPROGS)
+
 $(APITESTPROGS): %$(EXESUF): %.o $(FF_DEP_LIBS)
 	$(LD) $(LDFLAGS) $(LDEXEFLAGS) $(LD_O) $(filter %.o,$^) $(FF_EXTRALIBS) $(ELIBS)
 
-- 
2.17.1

