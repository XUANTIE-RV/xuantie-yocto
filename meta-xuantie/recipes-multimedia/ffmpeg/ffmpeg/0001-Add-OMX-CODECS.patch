From 651ec5d0cea329ecdd91a81e0c0f7025a2341904 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=81=92=E7=95=85?= <dongkaiyuan.dky@alibaba-inc.com>
Date: Mon, 18 Sep 2023 16:53:11 +0000
Subject: [PATCH] Add OMX CODECS

---
 configure                         |    6 +
 fftools/Makefile                  |    2 +
 libavcodec/Makefile               |    6 +
 libavcodec/allcodecs.c            |   11 +-
 libavcodec/omx.c                  |  667 ++++++++--
 libavcodec/omxdecoder.c           | 1923 +++++++++++++++++++++++++++++
 libavcodec/omxjpegdecoder.c       | 1099 +++++++++++++++++
 libavcodec/omxjpegencoder.c       | 1234 ++++++++++++++++++
 libavcodec/vsi_vendor_ext.h       |  797 ++++++++++++
 libavutil/Makefile                |    3 +-
 libavutil/hwcontext.h             |    1 +
 libavutil/hwcontext_omx.c         |   75 ++
 tests/api/Makefile                |    9 +-
 tests/api/api-dec-test.c          |  169 +++
 tests/api/compile-api-dec-test.sh |    4 +
 15 files changed, 5924 insertions(+), 82 deletions(-)
 create mode 100755 libavcodec/omxdecoder.c
 create mode 100755 libavcodec/omxjpegdecoder.c
 create mode 100644 libavcodec/omxjpegencoder.c
 create mode 100644 libavcodec/vsi_vendor_ext.h
 create mode 100755 libavutil/hwcontext_omx.c
 create mode 100644 tests/api/api-dec-test.c
 create mode 100644 tests/api/compile-api-dec-test.sh

diff --git a/configure b/configure
index 3c1b7d4..1070579 100755
--- a/configure
+++ b/configure
@@ -3054,6 +3054,12 @@ h264_mf_encoder_deps="mediafoundation"
 h264_mmal_decoder_deps="mmal"
 h264_nvenc_encoder_deps="nvenc"
 h264_omx_encoder_deps="omx"
+hevc_omx_encoder_deps="omx"
+jpeg_omx_encoder_deps="omx"
+h264_omx_decoder_deps="omx"
+hevc_omx_decoder_deps="omx"
+jpeg_omx_decoder_deps="omx"
+jpeg_omx_decoder_deps="omx"
 h264_qsv_decoder_select="h264_mp4toannexb_bsf qsvdec"
 h264_qsv_encoder_select="qsvenc"
 h264_rkmpp_decoder_deps="rkmpp"
diff --git a/fftools/Makefile b/fftools/Makefile
index 5affaa3..56e5fc5 100644
--- a/fftools/Makefile
+++ b/fftools/Makefile
@@ -43,11 +43,13 @@ install-progs-$(CONFIG_SHARED): install-libs
 install-progs: install-progs-yes $(AVPROGS)
 	$(Q)mkdir -p "$(BINDIR)"
 	$(INSTALL) -c -m 755 $(AVPROGS) "$(BINDIR)"
+	$(INSTALL) -c -m 755 $(APITESTPROGS) "$(BINDIR)"
 
 uninstall: uninstall-progs
 
 uninstall-progs:
 	$(RM) $(addprefix "$(BINDIR)/", $(ALLAVPROGS))
+	$(RM) $(addprefix "$(BINDIR)/", $(APITESTPROGS))
 
 clean::
 	$(RM) $(ALLAVPROGS) $(ALLAVPROGS_G) $(CLEANSUFFIXES:%=fftools/%)
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 5a6ea59..458001c 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -367,6 +367,12 @@ OBJS-$(CONFIG_H264_NVENC_ENCODER)      += nvenc_h264.o
 OBJS-$(CONFIG_NVENC_ENCODER)           += nvenc_h264.o
 OBJS-$(CONFIG_NVENC_H264_ENCODER)      += nvenc_h264.o
 OBJS-$(CONFIG_H264_OMX_ENCODER)        += omx.o
+OBJS-$(CONFIG_H264_OMX_DECODER)        += omxdecoder.o
+OBJS-$(CONFIG_HEVC_OMX_DECODER)        += omxdecoder.o
+OBJS-$(CONFIG_HEVC_OMX_ENCODER)        += omxdecoder.o
+OBJS-$(CONFIG_JPEG_OMX_DECODER)       += omxjpegdecoder.o
+OBJS-$(CONFIG_JPEG_OMX_ENCODER)       += omxjpegencoder.o
+OBJS-$(CONFIG_VP9_OMX_DECODER)        += omxdecoder.o
 OBJS-$(CONFIG_H264_QSV_DECODER)        += qsvdec_h2645.o
 OBJS-$(CONFIG_H264_QSV_ENCODER)        += qsvenc_h264.o
 OBJS-$(CONFIG_H264_RKMPP_DECODER)      += rkmppdec.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 80f128c..a3d7d7a 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -29,6 +29,14 @@
 #include "avcodec.h"
 #include "version.h"
 
+extern AVCodec ff_vp9_omx_decoder;
+extern AVCodec ff_hevc_omx_decoder;
+extern AVCodec ff_hevc_omx_encoder;
+extern AVCodec ff_h264_omx_decoder;
+extern AVCodec ff_h264_omx_encoder;
+extern AVCodec ff_jpeg_omx_encoder;
+extern AVCodec ff_jpeg_omx_decoder;
+
 extern AVCodec ff_a64multi_encoder;
 extern AVCodec ff_a64multi5_encoder;
 extern AVCodec ff_aasc_decoder;
@@ -166,7 +174,6 @@ extern AVCodec ff_indeo4_decoder;
 extern AVCodec ff_indeo5_decoder;
 extern AVCodec ff_interplay_video_decoder;
 extern AVCodec ff_jpeg2000_encoder;
-extern AVCodec ff_jpeg2000_decoder;
 extern AVCodec ff_jpegls_encoder;
 extern AVCodec ff_jpegls_decoder;
 extern AVCodec ff_jv_decoder;
@@ -765,7 +772,6 @@ extern AVCodec ff_h264_amf_encoder;
 extern AVCodec ff_h264_cuvid_decoder;
 extern AVCodec ff_h264_mf_encoder;
 extern AVCodec ff_h264_nvenc_encoder;
-extern AVCodec ff_h264_omx_encoder;
 extern AVCodec ff_h264_qsv_encoder;
 extern AVCodec ff_h264_v4l2m2m_encoder;
 extern AVCodec ff_h264_vaapi_encoder;
@@ -795,7 +801,6 @@ extern AVCodec ff_mpeg2_qsv_encoder;
 extern AVCodec ff_mpeg2_vaapi_encoder;
 extern AVCodec ff_mpeg4_cuvid_decoder;
 extern AVCodec ff_mpeg4_mediacodec_decoder;
-extern AVCodec ff_mpeg4_omx_encoder;
 extern AVCodec ff_mpeg4_v4l2m2m_encoder;
 extern AVCodec ff_vc1_cuvid_decoder;
 extern AVCodec ff_vp8_cuvid_decoder;
diff --git a/libavcodec/omx.c b/libavcodec/omx.c
index 0a6a308..f07da13 100644
--- a/libavcodec/omx.c
+++ b/libavcodec/omx.c
@@ -44,6 +44,9 @@
 #include "h264.h"
 #include "internal.h"
 
+#include "vsi_vendor_ext.h"
+static int omx_load_count = 0;
+
 #ifdef OMX_SKIP64BIT
 static OMX_TICKS to_omx_ticks(int64_t value)
 {
@@ -76,13 +79,13 @@ static int64_t from_omx_ticks(OMX_TICKS value)
 typedef struct OMXContext {
     void *lib;
     void *lib2;
-    OMX_ERRORTYPE (*ptr_Init)(void);
-    OMX_ERRORTYPE (*ptr_Deinit)(void);
-    OMX_ERRORTYPE (*ptr_ComponentNameEnum)(OMX_STRING, OMX_U32, OMX_U32);
-    OMX_ERRORTYPE (*ptr_GetHandle)(OMX_HANDLETYPE*, OMX_STRING, OMX_PTR, OMX_CALLBACKTYPE*);
-    OMX_ERRORTYPE (*ptr_FreeHandle)(OMX_HANDLETYPE);
-    OMX_ERRORTYPE (*ptr_GetComponentsOfRole)(OMX_STRING, OMX_U32*, OMX_U8**);
-    OMX_ERRORTYPE (*ptr_GetRolesOfComponent)(OMX_STRING, OMX_U32*, OMX_U8**);
+    OMX_ERRORTYPE(*ptr_Init)(void);
+    OMX_ERRORTYPE(*ptr_Deinit)(void);
+    OMX_ERRORTYPE(*ptr_ComponentNameEnum)(OMX_STRING, OMX_U32, OMX_U32);
+    OMX_ERRORTYPE(*ptr_GetHandle)(OMX_HANDLETYPE *, OMX_STRING, OMX_PTR, OMX_CALLBACKTYPE *);
+    OMX_ERRORTYPE(*ptr_FreeHandle)(OMX_HANDLETYPE);
+    OMX_ERRORTYPE(*ptr_GetComponentsOfRole)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    OMX_ERRORTYPE(*ptr_GetRolesOfComponent)(OMX_STRING, OMX_U32 *, OMX_U8 **);
     void (*host_init)(void);
 } OMXContext;
 
@@ -139,19 +142,20 @@ static av_cold int omx_try_load(OMXContext *s, void *logctx,
 
 static av_cold OMXContext *omx_init(void *logctx, const char *libname, const char *prefix)
 {
-    static const char * const libnames[] = {
+    static const char *const libnames[] = {
 #if CONFIG_OMX_RPI
         "/opt/vc/lib/libopenmaxil.so", "/opt/vc/lib/libbcm_host.so",
 #else
+        "libomxil-bellagio.so.0", NULL,
         "libOMX_Core.so", NULL,
         "libOmxCore.so", NULL,
 #endif
         NULL
     };
-    const char* const* nameptr;
+    const char *const *nameptr;
     int ret = AVERROR_ENCODER_NOT_FOUND;
     OMXContext *omx_context;
-
+    OMX_ERRORTYPE error;
     omx_context = av_mallocz(sizeof(*omx_context));
     if (!omx_context)
         return NULL;
@@ -173,7 +177,14 @@ static av_cold OMXContext *omx_init(void *logctx, const char *libname, const cha
 
     if (omx_context->host_init)
         omx_context->host_init();
-    omx_context->ptr_Init();
+    av_log(NULL, AV_LOG_INFO, "OMX_count load %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        error = omx_context->ptr_Init();
+        if (error != OMX_ErrorNone) {
+            av_log(NULL, AV_LOG_WARNING, "OMX Init error\n");
+        }
+    }
+    omx_load_count++;
     return omx_context;
 }
 
@@ -181,8 +192,12 @@ static av_cold void omx_deinit(OMXContext *omx_context)
 {
     if (!omx_context)
         return;
-    omx_context->ptr_Deinit();
-    dlclose(omx_context->lib);
+    omx_load_count--;
+    av_log(NULL, AV_LOG_INFO, "OMX_count %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        omx_context->ptr_Deinit();
+        dlclose(omx_context->lib);
+    }
     av_free(omx_context);
 }
 
@@ -227,10 +242,238 @@ typedef struct OMXCodecContext {
 
     int input_zerocopy;
     int profile;
+    int level;
+    int bitrate;
+    int QpI;
+    int QpP;
+    int gop_size;
+    int dts_now;
+    int dts_duration;
+    int pts_pre;
+    int stride_padding;
 } OMXCodecContext;
 
+
+
+static void say(OMXCodecContext *s, const char *message, ...)
+{
+    va_list args;
+    size_t str_len;
+    char str[1024];
+    memset(str, 0, sizeof(str));
+    va_start(args, message);
+    vsnprintf(str, sizeof(str) - 1, message, args);
+    va_end(args);
+    str_len = strlen(str);
+    if (str[str_len - 1] != '\n') {
+        str[str_len] = '\n';
+    }
+
+    av_log(s->avctx, AV_LOG_INFO, "%s", str);
+}
+
+
+static const char *dump_compression_format(OMXCodecContext *s, OMX_VIDEO_CODINGTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_VIDEO_CodingUnused:
+        return "not used";
+    case OMX_VIDEO_CodingAutoDetect:
+        return "autodetect";
+    case OMX_VIDEO_CodingMPEG2:
+        return "MPEG2";
+    case OMX_VIDEO_CodingH263:
+        return "H.263";
+    case OMX_VIDEO_CodingMPEG4:
+        return "MPEG4";
+    case OMX_VIDEO_CodingWMV:
+        return "Windows Media Video";
+    case OMX_VIDEO_CodingRV:
+        return "RealVideo";
+    case OMX_VIDEO_CodingAVC:
+        return "H.264/AVC";
+    case OMX_VIDEO_CodingMJPEG:
+        return "Motion JPEG";
+//        case OMX_VIDEO_CodingTheora:     return "OGG Theora";
+
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f, "format type 0x%08x", c);
+        return f;//maybe memleak
+    }
+}
+
+static const char *dump_color_format(OMXCodecContext *s, OMX_COLOR_FORMATTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_COLOR_FormatUnused:
+        return "OMX_COLOR_FormatUnused: not used";
+    case OMX_COLOR_FormatMonochrome:
+        return "OMX_COLOR_FormatMonochrome";
+    case OMX_COLOR_Format8bitRGB332:
+        return "OMX_COLOR_Format8bitRGB332";
+    case OMX_COLOR_Format12bitRGB444:
+        return "OMX_COLOR_Format12bitRGB444";
+    case OMX_COLOR_Format16bitARGB4444:
+        return "OMX_COLOR_Format16bitARGB4444";
+    case OMX_COLOR_Format16bitARGB1555:
+        return "OMX_COLOR_Format16bitARGB1555";
+    case OMX_COLOR_Format16bitRGB565:
+        return "OMX_COLOR_Format16bitRGB565";
+    case OMX_COLOR_Format16bitBGR565:
+        return "OMX_COLOR_Format16bitBGR565";
+    case OMX_COLOR_Format18bitRGB666:
+        return "OMX_COLOR_Format18bitRGB666";
+    case OMX_COLOR_Format18bitARGB1665:
+        return "OMX_COLOR_Format18bitARGB1665";
+    case OMX_COLOR_Format19bitARGB1666:
+        return "OMX_COLOR_Format19bitARGB1666";
+    case OMX_COLOR_Format24bitRGB888:
+        return "OMX_COLOR_Format24bitRGB888";
+    case OMX_COLOR_Format24bitBGR888:
+        return "OMX_COLOR_Format24bitBGR888";
+    case OMX_COLOR_Format24bitARGB1887:
+        return "OMX_COLOR_Format24bitARGB1887";
+    case OMX_COLOR_Format25bitARGB1888:
+        return "OMX_COLOR_Format25bitARGB1888";
+    case OMX_COLOR_Format32bitBGRA8888:
+        return "OMX_COLOR_Format32bitBGRA8888";
+    case OMX_COLOR_Format32bitARGB8888:
+        return "OMX_COLOR_Format32bitARGB8888";
+    case OMX_COLOR_FormatYUV411Planar:
+        return "OMX_COLOR_FormatYUV411Planar";
+    case OMX_COLOR_FormatYUV411PackedPlanar:
+        return "OMX_COLOR_FormatYUV411PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420Planar:
+        return "OMX_COLOR_FormatYUV420Planar: Planar YUV, 4:2:0 (I420)";
+    case OMX_COLOR_FormatYUV420PackedPlanar:
+        return "OMX_COLOR_FormatYUV420PackedPlanar: Planar YUV, 4:2:0 (I420), planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420SemiPlanar:
+        return "OMX_COLOR_FormatYUV420SemiPlanar, Planar YUV, 4:2:0 (NV12), U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422Planar:
+        return "OMX_COLOR_FormatYUV422Planar";
+    case OMX_COLOR_FormatYUV422PackedPlanar:
+        return "OMX_COLOR_FormatYUV422PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV422SemiPlanar:
+        return "OMX_COLOR_FormatYUV422SemiPlanar";
+    case OMX_COLOR_FormatYCbYCr:
+        return "OMX_COLOR_FormatYCbYCr";
+    case OMX_COLOR_FormatYCrYCb:
+        return "OMX_COLOR_FormatYCrYCb";
+    case OMX_COLOR_FormatCbYCrY:
+        return "OMX_COLOR_FormatCbYCrY";
+    case OMX_COLOR_FormatCrYCbY:
+        return "OMX_COLOR_FormatCrYCbY";
+    case OMX_COLOR_FormatYUV444Interleaved:
+        return "OMX_COLOR_FormatYUV444Interleaved";
+    case OMX_COLOR_FormatRawBayer8bit:
+        return "OMX_COLOR_FormatRawBayer8bit";
+    case OMX_COLOR_FormatRawBayer10bit:
+        return "OMX_COLOR_FormatRawBayer10bit";
+    case OMX_COLOR_FormatRawBayer8bitcompressed:
+        return "OMX_COLOR_FormatRawBayer8bitcompressed";
+    case OMX_COLOR_FormatL2:
+        return "OMX_COLOR_FormatL2";
+    case OMX_COLOR_FormatL4:
+        return "OMX_COLOR_FormatL4";
+    case OMX_COLOR_FormatL8:
+        return "OMX_COLOR_FormatL8";
+    case OMX_COLOR_FormatL16:
+        return "OMX_COLOR_FormatL16";
+    case OMX_COLOR_FormatL24:
+        return "OMX_COLOR_FormatL24";
+    case OMX_COLOR_FormatL32:
+        return "OMX_COLOR_FormatL32";
+    case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV420PackedSemiPlanar: Planar YUV, 4:2:0 (NV12), planes fragmented when a frame is split in multiple buffers, U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV422PackedSemiPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_Format18BitBGR666:
+        return "OMX_COLOR_Format18BitBGR666";
+    case OMX_COLOR_Format24BitARGB6666:
+        return "OMX_COLOR_Format24BitARGB6666";
+    case OMX_COLOR_Format24BitABGR6666:
+        return "OMX_COLOR_Format24BitABGR6666";
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f,  "format type 0x%08x", c);
+        return f;
+    }
+}
+
+static void dump_portdef(OMXCodecContext *s, OMX_PARAM_PORTDEFINITIONTYPE *portdef)
+{
+    OMX_VIDEO_PORTDEFINITIONTYPE *viddef = &portdef->format.video;
+    OMX_IMAGE_PORTDEFINITIONTYPE *imgdef = &portdef->format.image;
+
+    say(s, "Port %d is %s, %s, buffers wants:%d needs:%d, size:%d, pop:%d, aligned:%d",
+        portdef->nPortIndex,
+        (portdef->eDir ==  OMX_DirInput ? "input" : "output"),
+        (portdef->bEnabled == OMX_TRUE ? "enabled" : "disabled"),
+        portdef->nBufferCountActual,
+        portdef->nBufferCountMin,
+        portdef->nBufferSize,
+        portdef->bPopulated,
+        portdef->nBufferAlignment);
+
+
+    switch (portdef->eDomain) {
+    case OMX_PortDomainVideo:
+        say(s, "Video type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tBitrate:\t%d\n"
+            "\tFramerate:\t%.02f\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            viddef->nFrameWidth,
+            viddef->nFrameHeight,
+            viddef->nStride,
+            viddef->nSliceHeight,
+            viddef->nBitrate,
+            ((float)viddef->xFramerate / (float)65536),
+            (viddef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, viddef->eCompressionFormat),
+            dump_color_format(s, viddef->eColorFormat));
+        break;
+    case OMX_PortDomainImage:
+        say(s, "Image type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            imgdef->nFrameWidth,
+            imgdef->nFrameHeight,
+            imgdef->nStride,
+            imgdef->nSliceHeight,
+            (imgdef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, imgdef->eCompressionFormat),
+            dump_color_format(s, imgdef->eColorFormat));
+        break;
+    default:
+        break;
+    }
+}
+
+
 static void append_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
-                          int* array_size, OMX_BUFFERHEADERTYPE **array,
+                          int *array_size, OMX_BUFFERHEADERTYPE **array,
                           OMX_BUFFERHEADERTYPE *buffer)
 {
     pthread_mutex_lock(mutex);
@@ -240,19 +483,19 @@ static void append_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
 }
 
 static OMX_BUFFERHEADERTYPE *get_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
-                                        int* array_size, OMX_BUFFERHEADERTYPE **array,
+                                        int *array_size, OMX_BUFFERHEADERTYPE **array,
                                         int wait)
 {
     OMX_BUFFERHEADERTYPE *buffer;
     pthread_mutex_lock(mutex);
     if (wait) {
         while (!*array_size)
-           pthread_cond_wait(cond, mutex);
+            pthread_cond_wait(cond, mutex);
     }
     if (*array_size > 0) {
         buffer = array[0];
         (*array_size)--;
-        memmove(&array[0], &array[1], (*array_size) * sizeof(OMX_BUFFERHEADERTYPE*));
+        memmove(&array[0], &array[1], (*array_size) * sizeof(OMX_BUFFERHEADERTYPE *));
     } else {
         buffer = NULL;
     }
@@ -288,7 +531,7 @@ static OMX_ERRORTYPE event_handler(OMX_HANDLETYPE component, OMX_PTR app_data, O
             av_log(s->avctx, AV_LOG_VERBOSE, "OMX port %"PRIu32" enabled\n", (uint32_t) data2);
         } else {
             av_log(s->avctx, AV_LOG_VERBOSE, "OMX command complete, command %"PRIu32", value %"PRIu32"\n",
-                                             (uint32_t) data1, (uint32_t) data2);
+                   (uint32_t) data1, (uint32_t) data2);
         }
         break;
     case OMX_EventPortSettingsChanged:
@@ -296,7 +539,7 @@ static OMX_ERRORTYPE event_handler(OMX_HANDLETYPE component, OMX_PTR app_data, O
         break;
     default:
         av_log(s->avctx, AV_LOG_VERBOSE, "OMX event %d %"PRIx32" %"PRIx32"\n",
-                                         event, (uint32_t) data1, (uint32_t) data2);
+               event, (uint32_t) data1, (uint32_t) data2);
         break;
     }
     return OMX_ErrorNone;
@@ -311,7 +554,7 @@ static OMX_ERRORTYPE empty_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_dat
             if (buffer->pOutputPortPrivate)
                 av_free(buffer->pAppPrivate);
             else
-                av_frame_free((AVFrame**)&buffer->pAppPrivate);
+                av_frame_free((AVFrame **)&buffer->pAppPrivate);
             buffer->pAppPrivate = NULL;
         }
     }
@@ -363,7 +606,7 @@ static av_cold int find_component(OMXContext *omx_context, void *logctx,
             goto end;
         }
     }
-    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, (OMX_U8**) components);
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, (OMX_U8 **) components);
     av_strlcpy(str, components[0], str_size);
 end:
     for (i = 0; i < num; i++)
@@ -392,6 +635,7 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
     OMX_PARAM_PORTDEFINITIONTYPE in_port_params = { 0 }, out_port_params = { 0 };
     OMX_VIDEO_PARAM_PORTFORMATTYPE video_port_format = { 0 };
     OMX_VIDEO_PARAM_BITRATETYPE vid_param_bitrate = { 0 };
+    OMX_VIDEO_PARAM_QUANTIZATIONTYPE vid_param_quantization = { 0 };
     OMX_ERRORTYPE err;
     int i;
 
@@ -399,7 +643,7 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
     s->version.s.nVersionMinor = 1;
     s->version.s.nRevision     = 2;
 
-    err = s->omx_context->ptr_GetHandle(&s->handle, s->component_name, s, (OMX_CALLBACKTYPE*) &callbacks);
+    err = s->omx_context->ptr_GetHandle(&s->handle, s->component_name, s, (OMX_CALLBACKTYPE *) &callbacks);
     if (err != OMX_ErrorNone) {
         av_log(avctx, AV_LOG_ERROR, "OMX_GetHandle(%s) failed: %x\n", s->component_name, err);
         return AVERROR_UNKNOWN;
@@ -411,6 +655,10 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
     // Intentionally ignore errors on this one
     OMX_SetParameter(s->handle, OMX_IndexParamStandardComponentRole, &role_params);
 
+    s->dts_duration = avctx->pkt_timebase.den;
+    s->dts_now = 0;
+    s->pts_pre = -1;
+
     INIT_STRUCT(video_port_params);
     err = OMX_GetParameter(s->handle, OMX_IndexParamVideoInit, &video_port_params);
     CHECK(err);
@@ -439,32 +687,19 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
         return AVERROR_UNKNOWN;
     }
 
-    s->color_format = 0;
-    for (i = 0; ; i++) {
-        INIT_STRUCT(video_port_format);
-        video_port_format.nIndex = i;
-        video_port_format.nPortIndex = s->in_port;
-        if (OMX_GetParameter(s->handle, OMX_IndexParamVideoPortFormat, &video_port_format) != OMX_ErrorNone)
-            break;
-        if (video_port_format.eColorFormat == OMX_COLOR_FormatYUV420Planar ||
-            video_port_format.eColorFormat == OMX_COLOR_FormatYUV420PackedPlanar) {
-            s->color_format = video_port_format.eColorFormat;
-            break;
-        }
-    }
-    if (s->color_format == 0) {
-        av_log(avctx, AV_LOG_ERROR, "No supported pixel formats (%d formats available)\n", i);
-        return AVERROR_UNKNOWN;
-    }
+    s->color_format = OMX_COLOR_FormatYUV420SemiPlanar;
 
     in_port_params.bEnabled   = OMX_TRUE;
     in_port_params.bPopulated = OMX_FALSE;
     in_port_params.eDomain    = OMX_PortDomainVideo;
+    in_port_params.nBufferAlignment = 64;
 
     in_port_params.format.video.pNativeRender         = NULL;
     in_port_params.format.video.bFlagErrorConcealment = OMX_FALSE;
     in_port_params.format.video.eColorFormat          = s->color_format;
-    s->stride     = avctx->width;
+
+    s->stride = (avctx->width / 64 * 64) < avctx->width ? ((avctx->width / 64 + 1) * 64) : avctx->width;
+    s->stride_padding = s->stride - avctx->width;
     s->plane_size = avctx->height;
     // If specific codecs need to manually override the stride/plane_size,
     // that can be done here.
@@ -494,27 +729,50 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
     out_port_params.format.video.nFrameHeight  = avctx->height;
     out_port_params.format.video.nStride       = 0;
     out_port_params.format.video.nSliceHeight  = 0;
-    out_port_params.format.video.nBitrate      = avctx->bit_rate;
+    out_port_params.format.video.nBitrate      = s->bitrate ? s->bitrate : avctx->bit_rate;
     out_port_params.format.video.xFramerate    = in_port_params.format.video.xFramerate;
     out_port_params.format.video.bFlagErrorConcealment  = OMX_FALSE;
     if (avctx->codec->id == AV_CODEC_ID_MPEG4)
         out_port_params.format.video.eCompressionFormat = OMX_VIDEO_CodingMPEG4;
     else if (avctx->codec->id == AV_CODEC_ID_H264)
         out_port_params.format.video.eCompressionFormat = OMX_VIDEO_CodingAVC;
+    else if (avctx->codec->id == AV_CODEC_ID_HEVC)
+        out_port_params.format.video.eCompressionFormat = OMX_VIDEO_CodingHEVC;
 
     err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
     CHECK(err);
     err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
     CHECK(err);
+    dump_portdef(s, &in_port_params);
+    dump_portdef(s, &out_port_params);
+
     s->num_out_buffers = out_port_params.nBufferCountActual;
 
+    //bitrate control
     INIT_STRUCT(vid_param_bitrate);
     vid_param_bitrate.nPortIndex     = s->out_port;
     vid_param_bitrate.eControlRate   = OMX_Video_ControlRateVariable;
-    vid_param_bitrate.nTargetBitrate = avctx->bit_rate;
+    vid_param_bitrate.nTargetBitrate = s->bitrate ? s->bitrate : avctx->bit_rate;
+    //vid_param_bitrate.eControlRate = OMX_Video_ControlRateDisable;
     err = OMX_SetParameter(s->handle, OMX_IndexParamVideoBitrate, &vid_param_bitrate);
     if (err != OMX_ErrorNone)
         av_log(avctx, AV_LOG_WARNING, "Unable to set video bitrate parameter\n");
+    else
+        av_log(avctx, AV_LOG_INFO, "Target Bitrate Setted: %d\n", vid_param_bitrate.nTargetBitrate);
+
+    //quantization control
+    INIT_STRUCT(vid_param_quantization);
+    vid_param_quantization.nPortIndex = s->out_port;
+    vid_param_quantization.nQpI = s->QpI;
+    vid_param_quantization.nQpP = s->QpP;
+    vid_param_quantization.nQpB = 0; //not used
+    err = OMX_SetParameter(s->handle, OMX_IndexParamVideoQuantization, &vid_param_quantization);
+    if (err != OMX_ErrorNone)
+        av_log(avctx, AV_LOG_WARNING, "Unable to set video quantization parameter\n");
+    else
+        av_log(avctx, AV_LOG_INFO, "Qp for I frames: %d, Qp for P frames: %d\n", vid_param_quantization.nQpI,
+               vid_param_quantization.nQpP);
+
 
     if (avctx->codec->id == AV_CODEC_ID_H264) {
         OMX_VIDEO_PARAM_AVCTYPE avc = { 0 };
@@ -523,31 +781,181 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
         err = OMX_GetParameter(s->handle, OMX_IndexParamVideoAvc, &avc);
         CHECK(err);
         avc.nBFrames = 0;
-        avc.nPFrames = avctx->gop_size - 1;
+        avc.nPFrames = (s->gop_size) ? (s->gop_size - 1) : (avctx->gop_size - 1);
+        avc.eProfile = OMX_VIDEO_AVCProfileMain;
+        avc.eLevel = OMX_VIDEO_AVCLevel42;
         switch (s->profile == FF_PROFILE_UNKNOWN ? avctx->profile : s->profile) {
         case FF_PROFILE_H264_BASELINE:
             avc.eProfile = OMX_VIDEO_AVCProfileBaseline;
+            avc.bEntropyCodingCABAC = 0;
+            avc.eLevel = OMX_VIDEO_AVCLevel3;
+            av_log(avctx, AV_LOG_INFO, "Profile Baseline\n");
             break;
         case FF_PROFILE_H264_MAIN:
             avc.eProfile = OMX_VIDEO_AVCProfileMain;
+            avc.eLevel = OMX_VIDEO_AVCLevel42;
+            av_log(avctx, AV_LOG_INFO, "Profile Main\n");
             break;
         case FF_PROFILE_H264_HIGH:
             avc.eProfile = OMX_VIDEO_AVCProfileHigh;
+            avc.eLevel = OMX_VIDEO_AVCLevel51;
+            av_log(avctx, AV_LOG_INFO, "Profile High\n");
             break;
         default:
+            av_log(avctx, AV_LOG_INFO, "Profile Main\n");
             break;
         }
+        if (s->level != FF_LEVEL_UNKNOWN) {
+            avc.eLevel = s->level;
+        }
+        switch (avc.eLevel) {
+        case OMX_VIDEO_AVCLevel1:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel1\n");
+            break;
+        case OMX_VIDEO_AVCLevel1b:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel1b\n");
+            break;
+        case OMX_VIDEO_AVCLevel11:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel11\n");
+            break;
+        case OMX_VIDEO_AVCLevel12:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel12\n");
+            break;
+        case OMX_VIDEO_AVCLevel13:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel13\n");
+            break;
+        case OMX_VIDEO_AVCLevel2:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel2\n");
+            break;
+        case OMX_VIDEO_AVCLevel21:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel21\n");
+            break;
+        case OMX_VIDEO_AVCLevel22:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel22\n");
+            break;
+        case OMX_VIDEO_AVCLevel3:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel3\n");
+            break;
+        case OMX_VIDEO_AVCLevel31:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel31\n");
+            break;
+        case OMX_VIDEO_AVCLevel32:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel32\n");
+            break;
+        case OMX_VIDEO_AVCLevel4:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel4\n");
+            break;
+        case OMX_VIDEO_AVCLevel41:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel41\n");
+            break;
+        case OMX_VIDEO_AVCLevel42:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel42\n");
+            break;
+        case OMX_VIDEO_AVCLevel5:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel5\n");
+            break;
+        case OMX_VIDEO_AVCLevel51:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_AVCLevel51\n");
+            break;
+        default:
+            av_log(avctx, AV_LOG_ERROR, "[Error] OMX VIDEO AVCLevel\n");
+        }
         err = OMX_SetParameter(s->handle, OMX_IndexParamVideoAvc, &avc);
         CHECK(err);
+        err = OMX_GetParameter(s->handle, OMX_IndexParamVideoAvc, &avc);
+        CHECK(err);
+        if (avc.nPFrames)
+            av_log(avctx, AV_LOG_INFO, "1 I frame and %d P frame(s) in a gop\n", avc.nPFrames);
+        else
+            av_log(avctx, AV_LOG_INFO, "All intra coding\n");
+    } else if (avctx->codec->id == AV_CODEC_ID_HEVC) {
+        OMX_VIDEO_PARAM_HEVCTYPE hevc = { 0 };
+        INIT_STRUCT(hevc);
+        hevc.nPortIndex = s->out_port;
+        err = OMX_GetParameter(s->handle, OMX_IndexParamVideoHevc, &hevc);
+        CHECK(err);
+        hevc.nPFrames = (s->gop_size) ? (s->gop_size - 1) : (avctx->gop_size - 1);
+        hevc.eLevel = OMX_VIDEO_HEVCLevel51;
+        hevc.eProfile = OMX_VIDEO_HEVCProfileMain;
+        switch (s->profile == FF_PROFILE_UNKNOWN ? avctx->profile : s->profile) {
+        case FF_PROFILE_HEVC_MAIN:
+            av_log(avctx, AV_LOG_INFO, "Profile Main\n");
+            hevc.eProfile = OMX_VIDEO_HEVCProfileMain;
+            hevc.eLevel = OMX_VIDEO_HEVCLevel51;
+            break;
+        case FF_PROFILE_HEVC_MAIN_10:
+            av_log(avctx, AV_LOG_INFO, "Profile Main 10\n");
+            hevc.eProfile = OMX_VIDEO_HEVCProfileMain10;
+            hevc.eLevel = OMX_VIDEO_HEVCLevel51;
+            break;
+        default:
+            av_log(avctx, AV_LOG_INFO, "Profile Main\n");
+            break;
+        }
+        if (s->level != FF_LEVEL_UNKNOWN) {
+            hevc.eLevel = s->level;
+        }
+        switch (hevc.eLevel) {
+        case OMX_VIDEO_HEVCLevel1:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel1\n");
+            break;
+        case OMX_VIDEO_HEVCLevel2:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel2\n");
+            break;
+        case OMX_VIDEO_HEVCLevel21:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel21\n");
+            break;
+        case OMX_VIDEO_HEVCLevel3:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel3\n");
+            break;
+        case OMX_VIDEO_HEVCLevel31:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel31\n");
+            break;
+        case OMX_VIDEO_HEVCLevel4:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel4\n");
+            break;
+        case OMX_VIDEO_HEVCLevel41:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel41\n");
+            break;
+        case OMX_VIDEO_HEVCLevel5:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel5\n");
+            break;
+        case OMX_VIDEO_HEVCLevel51:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel51\n");
+            break;
+        case OMX_VIDEO_HEVCLevel52:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel52\n");
+            break;
+        case OMX_VIDEO_HEVCLevel6:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel6\n");
+            break;
+        case OMX_VIDEO_HEVCLevel61:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel61\n");
+            break;
+        case OMX_VIDEO_HEVCLevel62:
+            av_log(avctx, AV_LOG_INFO, "OMX_VIDEO_HEVCLevel62\n");
+            break;
+        default:
+            av_log(avctx, AV_LOG_ERROR, "[ERROR] OMX_VIDEO_HEVCLevel\n");
+        }
+
+        err = OMX_SetParameter(s->handle, OMX_IndexParamVideoHevc, &hevc);
+        CHECK(err);
+        err = OMX_GetParameter(s->handle, OMX_IndexParamVideoHevc, &hevc);
+        CHECK(err);
+        if (hevc.nPFrames)
+            av_log(avctx, AV_LOG_INFO, "1 I frame and %d P frame(s) in a gop\n", hevc.nPFrames);
+        else
+            av_log(avctx, AV_LOG_INFO, "All intra coding\n");
     }
 
     err = OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
     CHECK(err);
 
-    s->in_buffer_headers  = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE*) * s->num_in_buffers);
-    s->free_in_buffers    = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE*) * s->num_in_buffers);
-    s->out_buffer_headers = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE*) * s->num_out_buffers);
-    s->done_out_buffers   = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE*) * s->num_out_buffers);
+    s->in_buffer_headers  = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_in_buffers);
+    s->free_in_buffers    = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_in_buffers);
+    s->out_buffer_headers = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+    s->done_out_buffers   = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
     if (!s->in_buffer_headers || !s->free_in_buffers || !s->out_buffer_headers || !s->done_out_buffers)
         return AVERROR(ENOMEM);
     for (i = 0; i < s->num_in_buffers && err == OMX_ErrorNone; i++) {
@@ -590,7 +998,7 @@ static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
 static av_cold void cleanup(OMXCodecContext *s)
 {
     int i, executing;
-
+    av_log(s->avctx, AV_LOG_INFO, "OMX Cleanup\n");
     pthread_mutex_lock(&s->state_mutex);
     executing = s->state == OMX_StateExecuting;
     pthread_mutex_unlock(&s->state_mutex);
@@ -601,14 +1009,14 @@ static av_cold void cleanup(OMXCodecContext *s)
         OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateLoaded, NULL);
         for (i = 0; i < s->num_in_buffers; i++) {
             OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->input_mutex, &s->input_cond,
-                                                      &s->num_free_in_buffers, s->free_in_buffers, 1);
+                                           &s->num_free_in_buffers, s->free_in_buffers, 1);
             if (s->input_zerocopy)
                 buffer->pBuffer = NULL;
             OMX_FreeBuffer(s->handle, s->in_port, buffer);
         }
         for (i = 0; i < s->num_out_buffers; i++) {
             OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->output_mutex, &s->output_cond,
-                                                      &s->num_done_out_buffers, s->done_out_buffers, 1);
+                                           &s->num_done_out_buffers, s->done_out_buffers, 1);
             OMX_FreeBuffer(s->handle, s->out_port, buffer);
         }
         wait_for_state(s, OMX_StateLoaded);
@@ -617,7 +1025,6 @@ static av_cold void cleanup(OMXCodecContext *s)
         s->omx_context->ptr_FreeHandle(s->handle);
         s->handle = NULL;
     }
-
     omx_deinit(s->omx_context);
     s->omx_context = NULL;
     if (s->mutex_cond_inited) {
@@ -666,6 +1073,9 @@ static av_cold int omx_encode_init(AVCodecContext *avctx)
     case AV_CODEC_ID_H264:
         role = "video_encoder.avc";
         break;
+    case AV_CODEC_ID_HEVC:
+        role = "video_encoder.hevc";
+        break;
     default:
         return AVERROR(ENOSYS);
     }
@@ -677,13 +1087,14 @@ static av_cold int omx_encode_init(AVCodecContext *avctx)
 
     if ((ret = omx_component_init(avctx, role)) < 0)
         goto fail;
-
+#if 0
     if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
         while (1) {
             buffer = get_buffer(&s->output_mutex, &s->output_cond,
                                 &s->num_done_out_buffers, s->done_out_buffers, 1);
             if (buffer->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
-                if ((ret = av_reallocp(&avctx->extradata, avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
+                if ((ret = av_reallocp(&avctx->extradata,
+                                       avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
                     avctx->extradata_size = 0;
                     goto fail;
                 }
@@ -706,12 +1117,12 @@ static av_cold int omx_encode_init(AVCodecContext *avctx)
                 int nals[32] = { 0 };
                 int i;
                 for (i = 0; i + 4 < avctx->extradata_size; i++) {
-                     if (!avctx->extradata[i + 0] &&
-                         !avctx->extradata[i + 1] &&
-                         !avctx->extradata[i + 2] &&
-                         avctx->extradata[i + 3] == 1) {
-                         nals[avctx->extradata[i + 4] & 0x1f]++;
-                     }
+                    if (!avctx->extradata[i + 0] &&
+                        !avctx->extradata[i + 1] &&
+                        !avctx->extradata[i + 2] &&
+                        avctx->extradata[i + 3] == 1) {
+                        nals[avctx->extradata[i + 4] & 0x1f]++;
+                    }
                 }
                 if (nals[H264_NAL_SPS] && nals[H264_NAL_PPS])
                     break;
@@ -721,19 +1132,32 @@ static av_cold int omx_encode_init(AVCodecContext *avctx)
             }
         }
     }
+#endif
 
     return 0;
 fail:
     return ret;
 }
 
+static int omx_line_copy(AVCodecContext *avctx, const AVFrame *frame, OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    memset(buffer->pBuffer, 0, s->stride * frame->height * 3 / 2);
+    for (int i = 0; i < frame->height; i++) {
+        memcpy(buffer->pBuffer + i * s->stride, frame->data[0] + i * frame->width, frame->width);
+    }
+    for (int i = 0; i < frame->height / 2; i++) {
+        memcpy(buffer->pBuffer + s->stride * frame->height + i * s->stride, frame->data[1] + +i * frame->width, frame->width);
+    }
+    return 0;
+}
 
 static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                             const AVFrame *frame, int *got_packet)
 {
     OMXCodecContext *s = avctx->priv_data;
     int ret = 0;
-    OMX_BUFFERHEADERTYPE* buffer;
+    OMX_BUFFERHEADERTYPE *buffer;
     OMX_ERRORTYPE err;
     int had_partial = 0;
 
@@ -744,7 +1168,10 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         buffer = get_buffer(&s->input_mutex, &s->input_cond,
                             &s->num_free_in_buffers, s->free_in_buffers, 1);
 
-        buffer->nFilledLen = av_image_fill_arrays(dst, linesize, buffer->pBuffer, avctx->pix_fmt, s->stride, s->plane_size, 1);
+        //buffer->nFilledLen = av_image_fill_arrays(dst, linesize, buffer->pBuffer, avctx->pix_fmt, s->stride, s->plane_size, 1);
+        buffer->nFilledLen = s->stride * frame->height * 3 / 2;
+        buffer->nAllocLen = buffer->nFilledLen;
+        buffer->nFlags = 0;
 
         if (s->input_zerocopy) {
             uint8_t *src[4] = { NULL };
@@ -783,7 +1210,7 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                 } else {
                     buffer->pAppPrivate = buf;
                     // Mark that pAppPrivate is an av_malloc'ed buffer, not an AVFrame
-                    buffer->pOutputPortPrivate = (void*) 1;
+                    buffer->pOutputPortPrivate = (void *) 1;
                     buffer->pBuffer = buf;
                     need_copy = 1;
                     buffer->nFilledLen = av_image_fill_arrays(dst, linesize, buffer->pBuffer, avctx->pix_fmt, s->stride, s->plane_size, 1);
@@ -792,8 +1219,18 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         } else {
             need_copy = 1;
         }
-        if (need_copy)
-            av_image_copy(dst, linesize, (const uint8_t**) frame->data, frame->linesize, avctx->pix_fmt, avctx->width, avctx->height);
+
+        if (need_copy) {
+            //av_image_copy(dst, linesize, (const uint8_t**) frame->data, frame->linesize, avctx->pix_fmt, avctx->width, avctx->height);
+            if (s->stride_padding == 0) {
+                memcpy(buffer->pBuffer, frame->data[0], frame->height * frame->width);
+                memcpy(buffer->pBuffer + frame->height * frame->width, frame->data[1], frame->height * frame->width / 2);
+            } else if (s->stride_padding > 0) {
+                omx_line_copy(avctx, frame, buffer);
+            } else {
+                av_log(avctx, AV_LOG_ERROR, "error stride padding size: %d\n", s->stride_padding);
+            }
+        }
         buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;
         buffer->nOffset = 0;
         // Convert the timestamps to microseconds; some encoders can ignore
@@ -854,8 +1291,9 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         if (buffer->nFlags & OMX_BUFFERFLAG_EOS)
             s->got_eos = 1;
 
-        if (buffer->nFlags & OMX_BUFFERFLAG_CODECCONFIG && avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
-            if ((ret = av_reallocp(&avctx->extradata, avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
+        if (buffer->nFlags & OMX_BUFFERFLAG_CODECCONFIG && avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER && 0) {
+            if ((ret = av_reallocp(&avctx->extradata,
+                                   avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
                 avctx->extradata_size = 0;
                 goto end;
             }
@@ -899,10 +1337,12 @@ static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
             }
             if (buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) {
                 pkt->pts = av_rescale_q(from_omx_ticks(buffer->nTimeStamp), AV_TIME_BASE_Q, avctx->time_base);
-                // We don't currently enable B-frames for the encoders, so set
-                // pkt->dts = pkt->pts. (The calling code behaves worse if the encoder
-                // doesn't set the dts).
-                pkt->dts = pkt->pts;
+                if (pkt->pts != s->pts_pre + s->dts_duration) {
+                    pkt->pts = s->pts_pre + s->dts_duration;
+                }
+                s->pts_pre = pkt->pts;
+                pkt->dts = s->dts_now;
+                s->dts_now += s->dts_duration;
                 if (buffer->nFlags & OMX_BUFFERFLAG_SYNCFRAME)
                     pkt->flags |= AV_PKT_FLAG_KEY;
                 *got_packet = 1;
@@ -933,18 +1373,68 @@ static av_cold int omx_encode_end(AVCodecContext *avctx)
 static const AVOption options[] = {
     { "omx_libname", "OpenMAX library name", OFFSET(libname), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
     { "omx_libprefix", "OpenMAX library prefix", OFFSET(libprefix), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
-    { "zerocopy", "Try to avoid copying input frames if possible", OFFSET(input_zerocopy), AV_OPT_TYPE_INT, { .i64 = CONFIG_OMX_RPI }, 0, 1, VE },
+    { "zerocopy", "Try to avoid copying input frames if possible", OFFSET(input_zerocopy), AV_OPT_TYPE_INT, { .i64 = CONFIG_OMX_RPI }, 0, 0, VE },
+    { "gop_size",  "Set the encoding gop_size", OFFSET(gop_size), AV_OPT_TYPE_INT,   { .i64 = 12 }, 0, OMX_VIDEO_AVCLevelMax, VE, "gop_size" },
+    { "bitrate",  "Set the encoding bitrate", OFFSET(bitrate), AV_OPT_TYPE_INT,   { .i64 = 10000000 }, 0, OMX_VIDEO_AVCLevelMax, VE, "bitrate" },
+    { "QpI",  "Set the encoding Qp for I frames", OFFSET(QpI), AV_OPT_TYPE_INT,   { .i64 = 27 }, 0, 51, VE, "QpI" },
+    { "QpP",  "Set the encoding Qp for P frames", OFFSET(QpP), AV_OPT_TYPE_INT,   { .i64 = 27 }, 0, 51, VE, "QpP" },
     { "profile",  "Set the encoding profile", OFFSET(profile), AV_OPT_TYPE_INT,   { .i64 = FF_PROFILE_UNKNOWN },       FF_PROFILE_UNKNOWN, FF_PROFILE_H264_HIGH, VE, "profile" },
-    { "baseline", "",                         0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_BASELINE }, 0, 0, VE, "profile" },
-    { "main",     "",                         0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_MAIN },     0, 0, VE, "profile" },
-    { "high",     "",                         0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_HIGH },     0, 0, VE, "profile" },
+    { "baseline",    "",                      0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_BASELINE }, 0, 0, VE, "profile" },
+    { "main",        "",                      0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_MAIN },     0, 0, VE, "profile" },
+    { "high",        "",                      0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_H264_HIGH },     0, 0, VE, "profile" },
+    { "level",  "Set the encoding level", OFFSET(level), AV_OPT_TYPE_INT,   { .i64 = FF_LEVEL_UNKNOWN},       FF_LEVEL_UNKNOWN, OMX_VIDEO_AVCLevelMax, VE, "level" },
+    { "level1",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel1 },      0, 0, VE, "level" },
+    { "level1b",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel1b},      0, 0, VE, "level" },
+    { "level11",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel11 },     0, 0, VE, "level" },
+    { "level12",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel12 },     0, 0, VE, "level" },
+    { "level13",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel13 },     0, 0, VE, "level" },
+    { "level2",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel2},       0, 0, VE, "level" },
+    { "level21",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel21 },     0, 0, VE, "level" },
+    { "level22",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel22 },     0, 0, VE, "level" },
+    { "level3",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel3},       0, 0, VE, "level" },
+    { "level31",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel31 },     0, 0, VE, "level" },
+    { "level32",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel32 },     0, 0, VE, "level" },
+    { "level4",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel4},       0, 0, VE, "level" },
+    { "level41",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel41 },     0, 0, VE, "level" },
+    { "level42",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel42 },     0, 0, VE, "level" },
+    { "level5",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel5},       0, 0, VE, "level" },
+    { "level51",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_AVCLevel51 },     0, 0, VE, "level" },
+    { NULL }
+};
+
+static const AVOption options_hevc[] = {
+    { "omx_libname", "OpenMAX library name", OFFSET(libname), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
+    { "omx_libprefix", "OpenMAX library prefix", OFFSET(libprefix), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
+    { "zerocopy", "Try to avoid copying input frames if possible", OFFSET(input_zerocopy), AV_OPT_TYPE_INT, { .i64 = CONFIG_OMX_RPI }, 0, 0, VE },
+    { "gop_size",  "Set the encoding gop_size", OFFSET(gop_size), AV_OPT_TYPE_INT,   { .i64 = 12 }, 0, OMX_VIDEO_AVCLevelMax, VE, "gop_size" },
+    { "bitrate",  "Set the encoding bitrate", OFFSET(bitrate), AV_OPT_TYPE_INT,   { .i64 = 10000000 }, 0, OMX_VIDEO_AVCLevelMax, VE, "bitrate" },
+    { "QpI",  "Set the encoding Qp for I frames", OFFSET(QpI), AV_OPT_TYPE_INT,   { .i64 = 27 }, 0, 51, VE, "QpI" },
+    { "QpP",  "Set the encoding Qp for P frames", OFFSET(QpP), AV_OPT_TYPE_INT,   { .i64 = 27 }, 0, 51, VE, "QpP" },
+    { "profile",  "Set the encoding profile", OFFSET(profile), AV_OPT_TYPE_INT,   { .i64 = FF_PROFILE_UNKNOWN },       FF_PROFILE_UNKNOWN, FF_PROFILE_H264_HIGH, VE, "profile" },
+    { "main",        "",                      0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_HEVC_MAIN },     0, 0, VE, "profile" },
+    { "main10",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_HEVC_MAIN_10 },  0, 0, VE, "profile" },
+    { "level",  "Set the encoding level", OFFSET(level), AV_OPT_TYPE_INT,   { .i64 = FF_LEVEL_UNKNOWN},       FF_LEVEL_UNKNOWN, OMX_VIDEO_HEVCLevelMax, VE, "level" },
+    { "level1",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel1 },     0, 0, VE, "level" },
+    { "level2",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel2},      0, 0, VE, "level" },
+    { "level21",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel21 },    0, 0, VE, "level" },
+    { "level3",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel3 },     0, 0, VE, "level" },
+    { "level31",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel31 },    0, 0, VE, "level" },
+    { "level4",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel4},      0, 0, VE, "level" },
+    { "level41",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel41 },    0, 0, VE, "level" },
+    { "level5",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel5 },     0, 0, VE, "level" },
+    { "level51",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel51},     0, 0, VE, "level" },
+    { "level52",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel52 },    0, 0, VE, "level" },
+    { "level6",      "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel6 },     0, 0, VE, "level" },
+    { "level61",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel61},     0, 0, VE, "level" },
+    { "level62",     "",                      0,               AV_OPT_TYPE_CONST, { .i64 = OMX_VIDEO_HEVCLevel62 },    0, 0, VE, "level" },
     { NULL }
 };
 
 static const enum AVPixelFormat omx_encoder_pix_fmts[] = {
-    AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE
+    AV_PIX_FMT_NV12, AV_PIX_FMT_NONE
 };
 
+#ifdef MPEG4_OMX
 static const AVClass omx_mpeg4enc_class = {
     .class_name = "mpeg4_omx",
     .item_name  = av_default_item_name,
@@ -965,6 +1455,7 @@ AVCodec ff_mpeg4_omx_encoder = {
     .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
     .priv_class       = &omx_mpeg4enc_class,
 };
+#endif
 
 static const AVClass omx_h264enc_class = {
     .class_name = "h264_omx",
@@ -986,3 +1477,29 @@ AVCodec ff_h264_omx_encoder = {
     .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
     .priv_class       = &omx_h264enc_class,
 };
+
+
+static const AVClass omx_hevcenc_class = {
+    .class_name = "hevc_omx",
+    .item_name  = av_default_item_name,
+    .option     = options_hevc,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+AVCodec ff_hevc_omx_encoder = {
+    .name             = "hevc_omx",
+    .long_name        = NULL_IF_CONFIG_SMALL("OpenMAX IL HEVC video encoder"),
+    .type             = AVMEDIA_TYPE_VIDEO,
+    .id               = AV_CODEC_ID_HEVC,
+    .priv_data_size   = sizeof(OMXCodecContext),
+    .init             = omx_encode_init,
+    .encode2          = omx_encode_frame,
+    .close            = omx_encode_end,
+    .pix_fmts         = omx_encoder_pix_fmts,
+    .capabilities     = AV_CODEC_CAP_DELAY,
+    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .priv_class       = &omx_hevcenc_class,
+};
+
+
+
diff --git a/libavcodec/omxdecoder.c b/libavcodec/omxdecoder.c
new file mode 100755
index 0000000..dfb6a91
--- /dev/null
+++ b/libavcodec/omxdecoder.c
@@ -0,0 +1,1923 @@
+/*decoders
+*
+* Copyright (c) 2023-2024 Huazhu Sun <sunhuazhu@coocaa.com>
+* Copyright (c) 2023-2024 Kaiyuan Dong <dongkaiyuan.dky@alibaba-inc.com>
+*
+* This file is part of FFmpeg.
+*
+* FFmpeg is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* FFmpeg is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with FFmpeg; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include "config.h"
+#include <dlfcn.h>
+#include <OMX_Core.h>
+#include <OMX_Component.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <stdint.h>
+#include <stdatomic.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <sys/ipc.h>
+#include <sys/msg.h>
+
+#include <pthread.h>
+
+#include "libavutil/avstring.h"
+#include "libavutil/avutil.h"
+#include "libavutil/common.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/log.h"
+#include "libavutil/opt.h"
+#include "libavutil/avassert.h"
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/pixfmt.h"
+#include "libavutil/internal.h"
+#include <libavutil/pixdesc.h>
+#include "libavutil/time.h"
+#include <libavutil/thread.h>
+#include <libavcodec/pthread_internal.h>
+
+#include "avcodec.h"
+#include "decode.h"
+#include "h264_parse.h"
+#include "h264_ps.h"
+#include "hevc_parse.h"
+#include "hwconfig.h"
+#include "internal.h"
+
+#include "avcodec.h"
+#include "h264.h"
+#include "libswscale/swscale.h"
+
+#include "vsi_vendor_ext.h"
+static int omx_load_count = 0;
+#define kNumPictureBuffers 2
+
+#ifdef c920v
+#define __riscv
+#define __riscv_vector
+#include "riscv_vector.h"
+#endif
+typedef enum __DecoderStatus {
+    INITIALIZING,
+    RESETTING,
+    DESTROYING,
+    ERRORING,
+    PortSettingFinished,
+    ILLEGAL_STATE
+} DecoderStatus;
+
+
+#define to_omx_ticks(x) (x)
+#define from_omx_ticks(x) (x)
+
+
+#define INIT_STRUCT(x) do {                                               \
+        x.nSize = sizeof(x);                                              \
+        x.nVersion = s->version;                                          \
+    } while (0)
+#define CHECK(x) do {                                                     \
+        if (x != OMX_ErrorNone) {                                         \
+            av_log(avctx, AV_LOG_ERROR,                                   \
+                   "err %x (%d) on line %d\n", x, x, __LINE__);           \
+            return AVERROR_UNKNOWN;                                       \
+        }                                                                 \
+    } while (0)
+
+typedef struct OMXContext {
+    void *lib;
+    void *lib2;
+    OMX_ERRORTYPE(*ptr_Init)(void);
+    OMX_ERRORTYPE(*ptr_Deinit)(void);
+    OMX_ERRORTYPE(*ptr_ComponentNameEnum)(OMX_STRING, OMX_U32, OMX_U32);
+    OMX_ERRORTYPE(*ptr_GetHandle)(OMX_HANDLETYPE *, OMX_STRING, OMX_PTR, OMX_CALLBACKTYPE *);
+    OMX_ERRORTYPE(*ptr_FreeHandle)(OMX_HANDLETYPE);
+    OMX_ERRORTYPE(*ptr_GetComponentsOfRole)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    OMX_ERRORTYPE(*ptr_GetRolesOfComponent)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    void (*host_init)(void);
+} OMXContext;
+
+static av_cold void *dlsym_prefixed(void *handle, const char *symbol, const char *prefix)
+{
+    char buf[50];
+    snprintf(buf, sizeof(buf), "%s%s", prefix ? prefix : "", symbol);
+    return dlsym(handle, buf);
+}
+
+static av_cold int omx_try_load(OMXContext *s, void *logctx,
+                                const char *libname, const char *prefix,
+                                const char *libname2)
+{
+    av_log(logctx, AV_LOG_INFO, "omx init libname %s\n", libname);
+
+    s->lib = dlopen(libname, RTLD_NOW | RTLD_GLOBAL);
+    if (!s->lib) {
+        av_log(logctx, AV_LOG_WARNING, "%s not found\n", libname);
+        return AVERROR_DECODER_NOT_FOUND;
+    }
+    s->ptr_Init                = dlsym_prefixed(s->lib, "OMX_Init", prefix);
+    s->ptr_Deinit              = dlsym_prefixed(s->lib, "OMX_Deinit", prefix);
+    s->ptr_ComponentNameEnum   = dlsym_prefixed(s->lib, "OMX_ComponentNameEnum", prefix);
+    s->ptr_GetHandle           = dlsym_prefixed(s->lib, "OMX_GetHandle", prefix);
+    s->ptr_FreeHandle          = dlsym_prefixed(s->lib, "OMX_FreeHandle", prefix);
+    s->ptr_GetComponentsOfRole = dlsym_prefixed(s->lib, "OMX_GetComponentsOfRole", prefix);
+    s->ptr_GetRolesOfComponent = dlsym_prefixed(s->lib, "OMX_GetRolesOfComponent", prefix);
+
+    if (!s->ptr_Init || !s->ptr_Deinit || !s->ptr_ComponentNameEnum ||
+        !s->ptr_GetHandle || !s->ptr_FreeHandle ||
+        !s->ptr_GetComponentsOfRole || !s->ptr_GetRolesOfComponent) {
+        av_log(logctx, AV_LOG_WARNING, "Not all functions found in %s\n", libname);
+        dlclose(s->lib);
+        s->lib = NULL;
+        if (s->lib2)
+            dlclose(s->lib2);
+        s->lib2 = NULL;
+        return AVERROR_DECODER_NOT_FOUND;
+    }
+    return 0;
+}
+
+
+static int print_omx_env(OMXContext *omx_context)
+{
+    OMX_ERRORTYPE err;
+    OMX_U32 numComps = 0;
+    OMX_U8 component[OMX_MAX_STRINGNAME_SIZE];
+    OMX_U8 **roleList;
+
+    if (omx_context == NULL) {
+        //omx_env unready
+        return 0;
+    }
+
+    if (omx_context->ptr_ComponentNameEnum == NULL) {
+        //ptr_ComponentNameEnum unready
+        return 0;
+
+    }
+    numComps = 0;
+    while (err == OMX_ErrorNone) {
+        err = omx_context->ptr_ComponentNameEnum(component, OMX_MAX_STRINGNAME_SIZE, numComps);
+        if (err == OMX_ErrorNone) {
+            OMX_U32 numberofroles = 0;
+            omx_context->ptr_GetRolesOfComponent(component, &numberofroles, NULL);
+
+            if (numberofroles == 1) {
+                roleList = malloc(numberofroles * sizeof(OMX_U8 *));
+                roleList[0] =  malloc(OMX_MAX_STRINGNAME_SIZE);
+                omx_context->ptr_GetRolesOfComponent(component, &numberofroles, roleList);
+                free(roleList[0]);
+                free(roleList);
+            }
+        }
+        numComps++;
+    }
+
+    return 0;
+}
+
+static av_cold OMXContext *omx_init(void *logctx, const char *libname, const char *prefix)
+{
+    static const char *const libnames[] = {
+#if 0
+        "/opt/vc/lib/libopenmaxil.so", "/opt/vc/lib/libbcm_host.so",
+#else
+        "libomxil-bellagio.so.0", NULL,
+        "libOMX_Core.so", NULL,
+        "libOmxCore.so", NULL,
+#endif
+        NULL
+    };
+    const char *const *nameptr;
+    int ret = AVERROR_DECODER_NOT_FOUND;
+    OMXContext *omx_context;
+    OMX_ERRORTYPE error;
+    omx_context = av_mallocz(sizeof(*omx_context));
+    if (!omx_context)
+        return NULL;
+    if (libname) {
+
+        ret = omx_try_load(omx_context, logctx, libname, prefix, NULL);
+        if (ret < 0) {
+            av_free(omx_context);
+            return NULL;
+        }
+    } else {
+        for (nameptr = libnames; *nameptr; nameptr += 2)
+            if (!(ret = omx_try_load(omx_context, logctx, nameptr[0], prefix, nameptr[1])))
+                break;
+        if (!*nameptr) {
+            av_free(omx_context);
+            return NULL;
+        }
+    }
+
+    if (omx_context->host_init)
+        omx_context->host_init();
+    av_log(NULL, AV_LOG_INFO, "OMX_count load %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        error = omx_context->ptr_Init();
+        if (error != OMX_ErrorNone) {
+            av_log(NULL, AV_LOG_WARNING, "OMX Init error\n");
+        }
+    }
+    omx_load_count++;
+    print_omx_env(omx_context);
+    return omx_context;
+}
+
+static av_cold void omx_deinit(OMXContext *omx_context)
+{
+    if (!omx_context)
+        return;
+    omx_load_count--;
+    av_log(NULL, AV_LOG_INFO, "OMX_count %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        omx_context->ptr_Deinit();
+        dlclose(omx_context->lib);
+    }
+    av_free(omx_context);
+}
+
+typedef struct OMXCodecDecoderContext {
+    const AVClass *class;
+    char *libname;
+    char *libprefix;
+    OMXContext *omx_context;
+
+    AVCodecContext *avctx;
+    //OmxCodecDecContext *ctx;
+
+    char component_name[OMX_MAX_STRINGNAME_SIZE];
+    OMX_VERSIONTYPE version;
+    OMX_HANDLETYPE handle;
+    int in_port, out_port;
+    //OMX_COLOR_FORMATTYPE color_format;
+    int stride, plane_size;
+
+    int num_in_buffers, num_out_buffers;
+    int in_buffer_size, out_buffer_size;
+    OMX_BUFFERHEADERTYPE **in_buffer_headers;
+    OMX_BUFFERHEADERTYPE **out_buffer_headers;
+    int num_free_in_buffers;
+    OMX_BUFFERHEADERTYPE **free_in_buffers;
+    int num_done_out_buffers;
+    OMX_BUFFERHEADERTYPE **done_out_buffers;
+    pthread_mutex_t input_mutex;
+    pthread_cond_t input_cond;
+
+    pthread_mutex_t output_mutex;
+    pthread_cond_t output_cond;
+
+    pthread_mutex_t state_mutex;
+    pthread_cond_t state_cond;
+
+    pthread_mutex_t eof_mutex;
+    pthread_cond_t eof_cond;
+
+    OMX_STATETYPE state;
+    OMX_ERRORTYPE error;
+
+    unsigned mutex_cond_inited_cnt;
+
+    int eos_sent, got_eos, draining, need_sendeos, eos_reach;
+
+    int input_zerocopy;
+    int profile;
+    //for receiving frame
+    int flushing;
+
+    int delay_flush;
+    int fast_render;
+    int mirror;
+    int rotation;/*0 ~3 means 0 90 180 270 degree*/
+    atomic_int serial;
+    int first_pkt;
+    AVPacket buffered_pkt;
+    int out_stride, out_slice_height;
+    int crop_top, crop_left;
+
+    int format_changed;
+    int input_count;
+    int output_count;
+    DecoderStatus status;
+    pthread_t output_tid;
+    //AVThread *thread_out;
+    int portSettingidle;
+    int reconfigPending;
+    int outport_disabled;
+    int pkt_full;
+    int sent_pkt_num;
+    int offscreen;
+    int now_pts;
+    int pkt_duration;
+    int resolution_changed;
+    int output_width;
+    int output_height;
+    OMX_BUFFERHEADERTYPE *temp_buffer;
+
+    OMX_COLOR_FORMATTYPE outformat;
+    //AsyncQueue *pic_queue;
+} OMXCodecDecoderContext;
+
+#define NB_MUTEX_CONDS 8
+#define OFF(field) offsetof(OMXCodecDecoderContext, field)
+
+static void append_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
+                          int *array_size, OMX_BUFFERHEADERTYPE **array,
+                          OMX_BUFFERHEADERTYPE *buffer)
+{
+    pthread_mutex_lock(mutex);
+    array[(*array_size)++] = buffer;
+    pthread_cond_broadcast(cond);
+    pthread_mutex_unlock(mutex);
+}
+
+/*0 ,return imediately, -1 wait buffer return, else such as 100, mean timeout is 100ms */
+static OMX_BUFFERHEADERTYPE *get_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
+                                        int *array_size, OMX_BUFFERHEADERTYPE ***array,
+                                        int timeOut)
+{
+    struct timeval  start, end;
+    long int elapse;
+    OMX_BUFFERHEADERTYPE *buffer;
+    if (timeOut != 0) {
+        gettimeofday(&start, NULL);
+        while (!*array_size) {
+            if (timeOut > 0) {
+                gettimeofday(&end, NULL);
+                elapse = (end.tv_sec - start.tv_sec) * 1000 + (end.tv_usec - start.tv_usec) / 1000;
+                if (elapse > timeOut) {
+                    break;
+                }
+            } else if (timeOut == -1) {
+                break;
+            }
+        }
+    }
+
+    if (*array_size > 0) {
+        pthread_mutex_lock(mutex);
+        buffer = *array[0];
+        (*array_size)--;
+        memmove(&(*array)[0], &(*array)[1], (*array_size) * sizeof(OMX_BUFFERHEADERTYPE *));
+        pthread_mutex_unlock(mutex);
+    } else {
+        buffer = NULL;
+    }
+    return buffer;
+}
+
+static void checkstate(OMXCodecDecoderContext *s, OMX_U32 state)
+{
+    switch (state) {
+    case OMX_StateMax:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StateMax\n");
+        break;
+    case OMX_StateLoaded:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StateLoaded\n");
+        break;
+    case OMX_StateIdle:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StateIdle\n");
+        break;
+    case OMX_StateExecuting:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StateExecuting\n");
+        break;
+    case OMX_StatePause:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StatePause\n");
+        break;
+    case OMX_StateWaitForResources:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX_StateWaitForResources\n");
+        break;
+    }
+}
+
+static void say(OMXCodecDecoderContext *s, const char *message, ...)
+{
+    va_list args;
+    size_t str_len;
+    char str[1024];
+    memset(str, 0, sizeof(str));
+    va_start(args, message);
+    vsnprintf(str, sizeof(str) - 1, message, args);
+    va_end(args);
+    str_len = strlen(str);
+    if (str[str_len - 1] != '\n') {
+        str[str_len] = '\n';
+    }
+
+    av_log(s->avctx, AV_LOG_INFO, "%s", str);
+}
+
+
+static const char *dump_compression_format(OMXCodecDecoderContext *s, OMX_VIDEO_CODINGTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_VIDEO_CodingUnused:
+        return "not used";
+    case OMX_VIDEO_CodingAutoDetect:
+        return "autodetect";
+    case OMX_VIDEO_CodingMPEG2:
+        return "MPEG2";
+    case OMX_VIDEO_CodingH263:
+        return "H.263";
+    case OMX_VIDEO_CodingMPEG4:
+        return "MPEG4";
+    case OMX_VIDEO_CodingWMV:
+        return "Windows Media Video";
+    case OMX_VIDEO_CodingRV:
+        return "RealVideo";
+    case OMX_VIDEO_CodingAVC:
+        return "H.264/AVC";
+    case OMX_VIDEO_CodingMJPEG:
+        return "Motion JPEG";
+//        case OMX_VIDEO_CodingTheora:     return "OGG Theora";
+
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory\n");
+        }
+        sprintf(f, "format type 0x%08x", c);
+        return f;//maybe memleak
+    }
+}
+
+static const char *dump_color_format(OMXCodecDecoderContext *s, OMX_COLOR_FORMATTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_COLOR_FormatUnused:
+        return "OMX_COLOR_FormatUnused: not used";
+    case OMX_COLOR_FormatMonochrome:
+        return "OMX_COLOR_FormatMonochrome";
+    case OMX_COLOR_Format8bitRGB332:
+        return "OMX_COLOR_Format8bitRGB332";
+    case OMX_COLOR_Format12bitRGB444:
+        return "OMX_COLOR_Format12bitRGB444";
+    case OMX_COLOR_Format16bitARGB4444:
+        return "OMX_COLOR_Format16bitARGB4444";
+    case OMX_COLOR_Format16bitARGB1555:
+        return "OMX_COLOR_Format16bitARGB1555";
+    case OMX_COLOR_Format16bitRGB565:
+        return "OMX_COLOR_Format16bitRGB565";
+    case OMX_COLOR_Format16bitBGR565:
+        return "OMX_COLOR_Format16bitBGR565";
+    case OMX_COLOR_Format18bitRGB666:
+        return "OMX_COLOR_Format18bitRGB666";
+    case OMX_COLOR_Format18bitARGB1665:
+        return "OMX_COLOR_Format18bitARGB1665";
+    case OMX_COLOR_Format19bitARGB1666:
+        return "OMX_COLOR_Format19bitARGB1666";
+    case OMX_COLOR_Format24bitRGB888:
+        return "OMX_COLOR_Format24bitRGB888";
+    case OMX_COLOR_Format24bitBGR888:
+        return "OMX_COLOR_Format24bitBGR888";
+    case OMX_COLOR_Format24bitARGB1887:
+        return "OMX_COLOR_Format24bitARGB1887";
+    case OMX_COLOR_Format25bitARGB1888:
+        return "OMX_COLOR_Format25bitARGB1888";
+    case OMX_COLOR_Format32bitBGRA8888:
+        return "OMX_COLOR_Format32bitBGRA8888";
+    case OMX_COLOR_Format32bitARGB8888:
+        return "OMX_COLOR_Format32bitARGB8888";
+    case OMX_COLOR_FormatYUV411Planar:
+        return "OMX_COLOR_FormatYUV411Planar";
+    case OMX_COLOR_FormatYUV411PackedPlanar:
+        return "OMX_COLOR_FormatYUV411PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420Planar:
+        return "OMX_COLOR_FormatYUV420Planar: Planar YUV, 4:2:0 (I420)";
+    case OMX_COLOR_FormatYUV420PackedPlanar:
+        return "OMX_COLOR_FormatYUV420PackedPlanar: Planar YUV, 4:2:0 (I420), planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420SemiPlanar:
+        return "OMX_COLOR_FormatYUV420SemiPlanar, Planar YUV, 4:2:0 (NV12), U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422Planar:
+        return "OMX_COLOR_FormatYUV422Planar";
+    case OMX_COLOR_FormatYUV422PackedPlanar:
+        return "OMX_COLOR_FormatYUV422PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV422SemiPlanar:
+        return "OMX_COLOR_FormatYUV422SemiPlanar";
+    case OMX_COLOR_FormatYCbYCr:
+        return "OMX_COLOR_FormatYCbYCr";
+    case OMX_COLOR_FormatYCrYCb:
+        return "OMX_COLOR_FormatYCrYCb";
+    case OMX_COLOR_FormatCbYCrY:
+        return "OMX_COLOR_FormatCbYCrY";
+    case OMX_COLOR_FormatCrYCbY:
+        return "OMX_COLOR_FormatCrYCbY";
+    case OMX_COLOR_FormatYUV444Interleaved:
+        return "OMX_COLOR_FormatYUV444Interleaved";
+    case OMX_COLOR_FormatRawBayer8bit:
+        return "OMX_COLOR_FormatRawBayer8bit";
+    case OMX_COLOR_FormatRawBayer10bit:
+        return "OMX_COLOR_FormatRawBayer10bit";
+    case OMX_COLOR_FormatRawBayer8bitcompressed:
+        return "OMX_COLOR_FormatRawBayer8bitcompressed";
+    case OMX_COLOR_FormatL2:
+        return "OMX_COLOR_FormatL2";
+    case OMX_COLOR_FormatL4:
+        return "OMX_COLOR_FormatL4";
+    case OMX_COLOR_FormatL8:
+        return "OMX_COLOR_FormatL8";
+    case OMX_COLOR_FormatL16:
+        return "OMX_COLOR_FormatL16";
+    case OMX_COLOR_FormatL24:
+        return "OMX_COLOR_FormatL24";
+    case OMX_COLOR_FormatL32:
+        return "OMX_COLOR_FormatL32";
+    case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV420PackedSemiPlanar: Planar YUV, 4:2:0 (NV12), planes fragmented when a frame is split in multiple buffers, U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV422PackedSemiPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_Format18BitBGR666:
+        return "OMX_COLOR_Format18BitBGR666";
+    case OMX_COLOR_Format24BitARGB6666:
+        return "OMX_COLOR_Format24BitARGB6666";
+    case OMX_COLOR_Format24BitABGR6666:
+        return "OMX_COLOR_Format24BitABGR6666";
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory\n");
+        }
+        sprintf(f,  "format type 0x%08x", c);
+        return f;
+    }
+}
+
+static void dump_portdef(OMXCodecDecoderContext *s, OMX_PARAM_PORTDEFINITIONTYPE *portdef)
+{
+    OMX_VIDEO_PORTDEFINITIONTYPE *viddef = &portdef->format.video;
+    OMX_IMAGE_PORTDEFINITIONTYPE *imgdef = &portdef->format.image;
+
+    say(s, "Port %d is %s, %s, buffers wants:%d needs:%d, size:%d, pop:%d, aligned:%d",
+        portdef->nPortIndex,
+        (portdef->eDir ==  OMX_DirInput ? "input" : "output"),
+        (portdef->bEnabled == OMX_TRUE ? "enabled" : "disabled"),
+        portdef->nBufferCountActual,
+        portdef->nBufferCountMin,
+        portdef->nBufferSize,
+        portdef->bPopulated,
+        portdef->nBufferAlignment);
+
+
+    switch (portdef->eDomain) {
+    case OMX_PortDomainVideo:
+        say(s, "Video type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tBitrate:\t%d\n"
+            "\tFramerate:\t%.02f\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            viddef->nFrameWidth,
+            viddef->nFrameHeight,
+            viddef->nStride,
+            viddef->nSliceHeight,
+            viddef->nBitrate,
+            ((float)viddef->xFramerate / (float)65536),
+            (viddef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, viddef->eCompressionFormat),
+            dump_color_format(s, viddef->eColorFormat));
+        break;
+    case OMX_PortDomainImage:
+        say(s, "Image type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            imgdef->nFrameWidth,
+            imgdef->nFrameHeight,
+            imgdef->nStride,
+            imgdef->nSliceHeight,
+            (imgdef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, imgdef->eCompressionFormat),
+            dump_color_format(s, imgdef->eColorFormat));
+        break;
+    default:
+        break;
+    }
+}
+
+static av_cold int wait_for_state(OMXCodecDecoderContext *s, OMX_STATETYPE state);
+
+static void OnOutputPortEnabled(OMXCodecDecoderContext *s)
+{
+    av_log(s->avctx, AV_LOG_WARNING, "OnOutputPortEnabled\n");
+    s->outport_disabled = 0;
+    s->reconfigPending = 0;
+}
+
+static int OnOutputPortDisabled(OMXCodecDecoderContext *s)
+{
+    int i;
+    AVCodecContext *avctx = s->avctx;
+    OMX_ERRORTYPE err;
+    OMX_PARAM_PORTDEFINITIONTYPE out_port_params;
+    av_log(s->avctx, AV_LOG_WARNING, "OnOutputPortDisabled\n");
+    if (s->reconfigPending) {
+        INIT_STRUCT(out_port_params);
+        out_port_params.nPortIndex = s->out_port;
+        OMX_GetParameter(
+            s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+
+        pthread_mutex_lock(&s->output_mutex);
+        s->num_out_buffers = out_port_params.nBufferCountMin + 5;
+        out_port_params.nBufferCountActual = out_port_params.nBufferCountMin + 5;
+
+        err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+        CHECK(err);
+
+        s->out_buffer_headers = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+        s->done_out_buffers   = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+        if (!s->out_buffer_headers || !s->done_out_buffers) {
+            s->num_done_out_buffers = 0;
+            pthread_mutex_unlock(&s->output_mutex);
+            av_log(s->avctx, AV_LOG_ERROR, "Something wrong with out_buffers.\n");
+            return AVERROR(ENOMEM);
+        }
+        for (i = 0; i < s->num_out_buffers ; i++) {
+            err = OMX_AllocateBuffer(s->handle, &s->out_buffer_headers[i], s->out_port, s, out_port_params.nBufferSize);
+            s->out_buffer_headers[i]->pAppPrivate = s->out_buffer_headers[i]->pOutputPortPrivate = NULL;
+            s->out_buffer_headers[i]->pAppPrivate = NULL;
+            s->out_buffer_headers[i]->nTimeStamp = -1;
+            s->out_buffer_headers[i]->nOutputPortIndex =  s->out_port;
+            CHECK(err);
+        }
+
+        s->num_out_buffers = i;
+        s->num_done_out_buffers = 0;
+        for (i = 0; i < s->num_out_buffers && err == OMX_ErrorNone; i++) {
+            err = OMX_FillThisBuffer(s->handle, s->out_buffer_headers[i]);
+        }
+
+        if (err != OMX_ErrorNone) {
+            av_log(avctx, AV_LOG_WARNING, "FillOutBuffer failed , so set header\n");
+            for (i = 0; i < s->num_out_buffers; i++) {
+                s->done_out_buffers[s->num_done_out_buffers++] = s->out_buffer_headers[i];
+            }
+        }
+
+        av_log(s->avctx, AV_LOG_WARNING, "Send OMX_CommandPortEnable\n");
+        err = OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->out_port, NULL);
+        CHECK(err);
+        pthread_mutex_unlock(&s->output_mutex);
+    }
+    return 0;
+}
+
+static int onPortSettingChanged(OMXCodecDecoderContext *s, OMX_PARAM_PORTDEFINITIONTYPE *out_port_params)
+{
+    AVCodecContext *avctx = s->avctx;
+
+    av_log(s->avctx, AV_LOG_WARNING, "onPortSettingChanged\n");
+
+    //if ((out_port_params->nBufferCountActual < out_port_params->nBufferCountMin)
+    //    || (out_port_params->nBufferSize > s->out_buffer_size)) {
+    OMX_ERRORTYPE err;
+    int i = 0;
+    s->outport_disabled = 1;
+    av_log(s->avctx, AV_LOG_WARNING, "nBufferCountActual modify!\n");
+    err = OMX_SendCommand(s->handle, OMX_CommandPortDisable, s->out_port, NULL);
+    CHECK(err);
+    s->reconfigPending = 1;
+    pthread_mutex_lock(&s->output_mutex);
+    if (&s->out_buffer_headers) {
+        av_freep(&s->out_buffer_headers);
+    }
+    if (&s->done_out_buffers) {
+        av_freep(&s->done_out_buffers);
+    }
+    s->num_out_buffers = 0;
+    s->num_done_out_buffers = 0;
+    pthread_mutex_unlock(&s->output_mutex);
+    //} else {
+    //    OMX_ERRORTYPE err;
+    //    err = OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->out_port, NULL);
+    //    CHECK(err);
+    //}
+
+    return 0;
+}
+
+static int onIdleState(OMXCodecDecoderContext *s)
+{
+    if (s->portSettingidle == 1) {
+        av_log(s->avctx, AV_LOG_ERROR, "onIdleState after portSettingidle\n");
+
+        if (OMX_ErrorNone != OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateExecuting, NULL)) {
+            av_log(s->avctx, AV_LOG_ERROR, "unable to set OMX_StateExecuting state\n");
+        }
+
+        s->portSettingidle = 0;
+    }
+
+    return  0;
+}
+
+static OMX_ERRORTYPE event_handler(OMX_HANDLETYPE component, OMX_PTR app_data, OMX_EVENTTYPE event,
+                                   OMX_U32 data1, OMX_U32 data2, OMX_PTR event_data)
+{
+    OMXCodecDecoderContext *s = app_data;
+    // This uses casts in the printfs, since OMX_U32 actually is a typedef for
+    // unsigned long in official header versions (but there are also modified
+    // versions where it is something else).
+    //av_log(s->avctx, AV_LOG_WARNING, "event_handler OMXCodecDecoderContext %p\n", s);
+    switch (event) {
+    case OMX_EventError:
+        pthread_mutex_lock(&s->state_mutex);
+        s->error = data1;
+        pthread_cond_broadcast(&s->state_cond);
+        pthread_mutex_unlock(&s->state_mutex);
+
+        switch (data1) {
+        case OMX_ErrorInsufficientResources:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorInsufficientResources, stop decode!\n");
+            break;
+        case OMX_ErrorInvalidState:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorInvalidState!\n");
+            s->state = OMX_StateInvalid;
+            break;
+        case OMX_ErrorNotReady:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorNotReady!\n");
+            break;
+        case OMX_ErrorIncorrectStateOperation:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorIncorrectStateOperation!\n");
+            break;
+        case OMX_ErrorTimeout:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorTimeout!\n");
+            break;
+        case OMX_ErrorIncorrectStateTransition:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorTimeout!\n");
+            break;
+        default:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX error %"PRIx32"\n", (uint32_t) data1);
+            break;
+        }
+        return OMX_ErrorNone;
+    case OMX_EventCmdComplete:
+        if (data1 == OMX_CommandStateSet) {
+            pthread_mutex_lock(&s->state_mutex);
+            s->state = data2;
+            checkstate(s, data2);
+            if (data2 == OMX_StateIdle) {
+                onIdleState(s);
+            }
+
+            pthread_cond_broadcast(&s->state_cond);
+            pthread_mutex_unlock(&s->state_mutex);
+        } else if (data1 == OMX_CommandPortDisable) {
+            av_log(s->avctx, AV_LOG_INFO, "OMX port %"PRIu32" disabled\n", (uint32_t) data2);
+            if (data2 == s->out_port) {
+                OnOutputPortDisabled(s);
+            }
+        } else if (data1 == OMX_CommandPortEnable) {
+            av_log(s->avctx, AV_LOG_INFO, "OMX port %"PRIu32" enabled\n", (uint32_t) data2);
+            if (data2 == s->out_port) {
+                OnOutputPortEnabled(s);
+            }
+        } else if (data1 == OMX_CommandFlush) {
+            av_log(s->avctx, AV_LOG_WARNING, "OMX port %"PRIu32" flushed\n", (uint32_t) data2);
+        } else {
+            av_log(s->avctx, AV_LOG_WARNING, "OMX command complete, command %"PRIu32", value %"PRIu32"\n",
+                   (uint32_t) data1, (uint32_t) data2);
+        }
+        break;
+    case OMX_EventPortSettingsChanged:
+        if ((int)data1 == OMX_DirOutput) { //out is OMX_DirOutput
+            OMX_PARAM_PORTDEFINITIONTYPE out_port_params;
+            av_log(s->avctx, AV_LOG_INFO, "OMX outport settings changed: out_port: %d\n", s->out_port);
+
+            INIT_STRUCT(out_port_params);
+            out_port_params.nPortIndex = s->out_port;
+            OMX_GetParameter(
+                s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+            dump_portdef(s, &out_port_params);
+            s->outformat = out_port_params.format.video.eColorFormat ;
+
+            s->out_stride       = out_port_params.format.video.nStride;
+            s->out_slice_height = out_port_params.format.video.nSliceHeight;
+
+            onPortSettingChanged(s, &out_port_params);
+
+        } else if (data1 == s->out_port && data2 == OMX_IndexConfigCommonOutputCrop) {
+            // TODO: Handle video crop rect.
+        } else if (data1 == s->out_port && data2 == OMX_IndexConfigCommonScale) {
+            // TODO: Handle video SAR change.
+        } else {
+            av_log(s->avctx, AV_LOG_WARNING, "error event \n");
+        }
+
+        break;
+    case OMX_EventBufferFlag:
+        if (data1 == s->out_port) {
+            //
+        }
+        break;
+    default:
+        av_log(s->avctx, AV_LOG_WARNING, "OMX event %d %"PRIx32" %"PRIx32"\n",
+               event, (uint32_t) data1, (uint32_t) data2);
+        break;
+    }
+    return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE empty_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                       OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecDecoderContext *s = app_data;
+    append_buffer(&s->input_mutex, &s->input_cond,
+                  &s->num_free_in_buffers, s->free_in_buffers, buffer);
+    return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE fill_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                      OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMX_ERRORTYPE err;
+    OMXCodecDecoderContext *s = app_data;
+    if (!buffer->nFilledLen) {
+        int i = 0;
+        for (i = 0; i < s->num_out_buffers; i++) {
+            if (s->out_buffer_headers[i] == buffer && s->out_buffer_headers[i]) {
+                break;
+            }
+        }
+
+        if (i == s->num_out_buffers) {
+            OMX_FreeBuffer(s->handle, 1, buffer);
+            return OMX_ErrorNone;
+        }
+    }
+    append_buffer(&s->output_mutex, &s->output_cond,
+                  &s->num_done_out_buffers, s->done_out_buffers, buffer);
+
+
+    return OMX_ErrorNone;
+}
+
+
+static const OMX_CALLBACKTYPE decoder_callbacks = {
+    event_handler,
+    empty_buffer_done,
+    fill_buffer_done
+};
+
+static av_cold int omx_dec_find_component(OMXContext *omx_context, void *logctx,
+        const char *role, char *str, int str_size)
+{
+    OMX_U32 i, num = 0;
+    char **components;
+    int ret = 0;
+
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, NULL);
+    if (!num) {
+        av_log(logctx, AV_LOG_WARNING, "No component for role %s found\n", role);
+        return AVERROR_DECODER_NOT_FOUND;
+    }
+    components = av_calloc(num, sizeof(*components));
+    if (!components)
+        return AVERROR(ENOMEM);
+    for (i = 0; i < num; i++) {
+        components[i] = av_mallocz(OMX_MAX_STRINGNAME_SIZE);
+        if (!components[i]) {
+            ret = AVERROR(ENOMEM);
+            goto end;
+        }
+    }
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, (OMX_U8 **) components);
+    av_strlcpy(str, components[0], str_size);
+end:
+    for (i = 0; i < num; i++)
+        av_free(components[i]);
+    av_free(components);
+    return ret;
+}
+
+static av_cold int wait_for_state(OMXCodecDecoderContext *s, OMX_STATETYPE state)
+{
+    int ret = 0;
+    pthread_mutex_lock(&s->state_mutex);
+    while (s->state != state && s->error == OMX_ErrorNone)
+        pthread_cond_wait(&s->state_cond, &s->state_mutex);
+    if (s->error != OMX_ErrorNone)
+        ret = AVERROR_DECODER_NOT_FOUND;
+    pthread_mutex_unlock(&s->state_mutex);
+    return ret;
+}
+
+static av_cold int wait_for_eof(OMXCodecDecoderContext *s)
+{
+    int ret = 0;
+    pthread_mutex_lock(&s->eof_mutex);
+    while (s->got_eos != 1)
+        pthread_cond_wait(&s->eof_cond, &s->eof_mutex);
+
+    pthread_mutex_unlock(&s->eof_mutex);
+    return ret;
+}
+
+static int omx_send_extradata(AVCodecContext *avctx)
+{
+    OMX_BUFFERHEADERTYPE *buffer;
+    OMX_ERRORTYPE err;
+    if (avctx->extradata_size > 0) {
+        int64_t timeout = 60;
+        OMXCodecDecoderContext *s = avctx->priv_data;
+
+        buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                            &s->num_free_in_buffers, &s->free_in_buffers, timeout);
+        buffer->nFilledLen = avctx->extradata_size;
+        buffer->nFlags = OMX_BUFFERFLAG_EXTRADATA;
+        buffer->nOffset = 0;
+        memcpy(buffer->pBuffer, avctx->extradata, avctx->extradata_size);
+        err = OMX_EmptyThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "omx_send_extradata OMX_EmptyThisBuffer failed: %x\n", err);
+            return -1;
+        }
+
+        av_log(avctx, AV_LOG_INFO, "omx_send_extradata finished: %x\n");
+    }
+    return 0;
+}
+
+#define FORMAT_NV12
+
+static void copyNV12toDst(OMXCodecDecoderContext *s, AVFrame *avframe, OMX_BUFFERHEADERTYPE *buffer)
+{
+    avframe->width = (OMX_U32) s->avctx->width;
+    avframe->height = (OMX_U32) s->avctx->height;
+    avframe->linesize[0] = avframe->width;
+    avframe->linesize[1] = avframe->width;
+    int y_size = avframe->linesize[0] * avframe->height;
+    int uv_size = y_size / 2;
+    int src_stride = s->out_stride;
+    uint8_t *y_src = (uint8_t *)(buffer->pBuffer);
+    uint8_t *y_dst = avframe->data[0];
+    uint8_t *uv_src = (uint8_t *)(buffer->pBuffer) + y_size;
+    uint8_t *uv_dst = avframe->data[1];
+    if (s->offscreen && !s->resolution_changed) {
+        avframe->data[0] = y_src;
+        avframe->data[1] = uv_src;
+    } else if (s->resolution_changed) {
+        for (int i = 0; i < avframe->height; i++) {
+            memcpy(y_dst + i * avframe->linesize[0], y_src + i * src_stride, avframe->linesize[0]);
+        }
+        for (int i = 0; i < avframe->height / 2; i++) {
+            memcpy(uv_dst + i * avframe->linesize[1], y_src + src_stride * avframe->height + i * src_stride, avframe->linesize[1]);
+        }
+    } else {
+        memcpy(y_dst, y_src, avframe->width *  avframe->height);
+        memcpy(uv_dst, uv_src, uv_size);
+    }
+}
+
+static void convertNV12toYUV420(OMXCodecDecoderContext *s, AVFrame *avframe, OMX_BUFFERHEADERTYPE *buffer)
+{
+#ifdef __OMX_ENABLE_SWCALE
+    const uint8_t *src_data[3];
+    int srclinesize[3];
+
+    srclinesize[0] = avframe->width;
+    srclinesize[1] = avframe->width;
+    srclinesize[2] = 0;
+
+    src_data[0] = (uint8_t *)(buffer->pBuffer);
+    src_data[1] = (uint8_t *)(buffer->pBuffer) + (avframe->width *  avframe->height) ;
+    src_data[2] = 0;
+
+    if (m_pSwsCtx == NULL) {
+        m_pSwsCtx = sws_getContext(avctx->width,
+                                   avctx->height,
+                                   AV_PIX_FMT_NV12,
+                                   avctx->width,
+                                   avctx->height,
+                                   AV_PIX_FMT_YUV420P, SWS_FAST_BILINEAR, NULL, NULL, NULL);
+    }
+
+    if (m_pSwsCtx == NULL) {
+        printf("Error converting\n");
+    } else {
+        sws_scale(m_pSwsCtx, src_data, srclinesize, 0,  avframe->height, avframe->data, avframe->linesize);
+    }
+#else
+    avframe->width = (OMX_U32) s->avctx->width;
+    avframe->height = (OMX_U32) s->avctx->height;
+    avframe->linesize[0] = avframe->width;
+    avframe->linesize[1] = avframe->width / 2;
+    avframe->linesize[2] = avframe->width / 2;
+    uint8_t *y_src = (uint8_t *)(buffer->pBuffer);
+    uint8_t *y_dst = avframe->data[0];
+
+    uint8_t *uv_src, *u_dst, *v_dst;
+    int src_stride = s->out_stride;
+    int y_src_size =  s->out_stride *  s->out_slice_height;
+    uint8_t *uv_src_start = (uint8_t *)(buffer->pBuffer) + y_src_size;
+
+    for (int i = 0; i < avframe->height; i++) {
+        memcpy(y_dst + i * avframe->linesize[0], y_src + i * src_stride, src_stride);
+    }
+
+
+    for (int i = 0; i < avframe->height / 2; i++) {
+        u_dst = avframe->data[1] + i * avframe->linesize[1];
+        v_dst = avframe->data[2] + i * avframe->linesize[2];
+        uv_src = uv_src_start + i *  src_stride ;
+
+        for (int j = 0; j < (avframe->width + 1) / 2; j++) {
+            *(u_dst++) = *(uv_src++);
+            *(v_dst++) = *(uv_src++);
+        }
+    }
+#endif
+}
+
+static int omx_try_filltempbuffer(AVCodecContext *avctx)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    OMX_ERRORTYPE err;
+    if (s->offscreen) {
+        if (s->temp_buffer) {
+            err = OMX_FillThisBuffer(s->handle, s->temp_buffer);
+            if (err != OMX_ErrorNone) {
+                append_buffer(&s->output_mutex, &s->output_cond, &s->num_done_out_buffers, s->done_out_buffers, s->temp_buffer);
+                av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+            }
+            s->temp_buffer = NULL;
+        }
+    }
+    return 0;
+}
+
+static void free_frame_buffer(void *opaque, uint8_t *data)
+{
+    OMXCodecDecoderContext *s = opaque;
+    AVCodecContext *avctx = s->avctx;
+
+    if (s->offscreen) {
+        omx_try_filltempbuffer(avctx);
+    } else {
+        if (data != NULL) {
+            av_free(data);
+        }
+    }
+}
+
+static int check_buffer_outsize(OMXCodecDecoderContext *s, OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMX_ERRORTYPE err;
+    AVCodecContext *avctx = s->avctx;
+    OMX_PARAM_PORTDEFINITIONTYPE out_port_params = {0};
+    INIT_STRUCT(out_port_params);
+    out_port_params.nPortIndex = s->out_port;
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+    CHECK(err);
+    if (avctx->width != out_port_params.format.video.nFrameWidth ||
+        avctx->height != out_port_params.format.video.nFrameHeight) {
+        avctx->width = out_port_params.format.video.nFrameWidth;
+        avctx->height = out_port_params.format.video.nFrameHeight;
+        avctx->coded_width = out_port_params.format.video.nFrameWidth;
+        avctx->coded_height = out_port_params.format.video.nFrameHeight;
+        s->resolution_changed = 1;
+    }
+    return 0;
+}
+
+static int ff_omx_dec_receive(AVCodecContext *avctx, OMXCodecDecoderContext *s,
+                              AVFrame *avframe, bool wait)
+{
+    OMX_ERRORTYPE err;
+    int ret;
+    if (s->draining && s->got_eos) {
+        return AVERROR_EOF;
+    }
+
+    if (s->offscreen) {
+        if (s->temp_buffer) {
+            err = OMX_FillThisBuffer(s->handle, s->temp_buffer);
+            if (err != OMX_ErrorNone) {
+                append_buffer(&s->output_mutex, &s->output_cond, &s->num_done_out_buffers, s->done_out_buffers, s->temp_buffer);
+                av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+            }
+            s->temp_buffer = NULL;
+        }
+    }
+    OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                                   &s->num_done_out_buffers, &s->done_out_buffers,
+                                   -1);
+    if (!buffer) {
+        //omx_outputbuffer_thread  error
+        return AVERROR(EAGAIN);
+    }
+
+    if (buffer->nFlags & OMX_BUFFERFLAG_EOS) {
+        av_log(avctx, AV_LOG_WARNING, "OMX_BUFFERFLAG_EOS reached\n");
+
+        pthread_mutex_lock(&s->eof_mutex);
+        s->got_eos = 1;
+        pthread_cond_broadcast(&s->eof_cond);
+        pthread_mutex_unlock(&s->eof_mutex);
+    }
+
+    if (buffer->nFilledLen == 0) {
+        err = OMX_FillThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->output_mutex, &s->output_cond, &s->num_done_out_buffers, s->done_out_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+        }
+        return AVERROR(EAGAIN);
+    }
+
+    s->output_count++;
+    check_buffer_outsize(s, buffer);
+#ifdef FORMAT_NV12
+    avctx->pix_fmt = AV_PIX_FMT_NV12;
+#endif
+    ret = ff_get_buffer(avctx, avframe, AV_GET_BUFFER_FLAG_REF);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "ff_get_buffer failed: %x\n", ret);
+        return ret;
+    }
+
+    if (buffer->nFlags == OMX_BUFFERFLAG_SYNCFRAME) {
+        avframe->flags |= AV_PICTURE_TYPE_I;
+    }
+    avframe->pts = av_rescale_q(from_omx_ticks(buffer->nTimeStamp), AV_TIME_BASE_Q, avctx->time_base);
+    avframe->pkt_dts = AV_NOPTS_VALUE;
+    if (avframe->pts <= 0 && s->pkt_duration) {
+        avframe->pts = s->now_pts;
+        s->now_pts += s->pkt_duration;
+    }
+
+#ifdef FORMAT_NV12
+    copyNV12toDst(s, avframe, buffer);
+#else
+    convertNV12toYUV420(s, avframe, buffer);
+#endif
+
+    if (s->offscreen) {
+        s->temp_buffer = buffer;
+    } else {
+        err = OMX_FillThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->output_mutex, &s->output_cond, &s->num_done_out_buffers, s->done_out_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+        }
+    }
+    //OMX_FillThisBuffer finished
+    return 0;
+}
+
+static av_cold int omx_component_init_decoder(AVCodecContext *avctx, const char *role)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    OMX_PARAM_COMPONENTROLETYPE role_params = { 0 };
+    OMX_PORT_PARAM_TYPE video_port_params = { 0 };
+    OMX_PARAM_PORTDEFINITIONTYPE in_port_params = { 0 }, out_port_params = { 0 };
+    OMX_VIDEO_PARAM_PORTFORMATTYPE formatIn = {0};
+
+    OMX_ERRORTYPE err;
+    int i;
+
+    s->version.s.nVersionMajor = 1;
+    s->version.s.nVersionMinor = 1;
+    s->version.s.nRevision     = 2;
+    s->input_count  = 0;
+    s->portSettingidle = 0;
+
+    s->crop_left = 0;
+    s->crop_top = 0;
+    s->status = INITIALIZING;
+#if 1
+    //set component_name OMX.hantro.VC8000D.video.decoder for test
+    av_log(avctx, AV_LOG_INFO, "OMX_GetHandle with component name %s \n", s->component_name);
+
+#endif
+    err = s->omx_context->ptr_GetHandle(&s->handle, s->component_name, s, (OMX_CALLBACKTYPE *) &decoder_callbacks);
+    if (err != OMX_ErrorNone) {
+        av_log(avctx, AV_LOG_ERROR, "OMX_GetHandle(%s) failed: %x\n", s->component_name, err);
+        return AVERROR_UNKNOWN;
+    }
+
+    // This one crashes the mediaserver on qcom, if used over IOMX
+    INIT_STRUCT(role_params);
+    av_strlcpy(role_params.cRole, role, sizeof(role_params.cRole));
+    // Intentionally ignore errors on this one
+    OMX_SetParameter(s->handle, OMX_IndexParamStandardComponentRole, &role_params);
+
+#if 1
+    if (s->fast_render) {
+        if (avctx->codec->id == AV_CODEC_ID_H264) {
+            OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE  codec_data;
+            OMX_INDEXTYPE index = OMX_IndexParamVideoFastUpdate;
+            av_log(avctx, AV_LOG_WARNING, "fast_render enabled");
+
+            INIT_STRUCT(codec_data);
+            codec_data.bEnableVFU = OMX_TRUE;
+            codec_data.nFirstGOB = 0;
+            codec_data.nFirstMB  = 0;
+            codec_data.nNumMBs   = 32;
+
+            err = OMX_SetConfig(s->handle, index, &codec_data);
+            if (err != OMX_ErrorNone) {
+                av_log(avctx, AV_LOG_WARNING, "OMX_IndexParamVideoFastUpdate not support yet");
+            }
+        }
+
+    }
+
+    if (s->mirror) {
+        OMX_CONFIG_MIRRORTYPE  mirrordata;
+        OMX_INDEXTYPE index = OMX_IndexConfigCommonMirror;
+        av_log(avctx, AV_LOG_WARNING, "mirror enabled %d", s->mirror);
+
+        INIT_STRUCT(mirrordata);
+        if (s->mirror == 1)
+            mirrordata.eMirror = OMX_MirrorVertical;
+        else
+            mirrordata.eMirror = OMX_MirrorHorizontal;
+
+        err = OMX_SetConfig(s->handle, index, &mirrordata);
+        if (err != OMX_ErrorNone) {
+            av_log(avctx, AV_LOG_WARNING, "OMX_IndexConfigCommonMirror not support yet");
+        }
+    }
+
+
+    if (s->rotation != 0) {
+
+        OMX_CONFIG_ROTATIONTYPE rot;
+        OMX_INDEXTYPE index = OMX_IndexConfigCommonRotate;
+        av_log(avctx, AV_LOG_WARNING, "rotation enabled %d", s->rotation);
+
+        INIT_STRUCT(rot);
+
+        err = OMX_SetConfig(s->handle, index, &rot);
+        if (err != OMX_ErrorNone) {
+            av_log(avctx, AV_LOG_WARNING, "OMX_IndexConfigCommonRotate not support yet");
+        }
+    }
+#endif
+
+    INIT_STRUCT(video_port_params);
+    err = OMX_GetParameter(s->handle, OMX_IndexParamVideoInit, &video_port_params);
+    CHECK(err);
+
+    s->in_port = s->out_port = -1;
+    s->format_changed = 0;
+    s->reconfigPending = 0;
+    s->outport_disabled = 0;
+    s->pkt_full = 0;
+    s->sent_pkt_num = 0;
+    s->temp_buffer = NULL;
+    s->now_pts = 0;
+    s->resolution_changed = 0;
+    if (avctx->framerate.num) {
+        s->pkt_duration = abs(avctx->pkt_timebase.den / avctx->framerate.num);
+    } else {
+        s->pkt_duration = 0;
+    }
+    if (s->output_width)
+        avctx->width = s->output_width;
+    if (s->output_height)
+        avctx->height = s->output_height;
+
+    INIT_STRUCT(in_port_params);
+    in_port_params.nPortIndex =  s->in_port = OMX_DirInput;
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &in_port_params);
+    CHECK(err);
+
+    INIT_STRUCT(out_port_params);
+    out_port_params.nPortIndex = s->out_port = OMX_DirOutput;
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+    CHECK(err);
+
+    in_port_params.format.video.nFrameWidth  = (OMX_U32) avctx->width;
+    in_port_params.format.video.nFrameHeight = (OMX_U32) avctx->height;
+    in_port_params.format.video.nStride      = (OMX_U32) avctx->width;
+    in_port_params.format.video.nSliceHeight = (OMX_U32) avctx->height;
+    in_port_params.nBufferCountActual    = kNumPictureBuffers;
+    in_port_params.nBufferCountMin       = kNumPictureBuffers;
+
+
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &in_port_params);
+    CHECK(err);
+
+    out_port_params.format.video.nFrameWidth   = avctx->width;
+    out_port_params.format.video.nFrameHeight  = avctx->height;
+    out_port_params.format.video.nStride      = (OMX_U32) avctx->width;
+    out_port_params.format.video.nSliceHeight = (OMX_U32) avctx->height;
+    out_port_params.nBufferCountActual   = kNumPictureBuffers;
+    out_port_params.nBufferCountMin      = kNumPictureBuffers;
+    out_port_params.nBufferSize = (OMX_U32) avctx->width * (OMX_U32) avctx->height * 3;
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+    CHECK(err);
+
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &in_port_params);
+    CHECK(err);
+
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+    CHECK(err);
+
+    s->stride         = in_port_params.format.video.nStride;
+    s->plane_size     = in_port_params.format.video.nSliceHeight;
+    s->num_in_buffers = in_port_params.nBufferCountMin;
+    s->in_buffer_size = in_port_params.nBufferSize;
+    s->num_out_buffers = out_port_params.nBufferCountMin + 5;
+    s->out_stride       = out_port_params.format.video.nStride;
+    s->out_slice_height = out_port_params.format.video.nSliceHeight;
+
+    in_port_params.nBufferCountActual = in_port_params.nBufferCountMin;
+    out_port_params.nBufferCountActual = out_port_params.nBufferCountMin + 5;
+
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &in_port_params);
+    CHECK(err);
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &out_port_params);
+    CHECK(err);
+
+    dump_portdef(s, &in_port_params);
+    dump_portdef(s, &out_port_params);
+
+    INIT_STRUCT(formatIn);
+    formatIn.nPortIndex = s->in_port;
+    err = OMX_GetParameter(s->handle, OMX_IndexParamVideoPortFormat, &formatIn);
+
+    switch (avctx->codec->id) {
+    case AV_CODEC_ID_MPEG4:
+        formatIn.eCompressionFormat = OMX_VIDEO_CodingMPEG4;
+        break;
+    case AV_CODEC_ID_H264:
+        formatIn.eCompressionFormat = OMX_VIDEO_CodingAVC;
+        break;
+    case AV_CODEC_ID_RV10:
+    case AV_CODEC_ID_RV20:
+    case AV_CODEC_ID_RV30:
+        formatIn.eCompressionFormat = OMX_VIDEO_CodingAVC;
+        break;
+
+    case AV_CODEC_ID_HEVC:
+        formatIn.eCompressionFormat = OMX_VIDEO_CodingHEVC;
+        break;
+    case AV_CODEC_ID_VP9:
+        formatIn.eCompressionFormat = OMX_VIDEO_CodingVP9;
+        break;
+    default:
+        formatIn.eCompressionFormat = OMX_VIDEO_CodingAutoDetect;
+        break;
+
+    }
+
+    formatIn.eColorFormat = OMX_COLOR_FormatUnused;
+    formatIn.xFramerate = (OMX_U32)av_q2d(avctx->framerate);
+    err = OMX_SetParameter(s->handle, OMX_IndexParamVideoPortFormat, &formatIn);
+
+    if (OMX_ErrorNone != OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL)) {
+        av_log(avctx, AV_LOG_ERROR, "Unable to set IDLE state\n");
+    }
+
+    //allocate input buffers
+    s->in_buffer_headers  = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_in_buffers);
+    s->free_in_buffers    = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_in_buffers);
+    if (!s->in_buffer_headers || !s->free_in_buffers)
+        return AVERROR(ENOMEM);
+
+    for (i = 0; i < s->num_in_buffers && err == OMX_ErrorNone; i++) {
+        err = OMX_AllocateBuffer(s->handle, &s->in_buffer_headers[i],  s->in_port,  s, in_port_params.nBufferSize);
+        if (err == OMX_ErrorNone) {
+            s->in_buffer_headers[i]->nInputPortIndex = s->in_port;
+            s->in_buffer_headers[i]->nOffset = 0;
+            s->in_buffer_headers[i]->nFlags  = 0;
+        } else {
+            av_log(avctx, AV_LOG_ERROR, "OMX_AllocateBuffer for input[%d] failed\n", i);
+        }
+    }
+
+    CHECK(err);
+    s->num_in_buffers = i;
+    for (i = 0; i < s->num_in_buffers; i++) {
+        s->free_in_buffers[i] = s->in_buffer_headers[i];
+    }
+    s->num_free_in_buffers =  s->num_in_buffers;
+    av_log(avctx, AV_LOG_INFO, "OMX_AllocateBuffer for inputs %d finished\n", s->num_free_in_buffers);
+
+    //allocate output buffers
+    s->out_buffer_headers = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+    s->done_out_buffers   = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+    if (!s->out_buffer_headers || !s->done_out_buffers)
+        return AVERROR(ENOMEM);
+    for (i = 0; i < s->num_out_buffers && err == OMX_ErrorNone; i++) {
+        err = OMX_AllocateBuffer(s->handle, &s->out_buffer_headers[i], s->out_port, s, out_port_params.nBufferSize);
+        s->out_buffer_headers[i]->pAppPrivate = s->out_buffer_headers[i]->pOutputPortPrivate = NULL;
+        s->out_buffer_headers[i]->pAppPrivate = NULL;
+        s->out_buffer_headers[i]->nTimeStamp = -1;
+        s->out_buffer_headers[i]->nOutputPortIndex =  s->out_port;
+        CHECK(err);
+    }
+
+    s->num_out_buffers = i;
+
+#if 0
+    //check if port enabled
+    if (in_port_params.bEnabled == OMX_FALSE) {
+        OMX_SendCommand(s->handle, OMX_CommandPortEnable, OMX_DirInput, NULL);
+    }
+
+    if (out_port_params.bEnabled == OMX_FALSE) {
+        OMX_SendCommand(s->handle, OMX_CommandPortEnable, OMX_DirOutput, NULL);
+    }
+#endif
+
+    if (wait_for_state(s, OMX_StateIdle) < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Didn't get OMX_StateIdle\n");
+        return AVERROR_UNKNOWN;
+    }
+
+    err = OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateExecuting, NULL);
+    CHECK(err);
+    if (wait_for_state(s, OMX_StateExecuting) < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Didn't get OMX_StateExecuting\n");
+        return AVERROR_UNKNOWN;
+    }
+
+
+    for (i = 0; i < s->num_out_buffers && err == OMX_ErrorNone; i++) {
+        err = OMX_FillThisBuffer(s->handle, s->out_buffer_headers[i]);
+    }
+
+    if (err != OMX_ErrorNone) {
+        av_log(avctx, AV_LOG_WARNING, "FillOutBuffer failed , so set header\n");
+        for (; i < s->num_out_buffers; i++) {
+            s->done_out_buffers[s->num_done_out_buffers++] = s->out_buffer_headers[i];
+        }
+    }
+#ifdef MPEG4_OMX
+    omx_send_extradata(avctx);
+#endif
+    return err != OMX_ErrorNone ? AVERROR_UNKNOWN : 0;
+}
+
+static av_cold void omx_cleanup(OMXCodecDecoderContext *s)
+{
+    int executing;
+    av_log(s->avctx, AV_LOG_WARNING, "OMX Cleanup\n");
+    /* If the mutexes/condition variables have not been properly initialized,
+     * nothing has been initialized and locking the mutex might be unsafe. */
+    if (s->mutex_cond_inited_cnt == NB_MUTEX_CONDS) {
+        pthread_mutex_lock(&s->state_mutex);
+        executing = s->state == OMX_StateExecuting;
+        pthread_mutex_unlock(&s->state_mutex);
+
+        if (executing) {
+            OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
+            wait_for_state(s, OMX_StateIdle);
+            OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateLoaded, NULL);
+
+            for (int i = 0; i < s->num_in_buffers; i++) {
+                OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                                               &s->num_free_in_buffers, &s->free_in_buffers, -1);
+                OMX_FreeBuffer(s->handle, s->in_port, buffer);
+            }
+
+            for (int i = 0; i < s->num_out_buffers; i++) {
+                OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                                               &s->num_done_out_buffers, &s->done_out_buffers, -1);
+                OMX_FreeBuffer(s->handle, s->out_port, buffer);
+            }
+
+            pthread_mutex_lock(&s->output_mutex);
+            s->num_out_buffers = 0;
+            s->num_done_out_buffers = 0;
+            pthread_mutex_unlock(&s->output_mutex);
+
+            wait_for_state(s, OMX_StateLoaded);
+        }
+
+        if (s->handle) {
+            s->omx_context->ptr_FreeHandle(s->handle);
+            s->handle = NULL;
+        }
+
+        //omx_deinit
+        omx_deinit(s->omx_context);
+        s->omx_context = NULL;
+        av_freep(&s->in_buffer_headers);
+        av_freep(&s->out_buffer_headers);
+        av_freep(&s->free_in_buffers);
+        av_freep(&s->done_out_buffers);
+
+    }
+    if (s->mutex_cond_inited_cnt) {
+        pthread_cond_destroy(&s->state_cond);
+        pthread_mutex_destroy(&s->state_mutex);
+        pthread_cond_destroy(&s->input_cond);
+        pthread_mutex_destroy(&s->input_mutex);
+        pthread_cond_destroy(&s->output_cond);
+        pthread_mutex_destroy(&s->output_mutex);
+        pthread_cond_destroy(&s->eof_cond);
+        pthread_mutex_destroy(&s->eof_mutex);
+        s->mutex_cond_inited_cnt = 0;
+    }
+}
+
+static av_cold int omx_decode_init(AVCodecContext *avctx)
+{
+
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    int ret = AVERROR_DECODER_NOT_FOUND;
+    const char *role;
+    av_log(avctx, AV_LOG_INFO, "omx_decode_init enter\n");
+    /* cleanup relies on the mutexes/conditions being initialized first. */
+    s->omx_context = omx_init(avctx, s->libname, s->libprefix);
+    if (!s->omx_context)
+        return AVERROR_DECODER_NOT_FOUND;
+
+    pthread_mutex_init(&s->state_mutex, NULL);
+    pthread_cond_init(&s->state_cond, NULL);
+    pthread_mutex_init(&s->input_mutex, NULL);
+    pthread_cond_init(&s->input_cond, NULL);
+    pthread_mutex_init(&s->output_mutex, NULL);
+    pthread_cond_init(&s->output_cond, NULL);
+    pthread_mutex_init(&s->eof_mutex, NULL);
+    pthread_cond_init(&s->eof_cond, NULL);
+    s->mutex_cond_inited_cnt = 1;
+    s->avctx = avctx;
+    s->state = OMX_StateLoaded;
+    s->error = OMX_ErrorNone;
+    s->first_pkt = 1;
+
+    switch (avctx->codec->id) {
+    case AV_CODEC_ID_MPEG4:
+        role = "video_decoder.mpeg4";
+        break;
+    case AV_CODEC_ID_H263:
+        role = "video_decoder.h263";
+        break;
+    case AV_CODEC_ID_H264:
+        role = "video_decoder.avc";
+        break;
+    case AV_CODEC_ID_HEVC:
+        role = "video_decoder.hevc";
+        break;
+    case AV_CODEC_ID_WMV1:
+    case AV_CODEC_ID_WMV2:
+    case AV_CODEC_ID_WMV3:
+        role = "video_decoder.wmv";
+        break;
+    case AV_CODEC_ID_VP6:
+        role = "video_decoder.vp6";
+        break;
+    case AV_CODEC_ID_VP8:
+        role = "video_decoder.vp8";
+        break;
+    case AV_CODEC_ID_VP9:
+        role = "video_decoder.vp9";
+        break;
+    default:
+        return AVERROR(ENOSYS);
+    }
+
+    ret = omx_dec_find_component(s->omx_context, avctx, role, s->component_name, sizeof(s->component_name));
+    if (ret < 0) {
+        return ret;
+    }
+
+    av_log(avctx, AV_LOG_INFO, "Using %s\n", s->component_name);
+    ret =  omx_component_init_decoder(avctx, role);
+    if (ret < 0) {
+        return ret;
+    }
+
+    av_log(avctx, AV_LOG_INFO, "%p, omx_decode_init:num_done_out_buffers %d, num_free_in_buffers %d\n", s,
+           s->num_out_buffers, s->num_free_in_buffers);
+    return 0;
+}
+
+static int ff_omx_dec_send(AVCodecContext *avctx, OMXCodecDecoderContext *s,
+                           AVPacket *pkt, bool wait)
+{
+    OMX_BUFFERHEADERTYPE *buffer;
+    OMX_ERRORTYPE err;
+    int need_draining = 0;
+    int64_t timeout = 0;
+
+    if (wait) {
+        timeout = 80;
+    }
+
+    if (pkt->size == 0) {
+        need_draining = 1;
+    }
+
+    if (s->draining && s->got_eos) {
+        av_log(avctx, AV_LOG_INFO, "got eof:%d\n", s->got_eos);
+        return AVERROR_EOF;
+    }
+
+    if (s->reconfigPending) {
+        //    av_usleep(1000);
+        return AVERROR_EOF;
+    }
+
+    if (pkt->data) {
+        buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                            &s->num_free_in_buffers, &s->free_in_buffers, timeout);
+
+        if (buffer == NULL) {
+            return AVERROR(EAGAIN);
+        }
+
+        buffer->nFilledLen = pkt->size;
+        buffer->nAllocLen = buffer->nFilledLen;
+        buffer->nFlags = 0;
+
+        if (pkt->flags & AV_PKT_FLAG_KEY) {
+            buffer->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;
+        }
+        if (pkt->flags & AV_PKT_FLAG_DISCARD) {
+            av_log(avctx, AV_LOG_ERROR, "AV_PKT_FLAG_DISCARD\n");
+        } else if (pkt->flags & AV_PKT_FLAG_CORRUPT) {
+            av_log(avctx, AV_LOG_ERROR, "AV_PKT_FLAG_CORRUPT\n");
+        } else {
+            buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
+        }
+
+        buffer->nOffset = 0;
+        buffer->nTimeStamp = to_omx_ticks(av_rescale_q(pkt->pts, avctx->time_base, AV_TIME_BASE_Q));
+        memcpy(buffer->pBuffer, pkt->data, pkt->size);
+        err = OMX_EmptyThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_EmptyThisBuffer failed: %x\n", err);
+            return AVERROR_UNKNOWN;
+        }
+        s->input_count++;
+    } else if (!s->eos_sent) {
+        //flush, end of stream
+        //ff_omx_dec_send reach eos
+        buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                            &s->num_free_in_buffers, &s->free_in_buffers, timeout);
+
+        buffer->nFilledLen = 0;
+        buffer->nFlags = OMX_BUFFERFLAG_EOS;
+        buffer->pAppPrivate = buffer->pOutputPortPrivate = NULL;
+        err = OMX_EmptyThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_EmptyThisBuffer failed: %x\n", err);
+            return AVERROR_UNKNOWN;
+        }
+        s->eos_sent = 1;
+    }
+    return 0;
+}
+
+static int ff_omx_dec_is_flushing(AVCodecContext *avctx, OMXCodecDecoderContext *s)
+{
+    return s->flushing;
+}
+
+static int ff_omx_dec_flush(AVCodecContext *avctx, OMXCodecDecoderContext *s)
+{
+    OMX_ERRORTYPE err;
+    OMX_BUFFERHEADERTYPE *buffer;
+    int i = 0;
+
+    s->draining = 0;
+    s->got_eos = 0;
+    if (!s->flushing) {
+        av_log(avctx, AV_LOG_INFO, "ff_omx_dec_flush\n");
+        err = OMX_SendCommand(s->handle, OMX_CommandFlush, s->in_port, NULL);
+        if (err != OMX_ErrorNone)
+            return -1;
+
+        err = OMX_SendCommand(s->handle, OMX_CommandFlush, s->out_port, NULL);
+        if (err != OMX_ErrorNone)
+            return -1;
+
+        while (s->num_done_out_buffers > 0) {
+            buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                                &s->num_done_out_buffers, &s->done_out_buffers,
+                                -1);
+            if (!buffer) {
+                //omx_outputbuffer_thread  error
+                return AVERROR(EAGAIN);
+            }
+            err = OMX_FillThisBuffer(s->handle, buffer);
+            if (err != OMX_ErrorNone) {
+                append_buffer(&s->output_mutex, &s->output_cond, &s->num_done_out_buffers, s->done_out_buffers, buffer);
+                av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+            }
+        }
+        s->flushing = 1;
+    }
+    return 0;
+}
+
+static int omx_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    int ret;
+    int out_value = 0;
+    /* feed decoder */
+    while (1) {
+        ret = omx_try_filltempbuffer(avctx);
+        if (s->num_done_out_buffers > 0) {
+            ret = ff_omx_dec_receive(avctx, s, frame, false);
+            if (ret != AVERROR(EAGAIN)) {
+                //receive success!
+                s->sent_pkt_num--;
+                return ret;
+            }
+        } else if (s->num_done_out_buffers == 0 && s->got_eos && s->eos_sent) {
+            return AVERROR_EOF;
+        }
+
+        /* try to flush any buffered packet data */
+        if (s->buffered_pkt.size > 0 && !s->outport_disabled) {
+            ret = ff_omx_dec_send(avctx, s, &s->buffered_pkt, true);
+            if (ret >= 0) {
+                //ff_omx_dec_send success
+                s->sent_pkt_num++;
+                s->pkt_full = 0;
+                av_packet_unref(&s->buffered_pkt);
+                s->flushing = 0;
+            } else if (ret < 0 && ret != AVERROR(EAGAIN)) {
+                return ret;
+            }
+            /* poll for space again */
+            continue;
+        }
+
+        /* fetch new packet or eof */
+        if (s->pkt_full == 0) {
+            ret = ff_decode_get_packet(avctx, &s->buffered_pkt);
+            if (ret == AVERROR_EOF) {
+                AVPacket null_pkt = { 0 };
+                ret = ff_omx_dec_send(avctx, s, &null_pkt, true);
+                if (ret < 0) {
+                    s->need_sendeos = 1;
+                    return ret;
+                }
+
+                s->need_sendeos = 0;
+                s->eos_reach = 1;
+                continue;
+
+            } else if (ret < 0) {
+                return ret;
+            } else {
+                //success
+                s->pkt_full = 1;
+            }
+        }
+    }
+    return AVERROR(EAGAIN);
+}
+
+
+static void omx_decode_flush(AVCodecContext *avctx)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    if (s->buffered_pkt.size > 0) {
+        av_packet_unref(&s->buffered_pkt);
+        s->buffered_pkt.size = 0;
+    }
+    ff_omx_dec_flush(avctx, s);
+}
+
+static av_cold int omx_decode_end(AVCodecContext *avctx)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+
+    omx_cleanup(s);
+    return 0;
+}
+
+#define OFFSET(x) offsetof(OMXCodecDecoderContext, x)
+#define VDE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+#define VE  AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+#define VD  AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM
+
+
+static const AVCodecHWConfigInternal *const omx_hw_configs[] = {
+    &(const AVCodecHWConfigInternal)
+    {
+        .public          = {
+            .pix_fmt     = AV_PIX_FMT_NV12,
+            .methods     = AV_CODEC_HW_CONFIG_METHOD_AD_HOC |
+            AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX,
+            .device_type = AV_HWDEVICE_TYPE_OMX,
+        },
+        .hwaccel         = NULL,
+    },
+    NULL
+};
+
+
+static const AVOption ff_omxcodec_vdec_options[] = {
+    {
+        "delay_flush", "Delay flush until hw output buffers are returned to the decoder(not support)",
+        OFFSET(delay_flush), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, VD
+    },
+    { "fast_render", "Fast render(not support)",  OFFSET(fast_render), AV_OPT_TYPE_BOOL,   {.i64 = 0}, 0, 1, VD},
+    { "mirror", "mirror image(not support)",      OFFSET(mirror), AV_OPT_TYPE_INT,         {.i64 = 0}, 0, 2, VD},
+    { "rotation", "rotation angle(not support)",  OFFSET(rotation), AV_OPT_TYPE_INT,       {.i64 = 0}, 0, 3, VD},
+    { "output_width", "output width(must smaller than the original width)",  OFFSET(output_width), AV_OPT_TYPE_INT,       {.i64 = 0}, 0, OMX_VIDEO_HEVCLevelMax, VD},
+    { "output_height", "output height(must smaller than the original height)",  OFFSET(output_height), AV_OPT_TYPE_INT,       {.i64 = 0}, 0, OMX_VIDEO_HEVCLevelMax, VD},
+    { "offscreen", "off screen mode",  OFFSET(offscreen), AV_OPT_TYPE_INT,       {.i64 = 0}, 0, 1, VD},
+    { NULL }
+};
+
+
+
+#define DECLARE_OMX_VCLASS(short_name)                          \
+static const AVClass ff_##short_name##_omxcodec_dec_class = {   \
+    .class_name = #short_name "_libomx",                        \
+    .item_name  = av_default_item_name,                         \
+    .option     = ff_omxcodec_vdec_options,                     \
+    .version    = LIBAVUTIL_VERSION_INT,                        \
+};
+
+#ifdef FORMAT_NV12
+#define DECLARE_OMX_VDEC(short_name, full_name, codec_id, bsf)                                 \
+DECLARE_OMX_VCLASS(short_name)                                                                 \
+const AVCodec ff_ ## short_name ## _omx_decoder = {                                            \
+    .name           = #short_name "_omx",                                                      \
+    .long_name      = NULL_IF_CONFIG_SMALL("OpenMAX IL decoder"),                                \
+    .type           = AVMEDIA_TYPE_VIDEO,                                                        \
+    .id             = codec_id,                                                                  \
+    .priv_class     = &ff_##short_name##_omxcodec_dec_class,                                     \
+    .priv_data_size = sizeof(OMXCodecDecoderContext),                                          \
+    .init           = omx_decode_init,                                                         \
+    .receive_frame  = omx_receive_frame,                                                       \
+    .close          = omx_decode_end,                                                          \
+    .flush          = omx_decode_flush,                                                        \
+    .capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING ,                          \
+    .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS ,                                              \
+    .bsfs           = bsf,                                                                     \
+    .hw_configs    = (const AVCodecHWConfigInternal *const []) { NULL },                       \
+    .wrapper_name = "omxcodec",                                                                \
+    .pix_fmts       = (const enum AVPixelFormat[]) {                                           \
+                                 AV_PIX_FMT_NV12,                                              \
+                                 AV_PIX_FMT_NONE },                                            \
+};
+
+#else
+#define DECLARE_OMX_VDEC(short_name, full_name, codec_id, bsf)                                 \
+DECLARE_OMX_VCLASS(short_name)                                                                 \
+const AVCodec ff_ ## short_name ## _omx_decoder = {                                            \
+    .name           = #short_name "_omx",                                                      \
+    .long_name      = NULL_IF_CONFIG_SMALL("OpenMAX IL decoder"),                                \
+    .type           = AVMEDIA_TYPE_VIDEO,                                                        \
+    .id             = codec_id,                                                                  \
+    .priv_class     = &ff_##short_name##_omxcodec_dec_class,                                     \
+    .priv_data_size = sizeof(OMXCodecDecoderContext),                                          \
+    .init           = omx_decode_init,                                                         \
+    .receive_frame  = omx_receive_frame,                                                       \
+    .close          = omx_decode_end,                                                          \
+    .flush          = omx_decode_flush,                                                        \
+    .capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING ,                          \
+    .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS ,                                              \
+    .bsfs           = bsf,                                                                     \
+    .hw_configs    = (const AVCodecHWConfigInternal *const []) { NULL },                       \
+};
+
+#endif
+
+
+
+DECLARE_OMX_VDEC(h264, "H.264", AV_CODEC_ID_H264, "h264_mp4toannexb")
+DECLARE_OMX_VDEC(hevc, "H.265", AV_CODEC_ID_HEVC, "hevc_mp4toannexb")
+DECLARE_OMX_VDEC(vp9, "VP9", AV_CODEC_ID_VP9, NULL)
+
+#ifdef MPEG4_OMX
+DECLARE_OMX_VDEC(mpeg4, "MPEG4", AV_CODEC_ID_MPEG4, NULL)
+#endif
diff --git a/libavcodec/omxjpegdecoder.c b/libavcodec/omxjpegdecoder.c
new file mode 100755
index 0000000..37bbef8
--- /dev/null
+++ b/libavcodec/omxjpegdecoder.c
@@ -0,0 +1,1099 @@
+/*decoders
+*
+* Copyright (c) 2023-2024 Huazhu Sun <sunhuazhu@coocaa.com>
+* Copyright (c) 2023-2024 Kaiyuan Dong <dongkaiyuan.dky@alibaba-inc.com>
+*
+* This file is part of FFmpeg.
+*
+* FFmpeg is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* FFmpeg is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with FFmpeg; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <time.h>
+#include <stdint.h>
+#include <stdatomic.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <sys/ipc.h>
+#include <sys/msg.h>
+#include <dlfcn.h>
+#include <string.h>
+#include <stdarg.h>
+#include <pthread.h>
+
+#include "libavutil/avstring.h"
+#include "libavutil/avutil.h"
+#include "libavutil/common.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/log.h"
+#include "libavutil/opt.h"
+#include "libavutil/avassert.h"
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/pixfmt.h"
+#include "libavutil/internal.h"
+#include <libavutil/pixdesc.h>
+#include "libavutil/time.h"
+#include <libavutil/thread.h>
+#include <libavcodec/pthread_internal.h>
+
+#include <OMX_Core.h>
+#include <OMX_Component.h>
+
+#include "avcodec.h"
+#include "decode.h"
+#include "h264_parse.h"
+#include "h264_ps.h"
+#include "hevc_parse.h"
+#include "hwconfig.h"
+#include "internal.h"
+static int omx_load_count = 0;
+#define DEBUG_NO_OMX
+
+#define TIMEOUT_MS 1000
+
+#define kNumPictureBuffers 2
+#define INIT_STRUCT(x) do {                                               \
+        x.nSize = sizeof(x);                                              \
+        x.nVersion = s->version;                                          \
+    } while (0)
+#define CHECK(x) do {                                                     \
+        if (x != OMX_ErrorNone) {                                         \
+            av_log(s->avctx, AV_LOG_ERROR,                                \
+                   "err %x (%d) on line %d\n", x, x, __LINE__);           \
+            return -1;                                       \
+        }                                                                 \
+    } while (0)
+
+typedef struct OMXContext {
+    void *lib;
+    void *lib2;
+    OMX_ERRORTYPE(*ptr_Init)(void);
+    OMX_ERRORTYPE(*ptr_Deinit)(void);
+    OMX_ERRORTYPE(*ptr_ComponentNameEnum)(OMX_STRING, OMX_U32, OMX_U32);
+    OMX_ERRORTYPE(*ptr_GetHandle)(OMX_HANDLETYPE *, OMX_STRING, OMX_PTR, OMX_CALLBACKTYPE *);
+    OMX_ERRORTYPE(*ptr_FreeHandle)(OMX_HANDLETYPE);
+    OMX_ERRORTYPE(*ptr_GetComponentsOfRole)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    OMX_ERRORTYPE(*ptr_GetRolesOfComponent)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    void (*host_init)(void);
+} OMXContext;
+
+
+typedef struct OMXCodecDecoderContext {
+    char *libname;
+    char *libprefix;
+    OMXContext *omx_context;
+    AVCodecContext *avctx;
+    char component_name[OMX_MAX_STRINGNAME_SIZE];
+    OMX_VERSIONTYPE version;
+    OMX_HANDLETYPE handle;
+    int in_port, out_port;
+    int width, height;
+    int stride, plane_size;
+    int filelen;
+    int num_in_buffers, num_out_buffers;
+    int in_buffer_size, out_buffer_size;
+    OMX_BUFFERHEADERTYPE **in_buffer_headers;
+    OMX_BUFFERHEADERTYPE **out_buffer_headers;
+
+    int num_free_in_buffers;
+    OMX_BUFFERHEADERTYPE **free_in_buffers;
+    int num_done_out_buffers;
+    OMX_BUFFERHEADERTYPE **done_out_buffers;
+
+    int in_fill_index;
+    int out_fill_index;
+    pthread_mutex_t input_mutex;
+    pthread_cond_t input_cond;
+
+    pthread_mutex_t output_mutex;
+    pthread_cond_t output_cond;
+
+    pthread_mutex_t state_mutex;
+    pthread_cond_t state_cond;
+    OMX_EVENTTYPE event;
+    OMX_COMMANDTYPE cmd;
+    OMX_STATETYPE state;
+
+    OMX_ERRORTYPE error;
+    int profile;
+
+    int crop_top, crop_left;
+    int portSettingChanged;
+    void *decoderBuffer;
+
+
+} OMXCodecDecoderContext;
+
+
+static void say(OMXCodecDecoderContext *s, const char *message, ...)
+{
+    va_list args;
+    size_t str_len;
+    char str[1024];
+    memset(str, 0, sizeof(str));
+    va_start(args, message);
+    vsnprintf(str, sizeof(str) - 1, message, args);
+    va_end(args);
+    str_len = strlen(str);
+    if (str[str_len - 1] != '\n') {
+        str[str_len] = '\n';
+    }
+
+    av_log(s->avctx, AV_LOG_INFO, "%s", str);
+}
+
+
+static const char *dump_compression_format(OMXCodecDecoderContext *s, OMX_VIDEO_CODINGTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_VIDEO_CodingUnused:
+        return "not used";
+    case OMX_VIDEO_CodingAutoDetect:
+        return "autodetect";
+    case OMX_VIDEO_CodingMPEG2:
+        return "MPEG2";
+    case OMX_VIDEO_CodingH263:
+        return "H.263";
+    case OMX_VIDEO_CodingMPEG4:
+        return "MPEG4";
+    case OMX_VIDEO_CodingWMV:
+        return "Windows Media Video";
+    case OMX_VIDEO_CodingRV:
+        return "RealVideo";
+    case OMX_VIDEO_CodingAVC:
+        return "H.264/AVC";
+    case OMX_VIDEO_CodingMJPEG:
+        return "Motion JPEG";
+//        case OMX_VIDEO_CodingTheora:     return "OGG Theora";
+
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f, "format type 0x%08x", c);
+        return f;//maybe memleak
+    }
+}
+
+static const char *dump_color_format(OMXCodecDecoderContext *s, OMX_COLOR_FORMATTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_COLOR_FormatUnused:
+        return "OMX_COLOR_FormatUnused: not used";
+    case OMX_COLOR_FormatMonochrome:
+        return "OMX_COLOR_FormatMonochrome";
+    case OMX_COLOR_Format8bitRGB332:
+        return "OMX_COLOR_Format8bitRGB332";
+    case OMX_COLOR_Format12bitRGB444:
+        return "OMX_COLOR_Format12bitRGB444";
+    case OMX_COLOR_Format16bitARGB4444:
+        return "OMX_COLOR_Format16bitARGB4444";
+    case OMX_COLOR_Format16bitARGB1555:
+        return "OMX_COLOR_Format16bitARGB1555";
+    case OMX_COLOR_Format16bitRGB565:
+        return "OMX_COLOR_Format16bitRGB565";
+    case OMX_COLOR_Format16bitBGR565:
+        return "OMX_COLOR_Format16bitBGR565";
+    case OMX_COLOR_Format18bitRGB666:
+        return "OMX_COLOR_Format18bitRGB666";
+    case OMX_COLOR_Format18bitARGB1665:
+        return "OMX_COLOR_Format18bitARGB1665";
+    case OMX_COLOR_Format19bitARGB1666:
+        return "OMX_COLOR_Format19bitARGB1666";
+    case OMX_COLOR_Format24bitRGB888:
+        return "OMX_COLOR_Format24bitRGB888";
+    case OMX_COLOR_Format24bitBGR888:
+        return "OMX_COLOR_Format24bitBGR888";
+    case OMX_COLOR_Format24bitARGB1887:
+        return "OMX_COLOR_Format24bitARGB1887";
+    case OMX_COLOR_Format25bitARGB1888:
+        return "OMX_COLOR_Format25bitARGB1888";
+    case OMX_COLOR_Format32bitBGRA8888:
+        return "OMX_COLOR_Format32bitBGRA8888";
+    case OMX_COLOR_Format32bitARGB8888:
+        return "OMX_COLOR_Format32bitARGB8888";
+    case OMX_COLOR_FormatYUV411Planar:
+        return "OMX_COLOR_FormatYUV411Planar";
+    case OMX_COLOR_FormatYUV411PackedPlanar:
+        return "OMX_COLOR_FormatYUV411PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420Planar:
+        return "OMX_COLOR_FormatYUV420Planar: Planar YUV, 4:2:0 (I420)";
+    case OMX_COLOR_FormatYUV420PackedPlanar:
+        return "OMX_COLOR_FormatYUV420PackedPlanar: Planar YUV, 4:2:0 (I420), planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420SemiPlanar:
+        return "OMX_COLOR_FormatYUV420SemiPlanar, Planar YUV, 4:2:0 (NV12), U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422Planar:
+        return "OMX_COLOR_FormatYUV422Planar";
+    case OMX_COLOR_FormatYUV422PackedPlanar:
+        return "OMX_COLOR_FormatYUV422PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV422SemiPlanar:
+        return "OMX_COLOR_FormatYUV422SemiPlanar";
+    case OMX_COLOR_FormatYCbYCr:
+        return "OMX_COLOR_FormatYCbYCr";
+    case OMX_COLOR_FormatYCrYCb:
+        return "OMX_COLOR_FormatYCrYCb";
+    case OMX_COLOR_FormatCbYCrY:
+        return "OMX_COLOR_FormatCbYCrY";
+    case OMX_COLOR_FormatCrYCbY:
+        return "OMX_COLOR_FormatCrYCbY";
+    case OMX_COLOR_FormatYUV444Interleaved:
+        return "OMX_COLOR_FormatYUV444Interleaved";
+    case OMX_COLOR_FormatRawBayer8bit:
+        return "OMX_COLOR_FormatRawBayer8bit";
+    case OMX_COLOR_FormatRawBayer10bit:
+        return "OMX_COLOR_FormatRawBayer10bit";
+    case OMX_COLOR_FormatRawBayer8bitcompressed:
+        return "OMX_COLOR_FormatRawBayer8bitcompressed";
+    case OMX_COLOR_FormatL2:
+        return "OMX_COLOR_FormatL2";
+    case OMX_COLOR_FormatL4:
+        return "OMX_COLOR_FormatL4";
+    case OMX_COLOR_FormatL8:
+        return "OMX_COLOR_FormatL8";
+    case OMX_COLOR_FormatL16:
+        return "OMX_COLOR_FormatL16";
+    case OMX_COLOR_FormatL24:
+        return "OMX_COLOR_FormatL24";
+    case OMX_COLOR_FormatL32:
+        return "OMX_COLOR_FormatL32";
+    case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV420PackedSemiPlanar: Planar YUV, 4:2:0 (NV12), planes fragmented when a frame is split in multiple buffers, U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV422PackedSemiPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_Format18BitBGR666:
+        return "OMX_COLOR_Format18BitBGR666";
+    case OMX_COLOR_Format24BitARGB6666:
+        return "OMX_COLOR_Format24BitARGB6666";
+    case OMX_COLOR_Format24BitABGR6666:
+        return "OMX_COLOR_Format24BitABGR6666";
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f,  "format type 0x%08x", c);
+        return f;
+    }
+}
+
+static void dump_portdef(OMXCodecDecoderContext *s, OMX_PARAM_PORTDEFINITIONTYPE *portdef)
+{
+    OMX_VIDEO_PORTDEFINITIONTYPE *viddef = &portdef->format.video;
+    OMX_IMAGE_PORTDEFINITIONTYPE *imgdef = &portdef->format.image;
+
+    say(s, "Port %d is %s, %s, buffers wants:%d needs:%d, size:%d, pop:%d, aligned:%d",
+        portdef->nPortIndex,
+        (portdef->eDir ==  OMX_DirInput ? "input" : "output"),
+        (portdef->bEnabled == OMX_TRUE ? "enabled" : "disabled"),
+        portdef->nBufferCountActual,
+        portdef->nBufferCountMin,
+        portdef->nBufferSize,
+        portdef->bPopulated,
+        portdef->nBufferAlignment);
+
+
+    switch (portdef->eDomain) {
+    case OMX_PortDomainVideo:
+        say(s, "Video type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tBitrate:\t%d\n"
+            "\tFramerate:\t%.02f\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            viddef->nFrameWidth,
+            viddef->nFrameHeight,
+            viddef->nStride,
+            viddef->nSliceHeight,
+            viddef->nBitrate,
+            ((float)viddef->xFramerate / (float)65536),
+            (viddef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, viddef->eCompressionFormat),
+            dump_color_format(s, viddef->eColorFormat));
+        break;
+    case OMX_PortDomainImage:
+        say(s, "Image type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            imgdef->nFrameWidth,
+            imgdef->nFrameHeight,
+            imgdef->nStride,
+            imgdef->nSliceHeight,
+            (imgdef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, imgdef->eCompressionFormat),
+            dump_color_format(s, imgdef->eColorFormat));
+        break;
+    default:
+        break;
+    }
+}
+
+static OMX_ERRORTYPE empty_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                       OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecDecoderContext *s = app_data;
+    pthread_mutex_lock(&s->input_mutex);
+    s->num_free_in_buffers++;
+    pthread_mutex_unlock(&s->input_mutex);
+    return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE fill_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                      OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMX_ERRORTYPE err;
+    OMXCodecDecoderContext *s = app_data;
+    pthread_mutex_lock(&s->output_mutex);
+    s->num_done_out_buffers++;
+    pthread_mutex_unlock(&s->output_mutex);
+
+    return OMX_ErrorNone;
+}
+
+static void OnDecoderOutputChanged(OMXCodecDecoderContext *s)
+{
+    OMX_ERRORTYPE err;
+    OMX_PARAM_PORTDEFINITIONTYPE portdef;
+    av_log(s->avctx, AV_LOG_INFO, "OnDecoderOutputChanged\n");
+
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex = s->out_port;
+    OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    s->out_buffer_size = portdef.nBufferCountActual;
+
+    dump_portdef(s, &portdef);
+    s->width = portdef.format.image.nFrameWidth;
+    s->height = portdef.format.image.nFrameHeight;
+    s->stride = portdef.format.image.nStride;
+    s->plane_size = portdef.format.image.nSliceHeight;
+    OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->out_port, NULL);
+
+    s->out_buffer_headers = malloc(s->out_buffer_size * sizeof(OMX_BUFFERHEADERTYPE *));
+    for (int i = 0; i < s->out_buffer_size; i++) {
+        err = OMX_AllocateBuffer(s->handle, &s->out_buffer_headers[i],  s->out_port,  s, portdef.nBufferSize);
+    }
+
+    for (int i = 0; i < s->out_buffer_size; i++) {
+        err = OMX_FillThisBuffer(s->handle, s->out_buffer_headers[i]);
+    }
+
+    s->decoderBuffer =   malloc(s->width * s->height * 3 / 2);
+
+    s->portSettingChanged = 1;
+
+}
+
+static OMX_ERRORTYPE event_handler(OMX_HANDLETYPE component, OMX_PTR app_data, OMX_EVENTTYPE event,
+                                   OMX_U32 data1, OMX_U32 data2, OMX_PTR event_data)
+{
+    OMXCodecDecoderContext *s = app_data;
+
+    switch (event) {
+    case OMX_EventError:
+        pthread_mutex_lock(&s->state_mutex);
+        s->error = data1;
+        pthread_cond_broadcast(&s->state_cond);
+        pthread_mutex_unlock(&s->state_mutex);
+        switch (data1) {
+        case OMX_ErrorInsufficientResources:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorInsufficientResources, stop decode!\n");
+            break;
+        case OMX_ErrorInvalidState:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorInvalidState!\n");
+            s->state = OMX_StateInvalid;
+            break;
+        case OMX_ErrorNotReady:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorNotReady!\n");
+            break;
+        case OMX_ErrorIncorrectStateOperation:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorIncorrectStateOperation!\n");
+            break;
+        case OMX_ErrorTimeout:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorTimeout!\n");
+            break;
+        case OMX_ErrorIncorrectStateTransition:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX_ErrorTimeout!\n");
+            break;
+        default:
+            av_log(s->avctx, AV_LOG_ERROR, "OMX error 0x%x\n", (uint32_t) data1);
+            break;
+        }
+        return OMX_ErrorNone;
+    case OMX_EventCmdComplete:
+        if (data1 == OMX_CommandStateSet) {
+            switch (data2) {
+            case  OMX_StateIdle:
+                av_log(s->avctx, AV_LOG_INFO, "OMX_StateIdle\n");
+                break;
+            case OMX_StateLoaded:
+                av_log(s->avctx, AV_LOG_INFO, "OMX_StateLoaded\n");
+                break;
+            case OMX_StateExecuting:
+                av_log(s->avctx, AV_LOG_INFO, "OMX_StateExecuting\n");
+                break;
+            case OMX_StatePause:
+                av_log(s->avctx, AV_LOG_INFO, "OMX_StatePause\n");
+                break;
+            default:
+                av_log(s->avctx, AV_LOG_INFO, "OMX_State %X\n", data2);
+                break;
+            }
+
+        } else if (data1 == OMX_CommandPortDisable) {
+            av_log(s->avctx, AV_LOG_INFO, "OMX port%ld disabled\n", (uint32_t) data2);
+        } else if (data1 == OMX_CommandPortEnable) {
+            av_log(s->avctx, AV_LOG_INFO, "OMX port %ld enabled\n", (uint32_t) data2);
+        } else if (data1 == OMX_CommandFlush) {
+            av_log(s->avctx, AV_LOG_INFO, "OMX port %ld flushed\n", (uint32_t) data2);
+        } else {
+            av_log(s->avctx, AV_LOG_INFO, "OMX command complete, command %ld, value %ld\n",
+                   (uint32_t) data1, (uint32_t) data2);
+        }
+        break;
+    case OMX_EventPortSettingsChanged:
+        if ((int)data1 == OMX_DirOutput) { //out is OMX_DirOutput
+            OnDecoderOutputChanged(s);
+
+        } else if (data1 == s->out_port && data2 == OMX_IndexConfigCommonOutputCrop) {
+
+        } else if (data1 == s->out_port && data2 == OMX_IndexConfigCommonScale) {
+
+        } else {
+            av_log(s->avctx, AV_LOG_ERROR, "error event \n");
+        }
+
+        break;
+    case OMX_EventBufferFlag:
+        if (data1 == s->out_port) {
+            //
+        }
+        break;
+    default:
+        av_log(s->avctx, AV_LOG_INFO, "OMX event %d %ld %ld\n",
+               event, (uint32_t) data1, (uint32_t) data2);
+        break;
+    }
+
+    pthread_mutex_lock(&s->state_mutex);
+
+    s->event = event;
+    s->state = data2;
+    s->cmd = data1;
+
+    pthread_cond_broadcast(&s->state_cond);
+    pthread_mutex_unlock(&s->state_mutex);
+    return OMX_ErrorNone;
+}
+
+
+static const OMX_CALLBACKTYPE decoder_callbacks = {
+    event_handler,
+    empty_buffer_done,
+    fill_buffer_done
+};
+
+
+
+static int wait_for_event(AVCodecContext *avctx, OMX_EVENTTYPE event, OMX_COMMANDTYPE cmd, OMX_STATETYPE state,
+                          int timeout)
+{
+    int ret = 0;
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    pthread_mutex_lock(&s->state_mutex);
+    while ((s->state != state ||  s->cmd != cmd  || s->event != event) && s->error == OMX_ErrorNone) {
+        pthread_cond_wait(&s->state_cond, &s->state_mutex);
+    }
+    if (s->error != OMX_ErrorNone)
+        ret = -1;
+    pthread_mutex_unlock(&s->state_mutex);
+    return ret;
+}
+
+static  void *dlsym_prefixed(void *handle, const char *symbol, const char *prefix)
+{
+    char buf[50];
+    snprintf(buf, sizeof(buf), "%s%s", prefix ? prefix : "", symbol);
+    return dlsym(handle, buf);
+}
+
+
+static int omx_try_load(OMXContext *s, void *logctx,
+                        const char *libname, const char *prefix,
+                        const char *libname2)
+{
+    s->lib = dlopen(libname, RTLD_NOW | RTLD_GLOBAL);
+    if (!s->lib) {
+        av_log(logctx, AV_LOG_ERROR, "%s not found\n", libname);
+        return -1;
+    }
+    s->ptr_Init                = dlsym_prefixed(s->lib, "OMX_Init", prefix);
+    s->ptr_Deinit              = dlsym_prefixed(s->lib, "OMX_Deinit", prefix);
+    s->ptr_ComponentNameEnum   = dlsym_prefixed(s->lib, "OMX_ComponentNameEnum", prefix);
+    s->ptr_GetHandle           = dlsym_prefixed(s->lib, "OMX_GetHandle", prefix);
+    s->ptr_FreeHandle          = dlsym_prefixed(s->lib, "OMX_FreeHandle", prefix);
+    s->ptr_GetComponentsOfRole = dlsym_prefixed(s->lib, "OMX_GetComponentsOfRole", prefix);
+    s->ptr_GetRolesOfComponent = dlsym_prefixed(s->lib, "OMX_GetRolesOfComponent", prefix);
+
+    if (!s->ptr_Init || !s->ptr_Deinit || !s->ptr_ComponentNameEnum ||
+        !s->ptr_GetHandle || !s->ptr_FreeHandle ||
+        !s->ptr_GetComponentsOfRole || !s->ptr_GetRolesOfComponent) {
+        av_log(logctx, AV_LOG_ERROR, "Not all functions found in %s\n", libname);
+        dlclose(s->lib);
+        s->lib = NULL;
+        if (s->lib2)
+            dlclose(s->lib2);
+        s->lib2 = NULL;
+        return -1;
+    }
+    return 0;
+}
+
+
+static int print_omx_env(OMXContext *omx_context)
+{
+    OMX_ERRORTYPE err;
+    OMX_U32 numComps = 0;
+    OMX_U8 component[OMX_MAX_STRINGNAME_SIZE];
+    OMX_U8 **roleList;
+
+    if (omx_context == NULL) {
+        return 0;
+    }
+
+    if (omx_context->ptr_ComponentNameEnum == NULL) {
+        return 0;
+    }
+    numComps = 0;
+    while (err == OMX_ErrorNone) {
+        err = omx_context->ptr_ComponentNameEnum(component, OMX_MAX_STRINGNAME_SIZE, numComps);
+        if (err == OMX_ErrorNone) {
+            OMX_U32 numberofroles = 0;
+            err = omx_context->ptr_GetRolesOfComponent(component, &numberofroles, NULL);
+            if (numberofroles == 1) {
+                roleList = malloc(numberofroles * sizeof(OMX_U8 *));
+                roleList[0] =  malloc(OMX_MAX_STRINGNAME_SIZE);
+                omx_context->ptr_GetRolesOfComponent(component, &numberofroles, roleList);
+                free(roleList[0]);
+                free(roleList);
+            }
+        }
+        numComps++;
+    }
+
+    return 0;
+}
+
+static OMXContext *omx_init(void *logctx,  const char *prefix)
+{
+    static const char *const libnames[] = {
+        "libomxil-bellagio.so.0", NULL,
+        "libOMX_Core.so", NULL,
+        "libOmxCore.so", NULL,
+        NULL
+    };
+    const char *const *nameptr;
+    int ret = -1;
+    OMXContext *omx_context;
+    OMX_ERRORTYPE error;
+    omx_context = malloc(sizeof(*omx_context));
+    if (!omx_context)
+        return NULL;
+    memset((void *)omx_context, 0, sizeof(*omx_context));
+
+    for (nameptr = libnames; *nameptr; nameptr += 2)
+        if (!(ret = omx_try_load(omx_context, logctx, nameptr[0], prefix, nameptr[1])))
+            break;
+    if (!*nameptr) {
+        free(omx_context);
+        return NULL;
+    }
+
+
+    if (omx_context->host_init)
+        omx_context->host_init();
+    av_log(NULL, AV_LOG_INFO, "OMX_count load %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        error = omx_context->ptr_Init();
+        if (error != OMX_ErrorNone) {
+            av_log(NULL, AV_LOG_WARNING, "OMX Init error\n");
+        }
+    }
+    omx_load_count++;
+    return omx_context;
+}
+
+static int omx_dec_find_component(OMXContext *omx_context,
+                                  const char *role, char *str, int str_size)
+{
+    OMX_U32 i, num = 0;
+    char **components;
+    int ret = 0;
+//OMX.hantro.VC8000D.image.decoder.jpeg
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, NULL);
+    if (!num) {
+        return -1;
+    }
+    components = calloc(num, sizeof(*components));
+    if (!components)
+        return -1;
+
+    memset((void *)components, 0, num * sizeof(*components));
+    for (i = 0; i < num; i++) {
+        components[i] = malloc(OMX_MAX_STRINGNAME_SIZE);
+        if (!components[i]) {
+            ret = -1;
+            goto end;
+        }
+        memset((void *)components[i], 0, OMX_MAX_STRINGNAME_SIZE);
+    }
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, (OMX_U8 **) components);
+    strncpy(str, components[0], str_size);
+end:
+    for (i = 0; i < num; i++)
+        free(components[i]);
+    free(components);
+    return ret;
+}
+
+
+static void omx_deinit(OMXContext *omx_context)
+{
+    if (!omx_context)
+        return;
+    omx_load_count--;
+    av_log(NULL, AV_LOG_INFO, "OMX_count %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        omx_context->ptr_Deinit();
+        dlclose(omx_context->lib);
+    }
+    free(omx_context);
+}
+
+
+
+static int omx_component_init_decoder(AVCodecContext *avctx)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    OMX_PARAM_COMPONENTROLETYPE role_params = { 0 };
+    OMX_PARAM_PORTDEFINITIONTYPE in_port_params = { 0 }, out_port_params = { 0 };
+
+    OMX_PARAM_PORTDEFINITIONTYPE portdef;
+    OMX_IMAGE_PARAM_PORTFORMATTYPE imagePortFormat;
+    OMX_PORT_PARAM_TYPE port;
+
+    OMX_ERRORTYPE err;
+    int i;
+
+    s->version.s.nVersionMajor = 1;
+    s->version.s.nVersionMinor = 1;
+    s->version.s.nRevision     = 2;
+    err = s->omx_context->ptr_GetHandle(&s->handle, s->component_name, s, (OMX_CALLBACKTYPE *) &decoder_callbacks);
+    if (err != OMX_ErrorNone) {
+        av_log(s->avctx, AV_LOG_ERROR, "OMX_GetHandle(%s) failed: %x\n", s->component_name, err);
+        return -1;
+    }
+
+    s->crop_left = 0;
+    s->crop_top = 0;
+    INIT_STRUCT(port);
+    OMX_GetParameter(s->handle, OMX_IndexParamImageInit, &port);
+    if (port.nPorts != 2) {
+        return -1;
+    }
+
+    s->in_port = port.nStartPortNumber;
+    s->out_port = port.nStartPortNumber + 1;
+
+    OMX_SendCommand(s->handle, OMX_CommandPortDisable, s->in_port, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortDisable, s->in_port, TIMEOUT_MS);
+    OMX_SendCommand(s->handle, OMX_CommandPortDisable, s->out_port, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortDisable, s->out_port, TIMEOUT_MS);
+
+
+
+
+    memset((void *)&imagePortFormat, 0, sizeof(imagePortFormat));
+    INIT_STRUCT(imagePortFormat);
+
+    imagePortFormat.nPortIndex = s->in_port;
+    imagePortFormat.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+
+    OMX_SetParameter(s->handle, OMX_IndexParamImagePortFormat, &imagePortFormat);
+
+
+
+    memset((void *)&portdef, 0, sizeof(portdef));
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex =  s->in_port;
+
+    OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    int iBufferCount = portdef.nBufferCountActual;
+    int iBufferSize = portdef.nBufferSize;
+    if (s->stride != 0) {
+        portdef.format.image.nFrameWidth = s->stride;
+        portdef.format.image.nFrameHeight = s->plane_size;
+    }
+
+    if (s->filelen >  4096 * 1024) {
+        portdef.nBufferSize = s->filelen;
+    } else {
+        portdef.nBufferSize = 4096 * 1024;
+    }
+    iBufferSize = portdef.nBufferSize;
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    if (err != OMX_ErrorNone) {
+        av_log(s->avctx, AV_LOG_ERROR, "set error failed\n");
+    }
+    dump_portdef(s, &portdef);
+    memset((void *)&portdef, 0, sizeof(portdef));
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex =  s->out_port;
+
+    OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    dump_portdef(s, &portdef);
+    if (s->stride != 0) {
+        portdef.format.image.nFrameWidth = s->stride;
+        portdef.format.image.nFrameHeight = s->plane_size;
+        OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    }
+
+    OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet,  OMX_StateIdle, TIMEOUT_MS);
+
+    OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->in_port, NULL);
+
+    s->num_free_in_buffers = s->in_buffer_size = iBufferCount;
+    s->num_done_out_buffers = 0;
+    s->in_buffer_headers = malloc(iBufferCount * sizeof(OMX_BUFFERHEADERTYPE *));
+    for (int i = 0; i < iBufferCount; i++) {
+        OMX_AllocateBuffer(s->handle, &s->in_buffer_headers[i],  s->in_port,  s, iBufferSize);
+    }
+
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortEnable, s->in_port, TIMEOUT_MS);
+    OMX_SendCommand(s->handle,  OMX_CommandStateSet, OMX_StateExecuting, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet, OMX_StateExecuting, TIMEOUT_MS);
+
+
+    av_log(s->avctx, AV_LOG_INFO, "finish omx_component_init_decoder\n");
+
+    return 0;
+}
+
+
+static int omx_decode_init2(AVCodecContext *avctx)
+{
+    av_log(avctx, AV_LOG_INFO, "jpeg_omxcodec decoder init...\n");
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    int ret = -1;
+    const char *role = "image_decoder.jpeg";
+    memset((void *)s, 0, sizeof(OMXCodecDecoderContext));
+
+    s->avctx = avctx;
+    s->width = 0;
+    s->height = 0;
+    s->decoderBuffer = NULL;
+    s->omx_context = omx_init(s->libname, s->libprefix);
+    if (!s->omx_context)
+        return -1;
+    pthread_mutex_init(&s->state_mutex, NULL);
+    pthread_cond_init(&s->state_cond, NULL);
+    pthread_mutex_init(&s->input_mutex, NULL);
+    pthread_cond_init(&s->input_cond, NULL);
+    pthread_mutex_init(&s->output_mutex, NULL);
+    pthread_cond_init(&s->output_cond, NULL);
+
+    s->state = OMX_StateLoaded;
+    s->error = OMX_ErrorNone;
+
+    strcpy(s->component_name, "OMX.hantro.VC8000D.image.decoder.jpeg");
+    return 0;
+}
+
+static int omx_decode_init(AVCodecContext *avctx, int len)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    int ret = -1;
+    s->filelen = len;
+    av_log(s->avctx, AV_LOG_INFO, "Using file %d\n", s->filelen);
+    ret =  omx_component_init_decoder(avctx);
+    if (ret < 0) {
+        return ret;
+    }
+    return 0;
+}
+
+static int omx_decode_uninit(AVCodecContext *avctx)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+
+    if (s->state == OMX_StateExecuting) {
+
+        OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
+        wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet, OMX_StateIdle, TIMEOUT_MS);
+        OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateLoaded, NULL);
+
+        for (int i = 0; i < s->num_in_buffers; i++) {
+            OMX_BUFFERHEADERTYPE *buffer = s->in_buffer_headers[i];
+            OMX_FreeBuffer(s->handle, s->in_port, buffer);
+        }
+
+        for (int i = 0; i < s->num_out_buffers; i++) {
+            OMX_BUFFERHEADERTYPE *buffer = s->out_buffer_headers[i];
+            OMX_FreeBuffer(s->handle, s->out_port, buffer);
+        }
+        wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet, OMX_StateLoaded, TIMEOUT_MS);
+    }
+
+
+    if (s->handle) {
+        s->omx_context->ptr_FreeHandle(s->handle);
+        s->handle = NULL;
+    }
+
+
+    omx_deinit(s->omx_context);
+    s->omx_context = NULL;
+    free(s->in_buffer_headers);
+    free(s->out_buffer_headers);
+    free(s->free_in_buffers);
+    free(s->done_out_buffers);
+    if (s->decoderBuffer) {
+        free(s->decoderBuffer);
+        s->decoderBuffer = NULL;
+    }
+
+    pthread_cond_destroy(&s->state_cond);
+    pthread_mutex_destroy(&s->state_mutex);
+    pthread_cond_destroy(&s->input_cond);
+    pthread_mutex_destroy(&s->input_mutex);
+    pthread_cond_destroy(&s->output_cond);
+    pthread_mutex_destroy(&s->output_mutex);
+    av_log(avctx, AV_LOG_INFO, "jpeg_omxcodec decoder finish...\n");
+    return 0;
+}
+
+
+#define FORMAT_NV12
+
+static void *convertToYUV420p(AVCodecContext *avctx, AVFrame *avframe)
+{
+    int ret = 0;
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    if (s->decoderBuffer != NULL) { //nv12 to YUV420p
+        int y_size =  s->width * s->height;
+        int uv_size = y_size / 4;
+
+        uint8_t *y_src = (uint8_t *)(s->decoderBuffer);
+        uint8_t *uv_src = (uint8_t *)(s->decoderBuffer) + y_size;
+        int  outsize = s->width * s->height * 3 / 2;
+
+#ifdef FORMAT_NV12
+        avframe->format =  AV_PIX_FMT_NV12;
+#else
+        avframe->format =  AV_PIX_FMT_YUV420P;
+#endif
+        avframe->width = s->width;
+        avframe->height = s->height;
+
+        ret = av_image_alloc(avframe->data, avframe->linesize, avframe->width, avframe->height, avframe->format, 32);
+        if (ret < 0) {
+            //process alloc failed
+            return AVERROR(EAGAIN);
+        }
+        av_image_get_buffer_size(avctx->pix_fmt,  avctx->width, avctx->height, 1);
+
+        ret = av_frame_get_buffer(avframe, 0);
+        if (ret < 0) {
+            av_frame_free(&avframe);
+            return AVERROR(EAGAIN);
+        }
+#ifdef FORMAT_NV12
+        avframe->linesize[0] = avframe->width;
+        avframe->linesize[1] = avframe->width;
+#else
+        avframe->linesize[0] = avframe->width;
+        avframe->linesize[1] = avframe->width / 2;
+        avframe->linesize[2] = avframe->width / 2;
+#endif
+        uint8_t *y_dst = avframe->data[0];
+        uint8_t *u_dst = avframe->data[1];
+        uint8_t *v_dst = avframe->data[2];
+
+#ifdef FORMAT_NV12
+        //avframe->data[0] = y_src;
+        //avframe->data[1] = uv_src;
+        memcpy(y_dst, y_src, avframe->width * avframe->height);
+        memcpy(u_dst, uv_src, avframe->width * avframe->height / 2);
+#else
+        //avframe->data[0] = y_src;
+        memcpy(y_dst, y_src, avframe->width * avframe->height);
+        for (int i = 0; i < uv_size; i ++) {
+            *(u_dst++) = *(uv_src++);
+            *(v_dst++) = *(uv_src++);
+        }
+#endif
+    }
+    return NULL;
+}
+
+
+
+static int omx_decode_image(AVCodecContext *avctx, void *buffer, int len, AVFrame *frame)
+{
+    OMXCodecDecoderContext *s = avctx->priv_data;
+
+    int done = 0;
+    int in_pos = 0;
+    int out_pos = 0;
+    int in_index = 0;
+    int out_index = 0;
+    s->portSettingChanged = 0;
+
+    while (!done) {
+
+        if ((s->num_free_in_buffers > 0) && (in_pos < len)) {
+            OMX_BUFFERHEADERTYPE *pBufHeader = s->in_buffer_headers[in_index];
+            in_index++;
+            pthread_mutex_lock(&s->input_mutex);
+            s->num_free_in_buffers--;
+            pthread_mutex_unlock(&s->input_mutex);
+            if (in_index >= s->in_buffer_size) {
+                in_index = 0;
+            }
+            pBufHeader->nOffset = 0;
+            pBufHeader->nFlags = 0;
+
+
+            if ((in_pos + pBufHeader->nAllocLen) < len) {
+                av_log(s->avctx, AV_LOG_INFO, "total len %d, currnet Filled buffer size %d, still %d left\n", len,
+                       pBufHeader->nAllocLen, len - in_pos);
+                memcpy(pBufHeader->pBuffer,  buffer + in_pos, pBufHeader->nAllocLen);
+                pBufHeader->nFilledLen = pBufHeader->nAllocLen;
+                in_pos +=  pBufHeader->nAllocLen;
+            } else {
+                memcpy(pBufHeader->pBuffer,  buffer + in_pos, len - in_pos);
+                pBufHeader->nFilledLen = len - in_pos;
+                pBufHeader->nFlags = OMX_BUFFERFLAG_EOS;
+                pBufHeader->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
+                in_pos = len;
+                av_log(s->avctx, AV_LOG_INFO, "input EOS reached\n");
+            }
+
+            OMX_EmptyThisBuffer(s->handle, pBufHeader);
+
+        }
+
+        if (s->portSettingChanged) {
+
+            while (s->num_done_out_buffers > 0) {
+
+                OMX_BUFFERHEADERTYPE *pBufHeader = s->out_buffer_headers[out_index];
+                out_index++;
+                if (out_index >= s->out_buffer_size) {
+                    out_index = 0;
+                }
+                pthread_mutex_lock(&s->output_mutex);
+                s->num_done_out_buffers--;
+                pthread_mutex_unlock(&s->output_mutex);
+                if (pBufHeader->nFilledLen > 0) {
+                    if (s->decoderBuffer != NULL) {
+                        memcpy(s->decoderBuffer + out_pos, pBufHeader->pBuffer, pBufHeader->nFilledLen);
+                    }
+                    out_pos += pBufHeader->nFilledLen;
+                }
+
+                if (pBufHeader->nFlags & OMX_BUFFERFLAG_EOS) {
+                    done = 1;
+                }
+                OMX_FillThisBuffer(s->handle, pBufHeader);
+            }
+
+        } else {
+            usleep(1);
+        }
+
+    }
+    convertToYUV420p(avctx, frame);
+
+    return 0;
+}
+
+
+
+
+static int omx_decode_rec_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)
+{
+
+    OMXCodecDecoderContext *s = avctx->priv_data;
+    AVFrame *frame = data;
+    int ret = 0;
+    int filelen = avpkt->size;
+    *got_frame = 0;
+    if (filelen) {
+        char *inbuffer = (char *)malloc(sizeof(char) * filelen);
+        if (!inbuffer) {
+            av_log(s->avctx, AV_LOG_ERROR, "error: malloc inbuffer failed.\n");
+            return AVERROR_EOF;
+        }
+        memcpy(inbuffer, avpkt->data, filelen);
+        if (inbuffer[158] == 0xff && inbuffer[159] == 0xc2) {
+            av_log(s->avctx, AV_LOG_ERROR, "error: decoder not support progressive jpeg.\n");
+            free(inbuffer);
+            return AVERROR_EOF;
+        }
+
+        omx_decode_init(avctx, filelen);
+        omx_decode_image(avctx, inbuffer, filelen, frame);
+        free(inbuffer);
+        *got_frame = 1;
+        return AVERROR_EOF;
+
+    }
+
+    return AVERROR_EOF;
+}
+
+
+const AVCodec ff_jpeg_omx_decoder = {
+    .name           = "jpeg_omx",
+    .long_name      = NULL_IF_CONFIG_SMALL("OpenMAX IL decoder"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_MJPEG,
+    .priv_data_size = sizeof(OMXCodecDecoderContext),
+    .init           = omx_decode_init2,
+    .decode         = omx_decode_rec_frame,
+    .close          = omx_decode_uninit,
+    .capabilities   = AV_CODEC_CAP_DR1,
+    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
+    FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+};
diff --git a/libavcodec/omxjpegencoder.c b/libavcodec/omxjpegencoder.c
new file mode 100644
index 0000000..43eba62
--- /dev/null
+++ b/libavcodec/omxjpegencoder.c
@@ -0,0 +1,1234 @@
+/*
+ * OMX Video encoder
+ * Copyright (C) 2011 Martin Storsjo
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+
+#if CONFIG_OMX_RPI
+#define OMX_SKIP64BIT
+#endif
+
+#include <dlfcn.h>
+#include <OMX_Core.h>
+#include <OMX_Component.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+
+#include "libavutil/avstring.h"
+#include "libavutil/avutil.h"
+#include "libavutil/common.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/log.h"
+#include "libavutil/opt.h"
+#include "libavutil/time.h"
+#include "avcodec.h"
+#include "h264.h"
+#include "internal.h"
+
+#include "vsi_vendor_ext.h"
+static int omx_load_count = 0;
+#define TIMEOUT_MS 1000
+#ifdef OMX_SKIP64BIT
+static OMX_TICKS to_omx_ticks(int64_t value)
+{
+    OMX_TICKS s;
+    s.nLowPart  = value & 0xffffffff;
+    s.nHighPart = value >> 32;
+    return s;
+}
+static int64_t from_omx_ticks(OMX_TICKS value)
+{
+    return (((int64_t)value.nHighPart) << 32) | value.nLowPart;
+}
+#else
+#define to_omx_ticks(x) (x)
+#define from_omx_ticks(x) (x)
+#endif
+
+#define INIT_STRUCT(x) do {                                               \
+        x.nSize = sizeof(x);                                              \
+        x.nVersion = s->version;                                          \
+    } while (0)
+#define CHECK(x) do {                                                     \
+        if (x != OMX_ErrorNone) {                                         \
+            av_log(avctx, AV_LOG_ERROR,                                   \
+                   "err %x (%d) on line %d\n", x, x, __LINE__);           \
+            return AVERROR_UNKNOWN;                                       \
+        }                                                                 \
+    } while (0)
+
+typedef struct OMXContext {
+    void *lib;
+    void *lib2;
+    OMX_ERRORTYPE(*ptr_Init)(void);
+    OMX_ERRORTYPE(*ptr_Deinit)(void);
+    OMX_ERRORTYPE(*ptr_ComponentNameEnum)(OMX_STRING, OMX_U32, OMX_U32);
+    OMX_ERRORTYPE(*ptr_GetHandle)(OMX_HANDLETYPE *, OMX_STRING, OMX_PTR, OMX_CALLBACKTYPE *);
+    OMX_ERRORTYPE(*ptr_FreeHandle)(OMX_HANDLETYPE);
+    OMX_ERRORTYPE(*ptr_GetComponentsOfRole)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    OMX_ERRORTYPE(*ptr_GetRolesOfComponent)(OMX_STRING, OMX_U32 *, OMX_U8 **);
+    void (*host_init)(void);
+} OMXContext;
+
+static av_cold void *dlsym_prefixed(void *handle, const char *symbol, const char *prefix)
+{
+    char buf[50];
+    snprintf(buf, sizeof(buf), "%s%s", prefix ? prefix : "", symbol);
+    return dlsym(handle, buf);
+}
+
+static av_cold int omx_try_load(OMXContext *s, void *logctx,
+                                const char *libname, const char *prefix,
+                                const char *libname2)
+{
+    if (libname2) {
+        s->lib2 = dlopen(libname2, RTLD_NOW | RTLD_GLOBAL);
+        if (!s->lib2) {
+            av_log(logctx, AV_LOG_WARNING, "%s not found\n", libname2);
+            return AVERROR_ENCODER_NOT_FOUND;
+        }
+        s->host_init = dlsym(s->lib2, "bcm_host_init");
+        if (!s->host_init) {
+            av_log(logctx, AV_LOG_WARNING, "bcm_host_init not found\n");
+            dlclose(s->lib2);
+            s->lib2 = NULL;
+            return AVERROR_ENCODER_NOT_FOUND;
+        }
+    }
+    s->lib = dlopen(libname, RTLD_NOW | RTLD_GLOBAL);
+    if (!s->lib) {
+        av_log(logctx, AV_LOG_WARNING, "%s not found\n", libname);
+        return AVERROR_ENCODER_NOT_FOUND;
+    }
+    s->ptr_Init                = dlsym_prefixed(s->lib, "OMX_Init", prefix);
+    s->ptr_Deinit              = dlsym_prefixed(s->lib, "OMX_Deinit", prefix);
+    s->ptr_ComponentNameEnum   = dlsym_prefixed(s->lib, "OMX_ComponentNameEnum", prefix);
+    s->ptr_GetHandle           = dlsym_prefixed(s->lib, "OMX_GetHandle", prefix);
+    s->ptr_FreeHandle          = dlsym_prefixed(s->lib, "OMX_FreeHandle", prefix);
+    s->ptr_GetComponentsOfRole = dlsym_prefixed(s->lib, "OMX_GetComponentsOfRole", prefix);
+    s->ptr_GetRolesOfComponent = dlsym_prefixed(s->lib, "OMX_GetRolesOfComponent", prefix);
+    if (!s->ptr_Init || !s->ptr_Deinit || !s->ptr_ComponentNameEnum ||
+        !s->ptr_GetHandle || !s->ptr_FreeHandle ||
+        !s->ptr_GetComponentsOfRole || !s->ptr_GetRolesOfComponent) {
+        av_log(logctx, AV_LOG_WARNING, "Not all functions found in %s\n", libname);
+        dlclose(s->lib);
+        s->lib = NULL;
+        if (s->lib2)
+            dlclose(s->lib2);
+        s->lib2 = NULL;
+        return AVERROR_ENCODER_NOT_FOUND;
+    }
+    return 0;
+}
+
+static av_cold OMXContext *omx_init(void *logctx, const char *libname, const char *prefix)
+{
+    static const char *const libnames[] = {
+#if CONFIG_OMX_RPI
+        "/opt/vc/lib/libopenmaxil.so", "/opt/vc/lib/libbcm_host.so",
+#else
+        "libomxil-bellagio.so.0", NULL,
+        "libOMX_Core.so", NULL,
+        "libOmxCore.so", NULL,
+#endif
+        NULL
+    };
+    const char *const *nameptr;
+    int ret = AVERROR_ENCODER_NOT_FOUND;
+    OMXContext *omx_context;
+    OMX_ERRORTYPE error;
+    omx_context = av_mallocz(sizeof(*omx_context));
+    if (!omx_context)
+        return NULL;
+    if (libname) {
+        ret = omx_try_load(omx_context, logctx, libname, prefix, NULL);
+        if (ret < 0) {
+            av_free(omx_context);
+            return NULL;
+        }
+    } else {
+        for (nameptr = libnames; *nameptr; nameptr += 2)
+            if (!(ret = omx_try_load(omx_context, logctx, nameptr[0], prefix, nameptr[1])))
+                break;
+        if (!*nameptr) {
+            av_free(omx_context);
+            return NULL;
+        }
+    }
+
+    if (omx_context->host_init)
+        omx_context->host_init();
+    av_log(NULL, AV_LOG_INFO, "OMX_count load %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        error = omx_context->ptr_Init();
+        if (error != OMX_ErrorNone) {
+            av_log(NULL, AV_LOG_WARNING, "OMX Init error\n");
+        }
+    }
+    omx_load_count++;
+    return omx_context;
+}
+
+static av_cold void omx_deinit(OMXContext *omx_context)
+{
+    if (!omx_context)
+        return;
+    omx_load_count--;
+    av_log(NULL, AV_LOG_INFO, "OMX_count %d\n", omx_load_count);
+    if (omx_load_count == 0) {
+        omx_context->ptr_Deinit();
+        dlclose(omx_context->lib);
+    }
+    av_free(omx_context);
+}
+
+typedef struct OMXCodecContext {
+    const AVClass *class;
+    char *libname;
+    char *libprefix;
+    OMXContext *omx_context;
+
+    AVCodecContext *avctx;
+
+    char component_name[OMX_MAX_STRINGNAME_SIZE];
+    OMX_VERSIONTYPE version;
+    OMX_HANDLETYPE handle;
+    int in_port, out_port;
+    OMX_COLOR_FORMATTYPE color_format;
+    int stride, plane_size;
+
+    int num_in_buffers, num_out_buffers;
+    OMX_BUFFERHEADERTYPE **in_buffer_headers;
+    OMX_BUFFERHEADERTYPE **out_buffer_headers;
+    int num_free_in_buffers;
+    OMX_BUFFERHEADERTYPE **free_in_buffers;
+    int num_done_out_buffers;
+    OMX_BUFFERHEADERTYPE **done_out_buffers;
+
+    pthread_mutex_t input_mutex;
+    pthread_cond_t input_cond;
+    pthread_mutex_t output_mutex;
+    pthread_cond_t output_cond;
+
+    pthread_mutex_t state_mutex;
+    pthread_cond_t state_cond;
+    OMX_STATETYPE state;
+    OMX_ERRORTYPE error;
+    OMX_EVENTTYPE event;
+    OMX_COMMANDTYPE cmd;
+
+    int mutex_cond_inited;
+
+    int eos_sent, got_eos;
+
+    uint8_t *output_buf;
+    int output_buf_size;
+
+    int input_zerocopy;
+    int profile;
+    int QFactor;
+    int maxpts;
+    int stride_padding;
+} OMXCodecContext;
+
+
+
+static void say(OMXCodecContext *s, const char *message, ...)
+{
+    va_list args;
+    size_t str_len;
+    char str[1024];
+    memset(str, 0, sizeof(str));
+    va_start(args, message);
+    vsnprintf(str, sizeof(str) - 1, message, args);
+    va_end(args);
+    str_len = strlen(str);
+    if (str[str_len - 1] != '\n') {
+        str[str_len] = '\n';
+    }
+
+    av_log(s->avctx, AV_LOG_INFO, "%s", str);
+}
+
+
+static const char *dump_compression_format(OMXCodecContext *s, OMX_VIDEO_CODINGTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_VIDEO_CodingUnused:
+        return "not used";
+    case OMX_VIDEO_CodingAutoDetect:
+        return "autodetect";
+    case OMX_VIDEO_CodingH263:
+        return "H.263";
+    case OMX_VIDEO_CodingMPEG4:
+        return "MPEG4";
+    case OMX_VIDEO_CodingWMV:
+        return "Windows Media Video";
+    case OMX_VIDEO_CodingRV:
+        return "RealVideo";
+    case OMX_VIDEO_CodingAVC:
+        return "H.264/AVC";
+    case OMX_VIDEO_CodingMJPEG:
+        return "Motion JPEG";
+    case OMX_IMAGE_CodingJPEG:
+        return "JPEG";
+//        case OMX_VIDEO_CodingTheora:     return "OGG Theora";
+
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f, "format type 0x%08x", c);
+        return f;//maybe memleak
+    }
+}
+
+static const char *dump_color_format(OMXCodecContext *s, OMX_COLOR_FORMATTYPE c)
+{
+    char *f;
+    switch (c) {
+    case OMX_COLOR_FormatUnused:
+        return "OMX_COLOR_FormatUnused: not used";
+    case OMX_COLOR_FormatMonochrome:
+        return "OMX_COLOR_FormatMonochrome";
+    case OMX_COLOR_Format8bitRGB332:
+        return "OMX_COLOR_Format8bitRGB332";
+    case OMX_COLOR_Format12bitRGB444:
+        return "OMX_COLOR_Format12bitRGB444";
+    case OMX_COLOR_Format16bitARGB4444:
+        return "OMX_COLOR_Format16bitARGB4444";
+    case OMX_COLOR_Format16bitARGB1555:
+        return "OMX_COLOR_Format16bitARGB1555";
+    case OMX_COLOR_Format16bitRGB565:
+        return "OMX_COLOR_Format16bitRGB565";
+    case OMX_COLOR_Format16bitBGR565:
+        return "OMX_COLOR_Format16bitBGR565";
+    case OMX_COLOR_Format18bitRGB666:
+        return "OMX_COLOR_Format18bitRGB666";
+    case OMX_COLOR_Format18bitARGB1665:
+        return "OMX_COLOR_Format18bitARGB1665";
+    case OMX_COLOR_Format19bitARGB1666:
+        return "OMX_COLOR_Format19bitARGB1666";
+    case OMX_COLOR_Format24bitRGB888:
+        return "OMX_COLOR_Format24bitRGB888";
+    case OMX_COLOR_Format24bitBGR888:
+        return "OMX_COLOR_Format24bitBGR888";
+    case OMX_COLOR_Format24bitARGB1887:
+        return "OMX_COLOR_Format24bitARGB1887";
+    case OMX_COLOR_Format25bitARGB1888:
+        return "OMX_COLOR_Format25bitARGB1888";
+    case OMX_COLOR_Format32bitBGRA8888:
+        return "OMX_COLOR_Format32bitBGRA8888";
+    case OMX_COLOR_Format32bitARGB8888:
+        return "OMX_COLOR_Format32bitARGB8888";
+    case OMX_COLOR_FormatYUV411Planar:
+        return "OMX_COLOR_FormatYUV411Planar";
+    case OMX_COLOR_FormatYUV411PackedPlanar:
+        return "OMX_COLOR_FormatYUV411PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420Planar:
+        return "OMX_COLOR_FormatYUV420Planar: Planar YUV, 4:2:0 (I420)";
+    case OMX_COLOR_FormatYUV420PackedPlanar:
+        return "OMX_COLOR_FormatYUV420PackedPlanar: Planar YUV, 4:2:0 (I420), planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV420SemiPlanar:
+        return "OMX_COLOR_FormatYUV420SemiPlanar, Planar YUV, 4:2:0 (NV12), U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422Planar:
+        return "OMX_COLOR_FormatYUV422Planar";
+    case OMX_COLOR_FormatYUV422PackedPlanar:
+        return "OMX_COLOR_FormatYUV422PackedPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_FormatYUV422SemiPlanar:
+        return "OMX_COLOR_FormatYUV422SemiPlanar";
+    case OMX_COLOR_FormatYCbYCr:
+        return "OMX_COLOR_FormatYCbYCr";
+    case OMX_COLOR_FormatYCrYCb:
+        return "OMX_COLOR_FormatYCrYCb";
+    case OMX_COLOR_FormatCbYCrY:
+        return "OMX_COLOR_FormatCbYCrY";
+    case OMX_COLOR_FormatCrYCbY:
+        return "OMX_COLOR_FormatCrYCbY";
+    case OMX_COLOR_FormatYUV444Interleaved:
+        return "OMX_COLOR_FormatYUV444Interleaved";
+    case OMX_COLOR_FormatRawBayer8bit:
+        return "OMX_COLOR_FormatRawBayer8bit";
+    case OMX_COLOR_FormatRawBayer10bit:
+        return "OMX_COLOR_FormatRawBayer10bit";
+    case OMX_COLOR_FormatRawBayer8bitcompressed:
+        return "OMX_COLOR_FormatRawBayer8bitcompressed";
+    case OMX_COLOR_FormatL2:
+        return "OMX_COLOR_FormatL2";
+    case OMX_COLOR_FormatL4:
+        return "OMX_COLOR_FormatL4";
+    case OMX_COLOR_FormatL8:
+        return "OMX_COLOR_FormatL8";
+    case OMX_COLOR_FormatL16:
+        return "OMX_COLOR_FormatL16";
+    case OMX_COLOR_FormatL24:
+        return "OMX_COLOR_FormatL24";
+    case OMX_COLOR_FormatL32:
+        return "OMX_COLOR_FormatL32";
+    case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV420PackedSemiPlanar: Planar YUV, 4:2:0 (NV12), planes fragmented when a frame is split in multiple buffers, U and V planes interleaved with first U value";
+    case OMX_COLOR_FormatYUV422PackedSemiPlanar:
+        return "OMX_COLOR_FormatYUV422PackedSemiPlanar: Planes fragmented when a frame is split in multiple buffers";
+    case OMX_COLOR_Format18BitBGR666:
+        return "OMX_COLOR_Format18BitBGR666";
+    case OMX_COLOR_Format24BitARGB6666:
+        return "OMX_COLOR_Format24BitARGB6666";
+    case OMX_COLOR_Format24BitABGR6666:
+        return "OMX_COLOR_Format24BitABGR6666";
+    default:
+        f = calloc(32, sizeof(char));
+        memset(f, 0, 32 * sizeof(char));
+        if (f == NULL) {
+            av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory");
+        }
+        sprintf(f,  "format type 0x%08x", c);
+        return f;
+    }
+}
+
+static void dump_portdef(OMXCodecContext *s, OMX_PARAM_PORTDEFINITIONTYPE *portdef)
+{
+    OMX_VIDEO_PORTDEFINITIONTYPE *viddef = &portdef->format.video;
+    OMX_IMAGE_PORTDEFINITIONTYPE *imgdef = &portdef->format.image;
+
+    say(s, "Port %d is %s, %s, buffers wants:%d needs:%d, size:%d, pop:%d, aligned:%d",
+        portdef->nPortIndex,
+        (portdef->eDir ==  OMX_DirInput ? "input" : "output"),
+        (portdef->bEnabled == OMX_TRUE ? "enabled" : "disabled"),
+        portdef->nBufferCountActual,
+        portdef->nBufferCountMin,
+        portdef->nBufferSize,
+        portdef->bPopulated,
+        portdef->nBufferAlignment);
+
+
+    switch (portdef->eDomain) {
+    case OMX_PortDomainVideo:
+        say(s, "Video type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tBitrate:\t%d\n"
+            "\tFramerate:\t%.02f\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            viddef->nFrameWidth,
+            viddef->nFrameHeight,
+            viddef->nStride,
+            viddef->nSliceHeight,
+            viddef->nBitrate,
+            ((float)viddef->xFramerate / (float)65536),
+            (viddef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, viddef->eCompressionFormat),
+            dump_color_format(s, viddef->eColorFormat));
+        break;
+    case OMX_PortDomainImage:
+        say(s, "Image type:\n"
+            "\tWidth:\t\t%d\n"
+            "\tHeight:\t\t%d\n"
+            "\tStride:\t\t%d\n"
+            "\tSliceHeight:\t%d\n"
+            "\tError hiding:\t%s\n"
+            "\tCodec:\t\t%s\n"
+            "\tColor:\t\t%s\n",
+            imgdef->nFrameWidth,
+            imgdef->nFrameHeight,
+            imgdef->nStride,
+            imgdef->nSliceHeight,
+            (imgdef->bFlagErrorConcealment == OMX_TRUE ? "yes" : "no"),
+            dump_compression_format(s, imgdef->eCompressionFormat),
+            dump_color_format(s, imgdef->eColorFormat));
+        break;
+    default:
+        break;
+    }
+}
+
+
+static void append_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
+                          int *array_size, OMX_BUFFERHEADERTYPE **array,
+                          OMX_BUFFERHEADERTYPE *buffer)
+{
+    pthread_mutex_lock(mutex);
+    array[(*array_size)++] = buffer;
+    pthread_cond_broadcast(cond);
+    pthread_mutex_unlock(mutex);
+}
+
+static OMX_BUFFERHEADERTYPE *get_buffer(pthread_mutex_t *mutex, pthread_cond_t *cond,
+                                        int *array_size, OMX_BUFFERHEADERTYPE **array,
+                                        int wait)
+{
+    OMX_BUFFERHEADERTYPE *buffer;
+    pthread_mutex_lock(mutex);
+    if (wait) {
+        while (!*array_size)
+            pthread_cond_wait(cond, mutex);
+    }
+    if (*array_size > 0) {
+        buffer = array[0];
+        (*array_size)--;
+        memmove(&array[0], &array[1], (*array_size) * sizeof(OMX_BUFFERHEADERTYPE *));
+    } else {
+        buffer = NULL;
+    }
+    pthread_mutex_unlock(mutex);
+    return buffer;
+
+}
+
+static int OnPortOutputChanged(OMXCodecContext *s)
+{
+    OMX_ERRORTYPE err;
+    OMX_PARAM_PORTDEFINITIONTYPE portdef;
+    av_log(s->avctx, AV_LOG_INFO, "OnEventOutputChanged\n");
+
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex = s->out_port;
+    OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+
+    dump_portdef(s, &portdef);
+    //s->stride = portdef.format.image.nStride;
+    //s->plane_size = portdef.format.image.nSliceHeight;
+    s->num_out_buffers = portdef.nBufferCountActual;
+    err = OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->out_port, NULL);
+    s->out_buffer_headers = malloc(s->num_out_buffers * sizeof(OMX_BUFFERHEADERTYPE *));
+    for (int i = 0; i < s->num_out_buffers; i++) {
+        err = OMX_AllocateBuffer(s->handle, &s->out_buffer_headers[i],  s->out_port,  s, portdef.nBufferSize);
+    }
+
+    for (int i = 0; i < s->num_out_buffers; i++) {
+        err = OMX_FillThisBuffer(s->handle, s->out_buffer_headers[i]);
+    }
+    return 0 ;
+}
+
+static OMX_ERRORTYPE event_handler(OMX_HANDLETYPE component, OMX_PTR app_data, OMX_EVENTTYPE event,
+                                   OMX_U32 data1, OMX_U32 data2, OMX_PTR event_data)
+{
+    OMXCodecContext *s = app_data;
+    // This uses casts in the printfs, since OMX_U32 actually is a typedef for
+    // unsigned long in official header versions (but there are also modified
+    // versions where it is something else).
+    switch (event) {
+    case OMX_EventError:
+        pthread_mutex_lock(&s->state_mutex);
+        av_log(s->avctx, AV_LOG_ERROR, "OMX error %"PRIx32"\n", (uint32_t) data1);
+        s->error = data1;
+        pthread_cond_broadcast(&s->state_cond);
+        pthread_mutex_unlock(&s->state_mutex);
+        break;
+    case OMX_EventCmdComplete:
+        if (data1 == OMX_CommandStateSet) {
+            pthread_mutex_lock(&s->state_mutex);
+            s->state = data2;
+            av_log(s->avctx, AV_LOG_VERBOSE, "OMX state changed to %"PRIu32"\n", (uint32_t) data2);
+            pthread_cond_broadcast(&s->state_cond);
+            pthread_mutex_unlock(&s->state_mutex);
+        } else if (data1 == OMX_CommandPortDisable) {
+            av_log(s->avctx, AV_LOG_VERBOSE, "OMX port %"PRIu32" disabled\n", (uint32_t) data2);
+        } else if (data1 == OMX_CommandPortEnable) {
+            av_log(s->avctx, AV_LOG_VERBOSE, "OMX port %"PRIu32" enabled\n", (uint32_t) data2);
+        } else {
+            av_log(s->avctx, AV_LOG_VERBOSE, "OMX command complete, command %"PRIu32", value %"PRIu32"\n",
+                   (uint32_t) data1, (uint32_t) data2);
+        }
+        break;
+    case OMX_EventPortSettingsChanged:
+        av_log(s->avctx, AV_LOG_VERBOSE, "OMX port %"PRIu32" settings changed\n", (uint32_t) data1);
+        break;
+    default:
+        av_log(s->avctx, AV_LOG_VERBOSE, "OMX event %d %"PRIx32" %"PRIx32"\n",
+               event, (uint32_t) data1, (uint32_t) data2);
+        break;
+    }
+    pthread_mutex_lock(&s->state_mutex);
+
+    s->event = event;
+    s->state = data2;
+    s->cmd = data1;
+
+    pthread_cond_broadcast(&s->state_cond);
+    pthread_mutex_unlock(&s->state_mutex);
+
+    return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE empty_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                       OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecContext *s = app_data;
+    if (s->input_zerocopy) {
+        if (buffer->pAppPrivate) {
+            if (buffer->pOutputPortPrivate)
+                av_free(buffer->pAppPrivate);
+            else
+                av_frame_free((AVFrame **)&buffer->pAppPrivate);
+            buffer->pAppPrivate = NULL;
+        }
+    }
+    append_buffer(&s->input_mutex, &s->input_cond,
+                  &s->num_free_in_buffers, s->free_in_buffers, buffer);
+    return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE fill_buffer_done(OMX_HANDLETYPE component, OMX_PTR app_data,
+                                      OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecContext *s = app_data;
+    append_buffer(&s->output_mutex, &s->output_cond,
+                  &s->num_done_out_buffers, s->done_out_buffers, buffer);
+    return OMX_ErrorNone;
+}
+
+static const OMX_CALLBACKTYPE callbacks = {
+    event_handler,
+    empty_buffer_done,
+    fill_buffer_done
+};
+
+static av_cold int find_component(OMXContext *omx_context, void *logctx,
+                                  const char *role, char *str, int str_size)
+{
+    OMX_U32 i, num = 0;
+    char **components;
+    int ret = 0;
+
+#if CONFIG_OMX_RPI
+    if (av_strstart(role, "video_encoder.", NULL)) {
+        av_strlcpy(str, "OMX.broadcom.video_encode", str_size);
+        return 0;
+    }
+#endif
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, NULL);
+    if (!num) {
+        av_log(logctx, AV_LOG_WARNING, "No component for role %s found\n", role);
+        return AVERROR_ENCODER_NOT_FOUND;
+    }
+    components = av_mallocz_array(num, sizeof(*components));
+    if (!components)
+        return AVERROR(ENOMEM);
+    for (i = 0; i < num; i++) {
+        components[i] = av_mallocz(OMX_MAX_STRINGNAME_SIZE);
+        if (!components[i]) {
+            ret = AVERROR(ENOMEM);
+            goto end;
+        }
+    }
+    omx_context->ptr_GetComponentsOfRole((OMX_STRING) role, &num, (OMX_U8 **) components);
+    av_strlcpy(str, components[0], str_size);
+end:
+    for (i = 0; i < num; i++)
+        av_free(components[i]);
+    av_free(components);
+    return ret;
+}
+
+static av_cold int wait_for_state(OMXCodecContext *s, OMX_STATETYPE state)
+{
+    int ret = 0;
+    pthread_mutex_lock(&s->state_mutex);
+    while (s->state != state && s->error == OMX_ErrorNone)
+        pthread_cond_wait(&s->state_cond, &s->state_mutex);
+    if (s->error != OMX_ErrorNone)
+        ret = AVERROR_ENCODER_NOT_FOUND;
+    pthread_mutex_unlock(&s->state_mutex);
+    return ret;
+}
+
+static int wait_for_event(AVCodecContext *avctx, OMX_EVENTTYPE event, OMX_COMMANDTYPE cmd, OMX_STATETYPE state,
+                          int timeout)
+{
+    int ret = 0;
+    OMXCodecContext *s = avctx->priv_data;
+    pthread_mutex_lock(&s->state_mutex);
+    while ((s->state != state ||  s->cmd != cmd  || s->event != event) && s->error == OMX_ErrorNone) {
+        pthread_cond_wait(&s->state_cond, &s->state_mutex);
+    }
+    if (s->error != OMX_ErrorNone)
+        ret = -1;
+    pthread_mutex_unlock(&s->state_mutex);
+    return ret;
+}
+
+static av_cold int omx_component_init(AVCodecContext *avctx, const char *role)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    OMX_PARAM_COMPONENTROLETYPE role_params = { 0 };
+    OMX_PARAM_PORTDEFINITIONTYPE in_port_params = { 0 }, out_port_params = { 0 };
+
+    OMX_PARAM_PORTDEFINITIONTYPE portdef;
+    OMX_IMAGE_PARAM_PORTFORMATTYPE imagePortFormat;
+    OMX_PORT_PARAM_TYPE port;
+    OMX_IMAGE_PARAM_QFACTORTYPE qfactor;
+
+    OMX_ERRORTYPE err;
+    int i;
+
+    s->maxpts = 0;
+    s->version.s.nVersionMajor = 1;
+    s->version.s.nVersionMinor = 1;
+    s->version.s.nRevision     = 2;
+    err = s->omx_context->ptr_GetHandle(&s->handle, s->component_name, s, (OMX_CALLBACKTYPE *) &callbacks);
+    if (err != OMX_ErrorNone) {
+        av_log(s->avctx, AV_LOG_ERROR, "OMX_GetHandle(%s) failed: %x\n", s->component_name, err);
+        return -1;
+    }
+
+    INIT_STRUCT(port);
+    OMX_GetParameter(s->handle, OMX_IndexParamImageInit, &port);
+    if (port.nPorts != 2) {
+        return -1;
+    }
+
+    s->in_port = port.nStartPortNumber;
+    s->out_port = port.nStartPortNumber + 1;
+
+    err = OMX_SendCommand(s->handle, OMX_CommandPortDisable, s->in_port, NULL);
+    CHECK(err);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortDisable, s->in_port, TIMEOUT_MS);
+    err = OMX_SendCommand(s->handle, OMX_CommandPortDisable, s->out_port, NULL);
+    CHECK(err);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortDisable, s->out_port, TIMEOUT_MS);
+
+
+    memset((void *)&imagePortFormat, 0, sizeof(imagePortFormat));
+    INIT_STRUCT(imagePortFormat);
+
+    imagePortFormat.nPortIndex = s->in_port;
+    imagePortFormat.eCompressionFormat = OMX_IMAGE_CodingUnused;
+
+    OMX_SetParameter(s->handle, OMX_IndexParamImagePortFormat, &imagePortFormat);
+
+    s->stride = (avctx->width / 64 * 64) < avctx->width ? ((avctx->width / 64 + 1) * 64) : avctx->width;
+    s->stride_padding = s->stride - avctx->width;
+
+    memset((void *)&portdef, 0, sizeof(portdef));
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex =  s->in_port;
+
+    err = OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    CHECK(err);
+    int iBufferCount = portdef.nBufferCountActual;
+    int iBufferSize = portdef.nBufferSize;
+    portdef.nBufferAlignment = 64;
+    portdef.format.image.nFrameWidth = avctx->width;
+    portdef.format.image.nFrameHeight = avctx->height;
+    portdef.format.image.nStride = s->stride;
+    portdef.format.image.nSliceHeight = 0;
+    portdef.nBufferSize = s->stride * avctx->height * 3 / 2;
+    portdef.format.image.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
+    portdef.eDomain = OMX_PortDomainImage;
+
+    iBufferSize = portdef.nBufferSize;
+    err = OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    dump_portdef(s, &portdef);
+
+    memset((void *)&portdef, 0, sizeof(portdef));
+    INIT_STRUCT(portdef);
+    portdef.nPortIndex =  s->out_port;
+
+    OMX_GetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    portdef.format.image.nFrameWidth = avctx->width;
+    portdef.format.image.nFrameHeight = avctx->height;
+    portdef.format.image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+    portdef.nBufferSize = avctx->width * avctx->height * 3 / 2;
+    portdef.nBufferCountActual = 3;
+    OMX_SetParameter(s->handle, OMX_IndexParamPortDefinition, &portdef);
+    CHECK(err);
+    dump_portdef(s, &portdef);
+
+    //OMX_IMAGE_PARAM_QFACTORTYPE qfactor;
+    INIT_STRUCT(qfactor);
+    qfactor.nPortIndex = s->out_port;
+    err = OMX_GetParameter(s->handle, OMX_IndexParamQFactor, &qfactor);
+    CHECK(err);
+    qfactor.nPortIndex = s->out_port;
+    qfactor.nQFactor = s->QFactor;
+    err = OMX_SetParameter(s->handle, OMX_IndexParamQFactor, &qfactor);
+    CHECK(err);
+
+    OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet,  OMX_StateIdle, TIMEOUT_MS);
+
+    s->num_in_buffers = iBufferCount = 1;
+    s->in_buffer_headers = malloc(iBufferCount * sizeof(OMX_BUFFERHEADERTYPE *));
+    for (int i = 0; i < iBufferCount; i++) {
+        OMX_AllocateBuffer(s->handle, &s->in_buffer_headers[i],  s->in_port,  s, iBufferSize);
+    }
+    s->num_free_in_buffers = 0;
+    s->num_done_out_buffers = 0;
+    s->free_in_buffers    = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_in_buffers);
+    s->done_out_buffers   = av_mallocz(sizeof(OMX_BUFFERHEADERTYPE *) * s->num_out_buffers);
+    if (!s->free_in_buffers || !s->done_out_buffers)
+        return AVERROR(ENOMEM);
+    for (i = 0; i < s->num_in_buffers; i++)
+        s->free_in_buffers[s->num_free_in_buffers++] = s->in_buffer_headers[i];
+
+    s->num_out_buffers = 3;
+    s->out_buffer_headers = malloc(s->num_out_buffers * sizeof(OMX_BUFFERHEADERTYPE *));
+    for (int i = 0; i < s->num_out_buffers; i++) {
+        OMX_AllocateBuffer(s->handle, &s->out_buffer_headers[i],  s->out_port,  s, iBufferSize);
+    }
+
+    OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->in_port, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortEnable, s->in_port, TIMEOUT_MS);
+    //OMX_SendCommand(s->handle,OMX_CommandPortEnable, s->out_port, NULL);
+    //wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortEnable, s->out_port, TIMEOUT_MS);
+
+    err = OMX_SendCommand(s->handle,  OMX_CommandStateSet, OMX_StateExecuting, NULL);
+    CHECK(err);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandStateSet, OMX_StateExecuting, TIMEOUT_MS);
+    OMX_SendCommand(s->handle, OMX_CommandPortEnable, s->out_port, NULL);
+    wait_for_event(avctx, OMX_EventCmdComplete, OMX_CommandPortEnable, s->out_port, TIMEOUT_MS);
+    for (int i = 0; i < s->num_out_buffers; i++) {
+        err = OMX_FillThisBuffer(s->handle, s->out_buffer_headers[i]);
+    }
+
+    av_log(s->avctx, AV_LOG_INFO, "finish omx_component_init_encoder\n");
+    return 0;
+}
+
+static av_cold void cleanup(OMXCodecContext *s)
+{
+    int i, executing;
+
+    pthread_mutex_lock(&s->state_mutex);
+    executing = s->state == OMX_StateExecuting;
+    pthread_mutex_unlock(&s->state_mutex);
+
+    if (executing) {
+        OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
+        wait_for_state(s, OMX_StateIdle);
+        OMX_SendCommand(s->handle, OMX_CommandStateSet, OMX_StateLoaded, NULL);
+        for (i = 0; i < s->num_in_buffers; i++) {
+            OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                                           &s->num_free_in_buffers, s->free_in_buffers, 1);
+            if (s->input_zerocopy)
+                buffer->pBuffer = NULL;
+            OMX_FreeBuffer(s->handle, s->in_port, buffer);
+        }
+        for (i = 0; i < s->num_out_buffers; i++) {
+            OMX_BUFFERHEADERTYPE *buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                                           &s->num_done_out_buffers, s->done_out_buffers, 1);
+            OMX_FreeBuffer(s->handle, s->out_port, buffer);
+        }
+        wait_for_state(s, OMX_StateLoaded);
+    }
+    if (s->handle) {
+        s->omx_context->ptr_FreeHandle(s->handle);
+        s->handle = NULL;
+    }
+
+    omx_deinit(s->omx_context);
+    s->omx_context = NULL;
+    if (s->mutex_cond_inited) {
+        pthread_cond_destroy(&s->state_cond);
+        pthread_mutex_destroy(&s->state_mutex);
+        pthread_cond_destroy(&s->input_cond);
+        pthread_mutex_destroy(&s->input_mutex);
+        pthread_cond_destroy(&s->output_cond);
+        pthread_mutex_destroy(&s->output_mutex);
+        s->mutex_cond_inited = 0;
+    }
+    av_freep(&s->in_buffer_headers);
+    av_freep(&s->out_buffer_headers);
+    av_freep(&s->free_in_buffers);
+    av_freep(&s->done_out_buffers);
+    av_freep(&s->output_buf);
+}
+
+static av_cold int omx_encode_init(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    int ret = AVERROR_ENCODER_NOT_FOUND;
+    const char *role;
+    OMX_BUFFERHEADERTYPE *buffer;
+    OMX_ERRORTYPE err;
+
+    s->omx_context = omx_init(avctx, s->libname, s->libprefix);
+    if (!s->omx_context)
+        return AVERROR_ENCODER_NOT_FOUND;
+
+    pthread_mutex_init(&s->state_mutex, NULL);
+    pthread_cond_init(&s->state_cond, NULL);
+    pthread_mutex_init(&s->input_mutex, NULL);
+    pthread_cond_init(&s->input_cond, NULL);
+    pthread_mutex_init(&s->output_mutex, NULL);
+    pthread_cond_init(&s->output_cond, NULL);
+    s->mutex_cond_inited = 1;
+    s->avctx = avctx;
+    s->state = OMX_StateLoaded;
+    s->error = OMX_ErrorNone;
+
+    switch (avctx->codec->id) {
+    case AV_CODEC_ID_MJPEG:
+        role = "image_encoder.jpeg";
+        break;
+    default:
+        return AVERROR(ENOSYS);
+    }
+
+    if ((ret = find_component(s->omx_context, avctx, role, s->component_name, sizeof(s->component_name))) < 0)
+        goto fail;
+
+    av_log(avctx, AV_LOG_INFO, "Using %s\n", s->component_name);
+
+    if ((ret = omx_component_init(avctx, role)) < 0)
+        goto fail;
+#if 0
+    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+        while (1) {
+            buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                                &s->num_done_out_buffers, s->done_out_buffers, 1);
+            if (buffer->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
+                if ((ret = av_reallocp(&avctx->extradata,
+                                       avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
+                    avctx->extradata_size = 0;
+                    goto fail;
+                }
+                memcpy(avctx->extradata + avctx->extradata_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
+                avctx->extradata_size += buffer->nFilledLen;
+                memset(avctx->extradata + avctx->extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+            }
+            err = OMX_FillThisBuffer(s->handle, buffer);
+            if (err != OMX_ErrorNone) {
+                append_buffer(&s->output_mutex, &s->output_cond,
+                              &s->num_done_out_buffers, s->done_out_buffers, buffer);
+                av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+                ret = AVERROR_UNKNOWN;
+                goto fail;
+            }
+            if (avctx->codec->id == AV_CODEC_ID_H264) {
+                // For H.264, the extradata can be returned in two separate buffers
+                // (the videocore encoder on raspberry pi does this);
+                // therefore check that we have got both SPS and PPS before continuing.
+                int nals[32] = { 0 };
+                int i;
+                for (i = 0; i + 4 < avctx->extradata_size; i++) {
+                    if (!avctx->extradata[i + 0] &&
+                        !avctx->extradata[i + 1] &&
+                        !avctx->extradata[i + 2] &&
+                        avctx->extradata[i + 3] == 1) {
+                        nals[avctx->extradata[i + 4] & 0x1f]++;
+                    }
+                }
+                if (nals[H264_NAL_SPS] && nals[H264_NAL_PPS])
+                    break;
+            } else {
+                if (avctx->extradata_size > 0)
+                    break;
+            }
+        }
+    }
+#endif
+
+    return 0;
+fail:
+    return ret;
+}
+
+static int omx_line_copy(AVCodecContext *avctx, const AVFrame *frame, OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    memset(buffer->pBuffer, 0, s->stride * frame->height * 3 / 2);
+    for (int i = 0; i < frame->height; i++) {
+        memcpy(buffer->pBuffer + i * s->stride, frame->data[0] + i * frame->width, frame->width);
+    }
+    for (int i = 0; i < frame->height / 2; i++) {
+        memcpy(buffer->pBuffer + s->stride * frame->height + i * s->stride, frame->data[1] + +i * frame->width, frame->width);
+    }
+    return 0;
+}
+
+static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
+                            const AVFrame *frame, int *got_packet)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    int ret = 0;
+    OMX_BUFFERHEADERTYPE *buffer;
+    OMX_ERRORTYPE err;
+    int had_partial = 0;
+
+    if (frame) {
+        uint8_t *dst[4];
+        int linesize[4];
+        int need_copy;
+        buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                            &s->num_free_in_buffers, s->free_in_buffers, 1);
+
+        //buffer->nFilledLen = av_image_fill_arrays(dst, linesize, buffer->pBuffer, avctx->pix_fmt, s->stride, s->plane_size, 1);
+        buffer->nFilledLen = s->stride * frame->height * 3 / 2;
+        buffer->nAllocLen = buffer->nFilledLen;
+        buffer->nFlags = 0;
+#if 0
+        if (s->input_zerocopy) {
+            uint8_t *src[4] = { NULL };
+            int src_linesize[4];
+            av_image_fill_arrays(src, src_linesize, frame->data[0], avctx->pix_fmt, s->stride, s->plane_size, 1);
+            if (frame->linesize[0] == src_linesize[0] &&
+                frame->linesize[1] == src_linesize[1] &&
+                frame->linesize[2] == src_linesize[2] &&
+                frame->data[1] == src[1] &&
+                frame->data[2] == src[2]) {
+                // If the input frame happens to have all planes stored contiguously,
+                // with the right strides, just clone the frame and set the OMX
+                // buffer header to point to it
+                AVFrame *local = av_frame_clone(frame);
+                if (!local) {
+                    // Return the buffer to the queue so it's not lost
+                    append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+                    return AVERROR(ENOMEM);
+                } else {
+                    buffer->pAppPrivate = local;
+                    buffer->pOutputPortPrivate = NULL;
+                    buffer->pBuffer = local->data[0];
+                    need_copy = 0;
+                }
+            } else {
+                // If not, we need to allocate a new buffer with the right
+                // size and copy the input frame into it.
+                uint8_t *buf = NULL;
+                int image_buffer_size = av_image_get_buffer_size(avctx->pix_fmt, s->stride, s->plane_size, 1);
+                if (image_buffer_size >= 0)
+                    buf = av_malloc(image_buffer_size);
+                if (!buf) {
+                    // Return the buffer to the queue so it's not lost
+                    append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+                    return AVERROR(ENOMEM);
+                } else {
+                    buffer->pAppPrivate = buf;
+                    // Mark that pAppPrivate is an av_malloc'ed buffer, not an AVFrame
+                    buffer->pOutputPortPrivate = (void *) 1;
+                    buffer->pBuffer = buf;
+                    need_copy = 1;
+                    buffer->nFilledLen = av_image_fill_arrays(dst, linesize, buffer->pBuffer, avctx->pix_fmt, s->stride, s->plane_size, 1);
+                }
+            }
+        } else {
+            need_copy = 1;
+        }
+#endif
+        need_copy = 1;
+        if (need_copy) {
+            //av_image_copy(dst, linesize, (const uint8_t**) frame->data, frame->linesize, avctx->pix_fmt, avctx->width, avctx->height);
+            if (s->stride_padding == 0) {
+                memcpy(buffer->pBuffer, frame->data[0], frame->height * frame->width);
+                memcpy(buffer->pBuffer + frame->height * frame->width, frame->data[1], frame->height * frame->width / 2);
+            } else if (s->stride_padding > 0) {
+                omx_line_copy(avctx, frame, buffer);
+            } else {
+                av_log(avctx, AV_LOG_ERROR, "error stride padding size: %d\n", s->stride_padding);
+            }
+        }
+        buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;
+        buffer->nOffset = 0;
+        // Convert the timestamps to microseconds; some encoders can ignore
+        // the framerate and do VFR bit allocation based on timestamps.
+        buffer->nTimeStamp = to_omx_ticks(av_rescale_q(frame->pts, avctx->time_base, AV_TIME_BASE_Q));
+        if (frame->pict_type == AV_PICTURE_TYPE_I) {
+#if CONFIG_OMX_RPI
+            OMX_CONFIG_BOOLEANTYPE config = {0, };
+            INIT_STRUCT(config);
+            config.bEnabled = OMX_TRUE;
+            err = OMX_SetConfig(s->handle, OMX_IndexConfigBrcmVideoRequestIFrame, &config);
+            if (err != OMX_ErrorNone) {
+                av_log(avctx, AV_LOG_ERROR, "OMX_SetConfig(RequestIFrame) failed: %x\n", err);
+            }
+#else
+            OMX_CONFIG_INTRAREFRESHVOPTYPE config = {0, };
+            INIT_STRUCT(config);
+            config.nPortIndex = s->out_port;
+            config.IntraRefreshVOP = OMX_TRUE;
+            err = OMX_SetConfig(s->handle, OMX_IndexConfigVideoIntraVOPRefresh, &config);
+            if (err != OMX_ErrorNone) {
+                av_log(avctx, AV_LOG_ERROR, "OMX_SetConfig(IntraVOPRefresh) failed: %x\n", err);
+            }
+#endif
+        }
+        err = OMX_EmptyThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_EmptyThisBuffer failed: %x\n", err);
+            return AVERROR_UNKNOWN;
+        }
+    } else if (!s->eos_sent) {
+#if 1
+        buffer = get_buffer(&s->input_mutex, &s->input_cond,
+                            &s->num_free_in_buffers, s->free_in_buffers, 1);
+
+        buffer->nFilledLen = 0;
+        buffer->nFlags = OMX_BUFFERFLAG_EOS;
+        buffer->pAppPrivate = buffer->pOutputPortPrivate = NULL;
+        err = OMX_EmptyThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->input_mutex, &s->input_cond, &s->num_free_in_buffers, s->free_in_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_EmptyThisBuffer failed: %x\n", err);
+            return AVERROR_UNKNOWN;
+        }
+        s->eos_sent = 1;
+#endif
+    }
+
+    while (!*got_packet && ret == 0 && !s->got_eos) {
+        // If not flushing, just poll the queue if there's finished packets.
+        // If flushing, do a blocking wait until we either get a completed
+        // packet, or get EOS.
+        buffer = get_buffer(&s->output_mutex, &s->output_cond,
+                            &s->num_done_out_buffers, s->done_out_buffers,
+                            !frame || had_partial);
+        if (!buffer)
+            break;
+
+        if (buffer->nFlags & OMX_BUFFERFLAG_EOS)
+            s->got_eos = 1;
+
+        if (buffer->nFlags & OMX_BUFFERFLAG_CODECCONFIG && avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER && 0) {
+            if ((ret = av_reallocp(&avctx->extradata,
+                                   avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {
+                avctx->extradata_size = 0;
+                goto end;
+            }
+            memcpy(avctx->extradata + avctx->extradata_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
+            avctx->extradata_size += buffer->nFilledLen;
+            memset(avctx->extradata + avctx->extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+        } else {
+            if (!(buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) || !pkt->data) {
+                // If the output packet isn't preallocated, just concatenate everything in our
+                // own buffer
+                int newsize = s->output_buf_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE;
+                if ((ret = av_reallocp(&s->output_buf, newsize)) < 0) {
+                    s->output_buf_size = 0;
+                    goto end;
+                }
+                memcpy(s->output_buf + s->output_buf_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
+                s->output_buf_size += buffer->nFilledLen;
+                if (!s->output_buf_size) {
+                    av_freep(pkt);
+                    av_freep(&s->output_buf);
+                    s->output_buf_size = 0;
+                    goto end;
+                }
+                if (buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) {
+                    if ((ret = av_packet_from_data(pkt, s->output_buf, s->output_buf_size)) < 0) {
+                        av_freep(&s->output_buf);
+                        s->output_buf_size = 0;
+                        goto end;
+                    }
+                    s->output_buf = NULL;
+                    s->output_buf_size = 0;
+                }
+#if CONFIG_OMX_RPI
+                had_partial = 1;
+#endif
+            } else {
+                // End of frame, and the caller provided a preallocated frame
+                if ((ret = ff_alloc_packet2(avctx, pkt, s->output_buf_size + buffer->nFilledLen, 0)) < 0) {
+                    av_log(avctx, AV_LOG_ERROR, "Error getting output packet of size %d.\n",
+                           (int)(s->output_buf_size + buffer->nFilledLen));
+                    goto end;
+                }
+                memcpy(pkt->data, s->output_buf, s->output_buf_size);
+                memcpy(pkt->data + s->output_buf_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);
+                av_freep(&s->output_buf);
+                s->output_buf_size = 0;
+            }
+            if (buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) {
+                pkt->pts = av_rescale_q(from_omx_ticks(buffer->nTimeStamp), AV_TIME_BASE_Q, avctx->time_base);
+                // We don't currently enable B-frames for the encoders, so set
+                // pkt->dts = pkt->pts. (The calling code behaves worse if the encoder
+                // doesn't set the dts).
+                if (pkt->pts < s->maxpts) {
+                    pkt->pts = s->maxpts + 1;
+                }
+                s->maxpts = (s->maxpts > pkt->pts) ? s->maxpts : pkt->pts;
+                pkt->dts = pkt->pts;
+                if (buffer->nFlags & OMX_BUFFERFLAG_SYNCFRAME)
+                    pkt->flags |= AV_PKT_FLAG_KEY;
+                *got_packet = 1;
+            }
+        }
+end:
+        err = OMX_FillThisBuffer(s->handle, buffer);
+        if (err != OMX_ErrorNone) {
+            append_buffer(&s->output_mutex, &s->output_cond, &s->num_done_out_buffers, s->done_out_buffers, buffer);
+            av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
+            ret = AVERROR_UNKNOWN;
+        }
+    }
+    return ret;
+}
+
+static av_cold int omx_encode_end(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    cleanup(s);
+    return 0;
+}
+
+#define OFFSET(x) offsetof(OMXCodecContext, x)
+#define VDE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+#define VE  AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+static const AVOption options_jpeg[] = {
+    { "omx_libname", "OpenMAX library name", OFFSET(libname), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
+    { "omx_libprefix", "OpenMAX library prefix", OFFSET(libprefix), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VDE },
+    { "zerocopy", "Try to avoid copying input frames if possible", OFFSET(input_zerocopy), AV_OPT_TYPE_INT, { .i64 = CONFIG_OMX_RPI }, 0, 0, VE },
+    { "QFactor",  "Set the encoding QFactor", OFFSET(QFactor), AV_OPT_TYPE_INT,   {2}, 0, 10, VE},
+    { NULL }
+};
+
+
+
+static const enum AVPixelFormat omx_encoder_pix_fmts[] = {
+    AV_PIX_FMT_NV12, AV_PIX_FMT_NONE
+};
+
+
+static const AVClass omx_jpegenc_class = {
+    .class_name = "jpeg_omx",
+    .item_name  = av_default_item_name,
+    .option     = options_jpeg,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+AVCodec ff_jpeg_omx_encoder = {
+    .name             = "jpeg_omx",
+    .long_name        = NULL_IF_CONFIG_SMALL("OpenMAX IL JPEG video encoder"),
+    .type             = AVMEDIA_TYPE_VIDEO,
+    .id               = AV_CODEC_ID_MJPEG,
+    .priv_data_size   = sizeof(OMXCodecContext),
+    .init             = omx_encode_init,
+    .encode2          = omx_encode_frame,
+    .close            = omx_encode_end,
+    .pix_fmts         = omx_encoder_pix_fmts,
+    .capabilities     = AV_CODEC_CAP_DELAY,
+    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .priv_class       = &omx_jpegenc_class,
+};
+
+
diff --git a/libavcodec/vsi_vendor_ext.h b/libavcodec/vsi_vendor_ext.h
new file mode 100644
index 0000000..5c281de
--- /dev/null
+++ b/libavcodec/vsi_vendor_ext.h
@@ -0,0 +1,797 @@
+/*------------------------------------------------------------------------------
+--       Copyright (c) 2015-2017, VeriSilicon Inc. All rights reserved        --
+--                                                                            --
+-- This software is confidential and proprietary and may be used only as      --
+--   expressly authorized by VeriSilicon in a written licensing agreement.    --
+--                                                                            --
+--         This entire notice must be reproduced on all copies                --
+--                       and may not be removed.                              --
+--                                                                            --
+--------------------------------------------------------------------------------
+-- Redistribution and use in source and binary forms, with or without         --
+-- modification, are permitted provided that the following conditions are met:--
+--   * Redistributions of source code must retain the above copyright notice, --
+--       this list of conditions and the following disclaimer.                --
+--   * Redistributions in binary form must reproduce the above copyright      --
+--       notice, this list of conditions and the following disclaimer in the  --
+--       documentation and/or other materials provided with the distribution. --
+--   * Neither the names of Google nor the names of its contributors may be   --
+--       used to endorse or promote products derived from this software       --
+--       without specific prior written permission.                           --
+--------------------------------------------------------------------------------
+-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"--
+-- AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  --
+-- IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE --
+-- ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  --
+-- LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR        --
+-- CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF       --
+-- SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   --
+-- INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    --
+-- CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    --
+-- ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE --
+-- POSSIBILITY OF SUCH DAMAGE.                                                --
+--------------------------------------------------------------------------------
+------------------------------------------------------------------------------*/
+
+#ifndef _VSI_VENDOR_EXT_H_
+#define _VSI_VENDOR_EXT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <OMX_Index.h>
+
+/* Second view frame flag:
+ * This flag is set when the buffer content contains second view frame from MVC stream
+ *  @ingroup buf
+ */
+#define OMX_BUFFERFLAG_SECOND_VIEW      0x00010000
+
+/* VP8 temporal layer frame flags:
+ * One of these flags is set when the buffer contains encoded VP8 temporal layer frame
+ *  @ingroup buf
+ */
+#define OMX_BUFFERFLAG_BASE_LAYER       0x00020000
+#define OMX_BUFFERFLAG_FIRST_LAYER      0x00040000
+#define OMX_BUFFERFLAG_SECOND_LAYER     0x00080000
+#define OMX_BUFFERFLAG_THIRD_LAYER      0x00100000
+
+/* Struct for allocated buffer data. Carried in pInputPortPrivate */
+typedef struct ALLOC_PRIVATE {
+    OMX_U8* pBufferData;                // Virtual address of the buffer
+    OMX_U64 nBusAddress;                // Physical address of the buffer
+    OMX_U32 nBufferSize;                // Allocated size
+} ALLOC_PRIVATE;
+
+/** Structure for RFC (reference frame compression) table data */
+typedef struct RFC_TABLE {
+    OMX_U8* pLumaBase;
+    OMX_U64 nLumaBusAddress;
+    OMX_U8* pChromaBase;
+    OMX_U64 nChromaBusAddress;
+} RFC_TABLE;
+
+/* Struct for output buffer data. Carried in pOutputPortPrivate */
+typedef struct OUTPUT_BUFFER_PRIVATE {
+    OMX_U8* pLumaBase;                  // Virtual address of the luminance buffer
+    OMX_U64 nLumaBusAddress;            // Physical address of the luminance buffer
+    OMX_U32 nLumaSize;                  // Size of the luminance data
+    OMX_U8* pChromaBase;                // Virtual address of the chrominance buffer
+    OMX_U64 nChromaBusAddress;          // Physical address of the chrominance buffer
+    OMX_U32 nChromaSize;                // Size of the chrominance data
+    RFC_TABLE sRfcTable;                // RFC table data (G2 only)
+    OMX_U32 nBitDepthLuma;              // Luma component valid bit depth
+    OMX_U32 nBitDepthChroma;            // Chroma component valid bit depth
+    OMX_U32 nFrameWidth;                // Picture width in pixels
+    OMX_U32 nFrameHeight;               // Picture height in pixels
+    OMX_U32 nStride;                    // Picture stride in bytes
+    OMX_U32 nPicId[2];                  // Identifier of the picture in decoding order
+                                        // For H264 interlace stream, nPicId[0]/nPicId[1] are used for top/bottom field */
+    OMX_BOOL realloc;
+    OMX_BOOL singleField;               // Flag to indicate single field in output buffer
+} OUTPUT_BUFFER_PRIVATE;
+
+typedef enum OMX_INDEXVSITYPE {
+    OMX_IndexVsiStartUnused = OMX_IndexVendorStartUnused + 0x00100000,
+    OMX_IndexParamVideoMvcStream,
+    OMX_IndexConfigVideoIntraArea,
+    OMX_IndexConfigVideoRoiArea,
+    OMX_IndexConfigVideoRoiDeltaQp,
+    OMX_IndexConfigVideoAdaptiveRoi,
+    OMX_IndexConfigVideoVp8TemporalLayers,
+    OMX_IndexParamVideoHevc,               /**< reference: OMX_VIDEO_PARAM_HEVCTYPE */
+    OMX_IndexParamVideoVp9,                /**< reference: OMX_VIDEO_PARAM_VP9TYPE */
+    OMX_IndexParamVideoConfig,
+    OMX_IndexParamVideoCodecFormat,        /*which encoding type is selected in  vc8000e combined encoding system in which one of avc, hevc or av1 can be selected*/
+
+    OMX_IndexConfigVideoIPCMArea,
+    OMX_IndexParamVideoAvcExt,             /* AVC encoding parameters extention, refer to OMX_VIDEO_PARAM_AVCEXTTYPE */
+    OMX_IndexParamBufferMode,
+    OMX_IndexParamCompressionMode,
+} OMX_INDEXVSITYPE;
+
+typedef enum OMX_VIDEO_CODINGVSITYPE {
+    OMX_VIDEO_CodingVsiStartUnused = OMX_VIDEO_CodingVendorStartUnused + 0x00100000,
+    OMX_VIDEO_CodingSORENSON,
+    OMX_VIDEO_CodingDIVX,
+    OMX_VIDEO_CodingDIVX3,
+    OMX_VIDEO_CodingVP6,
+    OMX_VIDEO_CodingAVS,
+    OMX_VIDEO_CodingHEVC,
+    OMX_VIDEO_CodingVP9,
+    OMX_VIDEO_CodingAVS2,
+
+    OMX_VIDEO_CodingAV1
+} OMX_VIDEO_CODINGVSITYPE;
+
+typedef enum OMX_COLOR_FORMATVSITYPE {
+    OMX_COLOR_FormatVsiStartUnused = OMX_COLOR_FormatVendorStartUnused + 0x00100000,
+    OMX_COLOR_FormatYUV411SemiPlanar,
+    OMX_COLOR_FormatYUV411PackedSemiPlanar,
+    OMX_COLOR_FormatYUV440SemiPlanar,
+    OMX_COLOR_FormatYUV440PackedSemiPlanar,
+    OMX_COLOR_FormatYUV444SemiPlanar,
+    OMX_COLOR_FormatYUV444PackedSemiPlanar,
+    OMX_COLOR_FormatYUV420SemiPlanar4x4Tiled,   /* VC8000D tiled format */
+    OMX_COLOR_FormatYUV420SemiPlanarP010        /* P010 format */
+
+    , OMX_COLOR_FormatYUV420SemiPlanarVU        /* NV21*/
+    , OMX_COLOR_Format16bitBGR555               /* 15-bit RGB 16bpp */
+} OMX_COLOR_FORMATVSITYPE;
+
+/** Structure for configuring H.264 MVC mode */
+typedef struct OMX_VIDEO_PARAM_MVCSTREAMTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bIsMVCStream;
+} OMX_VIDEO_PARAM_MVCSTREAMTYPE;
+
+/** Structure for configuring Intra area for 8290/H1/H2 encoder */
+typedef struct OMX_VIDEO_CONFIG_INTRAAREATYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_U32 nTop;       /* Top mb row inside area [0..heightMbs-1]      */
+    OMX_U32 nLeft;      /* Left mb row inside area [0..widthMbs-1]      */
+    OMX_U32 nBottom;    /* Bottom mb row inside area [top..heightMbs-1] */
+    OMX_U32 nRight;     /* Right mb row inside area [left..widthMbs-1]  */
+} OMX_VIDEO_CONFIG_INTRAAREATYPE;
+
+/** Structure for configuring ROI area for 8290/H1/H2 encoder */
+typedef struct OMX_VIDEO_CONFIG_ROIAREATYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_U32 nArea;      /* ROI area number [1..2]                       */
+    OMX_U32 nTop;       /* Top mb row inside area [0..heightMbs-1]      */
+    OMX_U32 nLeft;      /* Left mb row inside area [0..widthMbs-1]      */
+    OMX_U32 nBottom;    /* Bottom mb row inside area [top..heightMbs-1] */
+    OMX_U32 nRight;     /* Right mb row inside area [left..widthMbs-1]  */
+} OMX_VIDEO_CONFIG_ROIAREATYPE;
+
+/** Structure for configuring IPCM area for VC8000E encoder */
+typedef struct OMX_VIDEO_CONFIG_IPCMAREATYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_U32 nArea;      /* IPCM area number [1..2]                       */
+    OMX_U32 nTop;       /* Top mb row inside area [0..heightMbs-1]      */
+    OMX_U32 nLeft;      /* Left mb row inside area [0..widthMbs-1]      */
+    OMX_U32 nBottom;    /* Bottom mb row inside area [top..heightMbs-1] */
+    OMX_U32 nRight;     /* Right mb row inside area [left..widthMbs-1]  */
+} OMX_VIDEO_CONFIG_IPCMAREATYPE;
+
+/** Structure for configuring ROI Delta QP for 8290/H1/H2 encoder */
+typedef struct OMX_VIDEO_CONFIG_ROIDELTAQPTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nArea;      /* ROI area number [1..2]               */
+    OMX_S32 nDeltaQP;   /* QP delta value [-127..0] for VP8     */
+                        /*                [-15..0]  for H264    */
+} OMX_VIDEO_CONFIG_ROIDELTAQPTYPE;
+
+/** Structure for configuring Adaptive ROI for H1 encoder */
+typedef struct OMX_VIDEO_CONFIG_ADAPTIVEROITYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nAdaptiveROI;       /* QP delta for adaptive ROI [-51..0]       */
+    OMX_S32 nAdaptiveROIColor;  /* Color temperature for the Adaptive ROI   */
+                                /* -10=2000K, 0=3000K, 10=5000K             */
+} OMX_VIDEO_CONFIG_ADAPTIVEROITYPE;
+
+/** Structure for configuring VP8 temporal layers */
+typedef struct OMX_VIDEO_CONFIG_VP8TEMPORALLAYERTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nBaseLayerBitrate;  /* Bits per second [10000..40000000]    */
+    OMX_U32 nLayer1Bitrate;     /* Bits per second [10000..40000000]    */
+    OMX_U32 nLayer2Bitrate;     /* Bits per second [10000..40000000]    */
+    OMX_U32 nLayer3Bitrate;     /* Bits per second [10000..40000000]    */
+} OMX_VIDEO_CONFIG_VP8TEMPORALLAYERTYPE;
+
+typedef enum OMX_VIDEO_AVCEXTLEVELTYPE {
+    OMX_VIDEO_AVCLevelUnused = OMX_VIDEO_AVCLevelVendorStartUnused + 0x00100000,
+    OMX_VIDEO_AVCLevel52,   
+    OMX_VIDEO_AVCLevel60,
+    OMX_VIDEO_AVCLevel61,
+    OMX_VIDEO_AVCLevel62
+} OMX_VIDEO_AVCEXTLEVELTYPE;
+
+
+typedef enum OMX_VIDEO_HEVCPROFILETYPE {
+    OMX_VIDEO_HEVCProfileMain     = 0x01,   /**< Main profile */
+    OMX_VIDEO_HEVCProfileMain10   = 0x02,   /**< Main10 profile */
+    OMX_VIDEO_HEVCProfileMainStillPicture  = 0x04,   /**< Main still picture profile */
+    OMX_VIDEO_HEVCProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_HEVCProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_HEVCProfileMax      = 0x7FFFFFFF
+} OMX_VIDEO_HEVCPROFILETYPE;
+
+typedef enum OMX_VIDEO_HEVCLEVELTYPE {
+    OMX_VIDEO_HEVCLevel1   = 0x01,     /**< Level 1   */
+    OMX_VIDEO_HEVCLevel2   = 0x02,     /**< Level 2   */
+    OMX_VIDEO_HEVCLevel21  = 0x04,     /**< Level 2.1 */
+    OMX_VIDEO_HEVCLevel3   = 0x08,     /**< Level 3   */
+    OMX_VIDEO_HEVCLevel31  = 0x10,     /**< Level 3.1 */
+    OMX_VIDEO_HEVCLevel4   = 0x20,     /**< Level 4   */
+    OMX_VIDEO_HEVCLevel41  = 0x40,     /**< Level 4.1 */
+    OMX_VIDEO_HEVCLevel5   = 0x80,     /**< Level 5   */
+    OMX_VIDEO_HEVCLevel51  = 0x100,    /**< Level 5.1 */
+    OMX_VIDEO_HEVCLevel52  = 0x200,    /**< Level 5.2 */
+    OMX_VIDEO_HEVCLevel6   = 0x400,    /**< Level 6   */
+    OMX_VIDEO_HEVCLevel61  = 0x800,    /**< Level 6.1 */
+    OMX_VIDEO_HEVCLevel62  = 0x1000,   /**< Level 6.2 */
+    OMX_VIDEO_HEVCLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_HEVCLevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_HEVCLevelMax = 0x7FFFFFFF
+} OMX_VIDEO_HEVCLEVELTYPE;
+
+/**
+ * AVC Encoder VSI Extension params
+ *
+ * STRUCT MEMBERS:
+ *  nSize                     : Size of the structure in bytes
+ *  nVersion                  : OMX specification version information
+ *  nPortIndex                : Port that this structure applies to
+ *  nBitDepthLuma             : Luma component valid bit depth.
+ *  nBitDepthChroma           : Chroma component valid bit depth.
+ *  gopSize                   : GOP Size, [0..8], 0 for adaptive GOP size; 1~7 for fixed GOP size
+ *  hrdCpbSize                : HRD Coded Picture Buffer size in bits. Buffer size used by the HRD model.
+ *  firstPic                  : First picture of input file to encode.
+ *  lastPic                   : Last picture of input file to encode.
+ * coded chroma_format_idc
+ *  codedChromaIdc            : Specify coded chroma format idc.[1]. 0 -400, 1- 420, 2- 422
+ 
+ * Adaptive Quantization
+ *  aq_mode                   : Mode for Adaptive Quantization - 0:none 1:uniform AQ 2:auto variance 3:auto variance with bias to dark scenes. Default 0
+ *  aq_strength               : Reduces blocking and blurring in flat and textured areas (0 to 3.0). Default 1.00
+ *  writeReconToDDR           : HW write recon to DDR or not if it's pure I-frame encoding
+ *  TxTypeSearchEnable        : av1 tx type search 1=enable 0=disable, enabled by default
+
+ *  
+ *  PsyFactor                 : Specify 0..4 Weight of psycho-visual encoding.
+                                    0 = disable psy-rd.
+                                    1..4 = encode psy-rd, and set strength of psyFactor, larger favor better subjective quality.
+
+ *  meVertSearchRange         : Specify ME vertical search range.
+ *  layerInRefIdcEnable       : Enable/Disable h264 2bit nal_ref_idc
+
+ *  rdoLevel                  : Programable hardware RDO Level [1..3].
+ *  crf                       : Specify constant rate factor mode, working with look-ahead turned on.
+                              :     [-1..51], -1=disable.
+                              :     CRF mode is to keep a certain level of quality based on crf value, working as constant QP with complexity rate control.
+                              :     CRF adjusts frame level QP within range of crf constant +-3 based on frame complexity. 
+                              :     CRF will disable VBR mode if both enabled.
+ * preset                     : Specify preset parameter to trade off performance and compression efficiency. 0...4 for HEVC. 0..1 for H264.
+ */
+typedef struct OMX_VIDEO_PARAM_AVCEXTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+
+    OMX_U32 preset;         /* 0...4 for HEVC. 0..1 for H264. Trade off performance and compression efficiency */
+
+    OMX_U32 nBitDepthLuma;
+    OMX_U32 nBitDepthChroma;
+
+    int vbr;
+    OMX_S32 qpMinI;
+    OMX_S32 qpMaxI;
+    OMX_S32 qpMinPB;
+    OMX_S32 qpMaxPB;
+    OMX_U32 hrdCpbSize;
+    OMX_S32 intraQpDelta;
+
+    OMX_S32 ctbRc;
+    OMX_S32 blockRCSize;
+    OMX_S32 tolCtbRcInter;
+    OMX_S32 tolCtbRcIntra;
+
+    /*rerference frame compression*/
+    int rfcEnable;
+
+    OMX_BOOL bLowLatencyEncoding;
+
+    OMX_U32 gopSize;
+
+    OMX_U32 exp_of_input_alignment;
+    OMX_S32 firstPic;
+    OMX_S32 lastPic;
+
+    OMX_U32 rdoLevel;
+    OMX_U32 codedChromaIdc; // 0: 400, 1: 420, 2: 422
+    OMX_S32 crf;             /*CRF constant [0,51]*/
+
+    /* Extension for CL244132*/
+    /*MMU*/
+    int mmuEnable;
+
+    /*external SRAM*/
+    OMX_U32 extSramLumHeightBwd;
+    OMX_U32 extSramChrHeightBwd;
+    OMX_U32 extSramLumHeightFwd;
+    OMX_U32 extSramChrHeightFwd;
+
+    /* AXI alignment */
+    OMX_U32 AXIAlignment; // bit[31:28] AXI_burst_align_wr_common
+                      // bit[27:24] AXI_burst_align_wr_stream
+                      // bit[23:20] AXI_burst_align_wr_chroma_ref
+                      // bit[19:16] AXI_burst_align_wr_luma_ref
+                      // bit[15:12] AXI_burst_align_rd_common
+                      // bit[11: 8] AXI_burst_align_rd_prp
+                      // bit[ 7: 4] AXI_burst_align_rd_ch_ref_prefetch
+                      // bit[ 3: 0] AXI_burst_align_rd_lu_ref_prefetch
+
+    /* Adaptive Quantization */
+    OMX_U32 aq_mode; /* Mode for Adaptive Quantization - 0:none 1:uniform AQ 2:auto variance 3:auto variance with bias to dark scenes. Default 0 */
+    OMX_U32 aq_strength; /* Reduces blocking and blurring in flat and textured areas (0 to 3.0). Default 1.00 */
+    OMX_U32 writeReconToDDR; /*HW write recon to DDR or not if it's pure I-frame encoding*/
+    OMX_U32 TxTypeSearchEnable; /*av1 tx type search 1=enable 0=disable, enabled by default*/
+
+    /*----*/
+    OMX_U32 PsyFactor;
+    OMX_U32 meVertSearchRange;
+	OMX_U32 layerInRefIdcEnable;
+} OMX_VIDEO_PARAM_AVCEXTTYPE;
+
+/**
+ * HEVC params
+ *
+ * STRUCT MEMBERS:
+ *  nSize                     : Size of the structure in bytes
+ *  nVersion                  : OMX specification version information
+ *  nPortIndex                : Port that this structure applies to
+ *  eProfile                  :
+ *  eLevel                    :
+ *  nPFrames                  : Number of P frames between each I frame
+ *  nBFrames                  : Number of B frames between each I frame
+
+
+ * Parameters related to Input frame
+ *  exp_of_input_alignment    : Alignment value of input frame buffer 0, [4-12]
+                                   Base address of input frame buffer and each line are aligned to 2^exp_of_input_alignmeny.
+ *  fieldOrder                : Specify interlaced field order, 0=bottom first, 1=top first.
+
+
+ * Parameters affecting the output stream and encoding tools:
+ *  nBitDepthLuma             : Luma component valid bit depth.
+ *  nBitDepthChroma           : Chroma component valid bit depth.
+ *  byteStream                : Stream type. 0: NAL units; 1: byte stream according to HEVC Standard Annex B.
+ *  videoRange                : Specify video signal sample range in encoded stream.
+                                    0 - Y range in [16..235]; Cb, Cr in [16..240]; 1 - Y, Cb, Cr range in [0..255].
+ *  enableCabac               : CAVLC (0) or CABAC (1)
+ *  bCabacInitFlag            : Initialization value for CABAC.
+ *  sliceSize                 : slice size in number of CTU rows.  
+                                    0 to encode each picture in one slice; Other value [1..height/ctu_size] specify CTU rows to encode each slice.
+ *  bEnableSAO:               : Enable/disable arbitrary slice ordering.
+ *  nTcOffset                 : Specify deblocking filter tc offset [-6..6]
+ *  nBetaOffset               : Specify deblocking filter beta offset[-6..6]
+ *  bEnableDeblockOverride    : Enable/disable deblock override between slice.
+ *  bDeblockOverride          : Indicate whether deblock override between slices.
+ *  num_tile_columns          : HEVC Tile setting: specify num of tile columns.
+ *  num_tile_rows             : HEVC Tile setting: specify num of tile rows.
+ *  loop_filter_across_tiles_enabled_flag     : HEVC Tile setting: enable/disable loop-filter across filter.
+ *  bEnableScalingList        : Use average scaling list (1) or default scaling list (0).
+ *  RpsInSliceHeader          : Encode rps in the slice header or not.
+
+
+ * Parameters affecting GOP pattern, rate control and output stream bitrate
+ *  intraPicRate              : Intra-picture rate in frames.
+ *  tolMovingBitRate          : Specify percent tolerance over target bitrate of moving bit rate [10..2000].
+ *  monitorFrames             : Specify how many frames will be monitored for moving bit rate [10..120]
+ *  bitVarRangeI              : Specify percent variations over average bits per frame for I frame. [10..10000] for VC8000E, [10..2000] for H2v4.1.
+ *  bitVarRangeP              : Specify percent variations over average bits per frame for P frame. [10..10000] for VC8000E, [10..2000] for H2v4.1.
+ *  bitVarRangeB              : Specify percent variations over average bits per frame for B frame. [10..10000] for VC8000E, [10..2000] for H2v4.1.
+ *  staticSceneIbitPercent    : Specify I frame bits percent of bitrate in static scene [0..100].
+ *  smoothPsnrInGOP           : Enable/Disable Smooth PSNR for frames in one GOP.
+ *  ctbRc                     : CTB QP adjustment mode for Rate Control and Subjective Quality. [0..1] for H2, [0..3] for VC8000E.
+ *  blockRCSize               : Specify unit size of block Rate control. 0: 64x64, 1: 32x32, 2: 16x16
+ *  rcQpDeltaRange            : Specify Max absolute value of CU/MB QP delta relative to frame QP in CTB RC.
+ *  rcBaseMBComplexity        : Specify MB complexity base in CTB QP adjustment for Subjective Quality [0..31].
+ *  tolCtbRcInter             : Specify tolerance of Ctb Rate Control for INTER frames.
+ *  tolCtbRcIntra             : Specify tolerance of Ctb Rate Control for INTRA frames.
+ *  ctbRowQpStep              : Specify the maximum accumulated QP adjustment step per CTB Row allowed by Ctb Rate Control
+ *  picQpDeltaMin             : Specify minimum value of QP delta relative to previous QP.
+ *  picQpDeltaMax             : Specify maximum value of QP delta relative to previous QP.
+ *  hrdCpbSize                : HRD Coded Picture Buffer size in bits. Buffer size used by the HRD model.
+ *  bitrateWindow             : Specify bit rate window length in frames [1..300].
+ *  gopSize                   : GOP Size [0..8]. 0 for adaptive GOP size; 1~7 for fixed GOP size.
+ *  ltrInterval               : Specify long term reference interval.
+ *  longTermGapOffset         : Specify the first frame after LTR that uses the LTR as reference.
+ *  longTermGap               : Specify the POC delta between two consecutive frames that use the same LTR as reference.
+ *  longTermQpDelta           : Specify QP delta for frame using LTR.
+ *  gopLowdelay               : Use default low delay GOP configuration or not.
+ *  picSkip                   : Enable/Disable picture skip rate control. Invalid for B-Frame encoding.
+ *  intraQpDelta              : Specify Intra QP delta value [-51..51].
+ *  fixedIntraQp              : Specify fixed Intra QP [0..51]. 0: disable.
+ *  chromaQpOffset            : Specify chroma QP offset [-12..12]
+ *  vbr                       : Enable/Disable Variable Bit Rate Control by qpMin.
+ *  gdrDuration               : Specify how many frames it will take to do GDR. 0: disable.
+
+
+ * Parameters affecting coding
+ *  cirStart                  : Specify start for Cyclic Intra Refresh
+ *  cirInterval               : Specify interval for Cyclic Intra Refresh
+ *  ipcmMapEnable             : Enable/Disable the IPCM Map.
+ *  roiMapDeltaQpBlockUnit    : Set the DeltaQp block size for ROI DeltaQp map file [0..3]. 
+                                    0-64x64,1-32x32,2-16x16,3-8x8
+ *  roiMapDeltaQpEnable       : Enable/disable the QP delta for ROI regions in the frame. 
+ *  RoiQpDelta_ver            : ROI Qp Delta map version number [0..3]. Valid only when roiMapInfoBinFile is enabled.
+
+
+ * Parameters affecting coding and performance
+ *  rdoLevel                  : Programable hardware RDO Level [1..3].
+ *  enableRdoQuant            : Enable/Disable RDO Quantization.
+
+
+ * Parameters affecting reporting
+ *  ssim                      : Enable (1) or Disable (0) SSIM calculation.
+ *  cuInfoVersion             : cu info dump version.
+ *  vui_timing_info_enable    : Enable/Disable writing VUI timing info in SPS.
+ *  hashtype                  : Specify hash type for frame data hash reporting. 0: disable, 1: crc32, 2: checksum32.
+ 
+
+ * Parameters affecting stream multi-segment output
+ *  streamMultiSegmentMode    : Stream multi-segment mode control[0..2]. 
+ *  streamMultiSegmentAmount  : The total amount of segments to control loop-back/SW handshaking/IRQ.
+
+
+ * Parameters affecting noise reduction
+ *  noiseReductionEnable      : Enable/disable noise reduction
+ *  noiseLow                  : Specify minimum noise value [1..30]
+ *  noiseFirstFrameSigma      : Specify noise estimation for start frames [1..30]
+
+ 
+ * HDR10 Config               
+ *  hdr10_display_enable      : Enable/Disable display color volume SEI message. 
+ *  hdr10_dx0                 : Component 0 normalized x chromaticity coordinates
+ *  hdr10_dy0                 : Component 0 normalized y chromaticity coordinates
+ *  hdr10_dx1                 : Component 1 normalized x chromaticity coordinates
+ *  hdr10_dy1                 : Component 1 normalized y chromaticity coordinates
+ *  hdr10_dx2                 : Component 2 normalized x chromaticity coordinates
+ *  hdr10_dy2                 : Component 2 normalized y chromaticity coordinates
+ *  hdr10_wx                  : White point normalized x chromaticity coordinates
+ *  hdr10_wy                  : White point normalized y chromaticity coordinates
+ *  hdr10_maxluma             : Nominal maximum display luminance
+ *  hdr10_minluma             : Nominal minimum display luminance
+ *  hdr10_lightlevel_enable   : Enable/Disable light level
+ *  hdr10_maxlight            : Specify max content light level
+ *  hdr10_avglight            : Specify  picture average light level
+ *  hdr10_color_enable        : Enable/Disable color description
+ *  hdr10_primary             : Index of chromaticity coordinates in Table E.3 in HEVC spec.
+ *  hdr10_transfer            : Specify the reference opto-electronic transfer characteristic function of the source picture in Table E.4 in HEVC spec.
+ *  hdr10_matrix              : Specify index of matrix coefficients used in deriving luma and chroma signals 
+                                    from the green, blue, and red or Y, Z, and X primaries in Table E.5 in HEVC spec.
+ 
+ *  firstPic                  : Specify the first picture number of input clip to encode.
+ *  lastPic                   : Specify the last picture number of input clip to encode.
+
+ *  nRefFrames                : Max number of reference frames to use for inter motion search (1-16) 
+                                    Valid for H2 only, obsolete for H2v4.1, VC8000E.
+ *  bStrongIntraSmoothing     : Enable/disable HEVC IntraTU32x32 strong intra smoothing filter.
+ *  pcm_loop_filter_disabled_flag             : Disable / Enable deblock filter for IPCM. 1-Disable, 0-Enable.
+
+ *Extensions for CL244132
+ * Parameters for MMU control
+ *  mmuEnable                 : Enable/disable MMU
+ *  
+ * Parameters for external SRAM
+ *  extSramLumHeightBwd       : 0=no external SRAM, 1..16=The number of line count is 4*extSramLumHeightBwd. [hevc:16,h264:12]
+ *  extSramChrHeightBwd       : 0=no external SRAM, 1..16=The number of line count is 4*extSramChrHeightBwd. [hevc:8,h264:6]
+ *  extSramLumHeightFwd       : 0=no external SRAM, 1..16=The number of line count is 4*extSramLumHeightFwd. [hevc:16,h264:12]
+ *  extSramChrHeightFwd       : 0=no external SRAM, 1..16=The number of line count is 4*extSramChrHeightFwd. [hevc:8,h264:6]
+ 
+ * Parameters for AXI alignment
+ *  AXIAlignment              : AXI alignment setting (in hexadecimal format).
+                              : bit[31:28] AXI_burst_align_wr_common
+                              : bit[27:24] AXI_burst_align_wr_stream
+                              : bit[23:20] AXI_burst_align_wr_chroma_ref
+                              : bit[19:16] AXI_burst_align_wr_luma_ref
+                              : bit[15:12] AXI_burst_align_rd_common
+                              : bit[11: 8] AXI_burst_align_rd_prp
+                              : bit[ 7: 4] AXI_burst_align_rd_ch_ref_prefetch
+                              : bit[ 3: 0] AXI_burst_align_rd_lu_ref_prefetch
+ 
+ * coded chroma_format_idc
+ *  codedChromaIdc            : Specify coded chroma format idc.[1]. 0 -400, 1- 420, 2- 422
+ 
+ * Adaptive Quantization
+ *  aq_mode                   : Mode for Adaptive Quantization - 0:none 1:uniform AQ 2:auto variance 3:auto variance with bias to dark scenes. Default 0
+ *  aq_strength               : Reduces blocking and blurring in flat and textured areas (0 to 3.0). Default 1.00
+ *  writeReconToDDR           : HW write recon to DDR or not if it's pure I-frame encoding
+ *  TxTypeSearchEnable        : av1 tx type search 1=enable 0=disable, enabled by default
+
+ *  
+ *  PsyFactor                 : Specify 0..4 Weight of psycho-visual encoding.
+                                    0 = disable psy-rd.
+                                    1..4 = encode psy-rd, and set strength of psyFactor, larger favor better subjective quality.
+
+ *  meVertSearchRange         : Specify ME vertical search range.
+ *  layerInRefIdcEnable       : Enable/Disable h264 2bit nal_ref_idc
+
+ *  crf                       : Specify constant rate factor mode, working with look-ahead turned on.
+                              :     [-1..51], -1=disable.
+                              :     CRF mode is to keep a certain level of quality based on crf value, working as constant QP with complexity rate control.
+                              :     CRF adjusts frame level QP within range of crf constant +-3 based on frame complexity. 
+                              :     CRF will disable VBR mode if both enabled.
+ * preset                     : Specify preset parameter to trade off performance and compression efficiency. 0...4 for HEVC. 0..1 for H264.
+ */
+typedef struct OMX_VIDEO_PARAM_HEVCTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_HEVCPROFILETYPE eProfile;
+    OMX_VIDEO_HEVCLEVELTYPE eLevel;
+    OMX_U32 nPFrames;
+    OMX_U32 nRefFrames;
+
+    OMX_U32 preset;         /* 0...4 for HEVC. 0..1 for H264. Trade off performance and compression efficiency */
+
+    OMX_U32 nBitDepthLuma;
+    OMX_U32 nBitDepthChroma;
+    OMX_S32 videoRange;
+    OMX_S32 sliceSize;
+    OMX_U32 num_tile_columns;
+    OMX_U32 num_tile_rows;
+    OMX_BOOL bEnableSAO;
+    OMX_S32 nTcOffset;
+    OMX_S32 nBetaOffset;
+    OMX_BOOL bEnableDeblockOverride;
+    OMX_BOOL bDeblockOverride;
+    int loop_filter_across_tiles_enabled_flag;
+
+    int vbr;
+    OMX_S32 qpMinI;
+    OMX_S32 qpMaxI;
+    OMX_S32 qpMinPB;
+    OMX_S32 qpMaxPB;
+    OMX_S32 tolMovingBitRate;
+    OMX_S32 monitorFrames;
+    OMX_S32 bitVarRangeI;
+    OMX_S32 bitVarRangeP;
+    OMX_S32 staticSceneIbitPercent;
+    OMX_S32 ctbRc;
+    OMX_S32 blockRCSize;
+    OMX_S32 tolCtbRcInter;
+    OMX_S32 tolCtbRcIntra;
+    OMX_S32 rcQpDeltaRange;
+    OMX_S32 rcBaseMBComplexity;
+    OMX_S32 ctbRowQpStep;
+    OMX_S32 picQpDeltaMin;
+    OMX_S32 picQpDeltaMax;
+	OMX_U32 hrdCpbSize;
+    OMX_S32 bitrateWindow;
+    OMX_S32 intraQpDelta;
+    OMX_S32 fixedIntraQp;
+    OMX_U32 chromaQpOffset;
+    OMX_S32 vui_timing_info_enable;
+
+    OMX_U32 gdrDuration;
+    OMX_U32 cirStart;
+    OMX_U32 cirInterval;
+    OMX_U32 roiMapDeltaQpBlockUnit;
+    OMX_U32 roiMapDeltaQpEnable;
+    OMX_U32 RoiQpDelta_ver;
+
+    OMX_BOOL bStrongIntraSmoothing;
+    int pcm_loop_filter_disabled_flag;
+
+    /*rerference frame compression*/
+    int rfcEnable;
+
+    OMX_BOOL bLowLatencyEncoding;
+
+
+    OMX_U32 nBFrames;
+    OMX_U32 fieldOrder;
+    OMX_BOOL bEnableScalingList;
+    OMX_S32 bitVarRangeB;
+    OMX_S32 smoothPsnrInGOP;
+    OMX_U32 gopSize;
+    OMX_U32 gopLowdelay;
+    OMX_U32 ipcmMapEnable;
+    OMX_U32 ssim;
+
+    OMX_U32 exp_of_input_alignment;
+    OMX_S32 firstPic;
+    OMX_S32 lastPic;
+
+
+    OMX_S32 hashtype;
+    OMX_U32 rdoLevel;
+    int enableRdoQuant;
+    int byteStream;
+    int enableCabac;
+    OMX_BOOL bCabacInitFlag;
+    int RpsInSliceHeader;
+    int picSkip;
+    OMX_U32 intraPicRate;
+    OMX_S32 cuInfoVersion;
+
+    /* Extension for CL244132*/
+    /*MMU*/
+    int mmuEnable;
+
+    /* coded chroma_format_idc */
+    OMX_U32 codedChromaIdc; // 0: 400, 1: 420, 2: 422
+
+    OMX_S32 crf;             /*CRF constant [0,51]*/
+
+    OMX_U32 streamMultiSegmentMode;
+    OMX_U32 streamMultiSegmentAmount;
+
+    OMX_S32 ltrInterval;
+    OMX_S32 longTermGapOffset;
+    OMX_S32 longTermGap;
+    OMX_S32 longTermQpDelta;
+
+    OMX_U32 noiseReductionEnable;
+    OMX_U32 noiseLow;
+    OMX_U32 noiseFirstFrameSigma;
+
+
+    OMX_U32 hdr10_display_enable;
+    OMX_U32 hdr10_dx0;
+    OMX_U32 hdr10_dy0;
+    OMX_U32 hdr10_dx1;
+    OMX_U32 hdr10_dy1;
+    OMX_U32 hdr10_dx2;
+    OMX_U32 hdr10_dy2;
+    OMX_U32 hdr10_wx;
+    OMX_U32 hdr10_wy;
+    OMX_U32 hdr10_maxluma;
+    OMX_U32 hdr10_minluma;
+    OMX_U32 hdr10_lightlevel_enable;
+    OMX_U32 hdr10_maxlight;
+    OMX_U32 hdr10_avglight;
+    OMX_U32 hdr10_color_enable;
+    OMX_U32 hdr10_primary;
+    OMX_U32 hdr10_transfer;
+    OMX_U32 hdr10_matrix;
+
+    /*external SRAM*/
+    OMX_U32 extSramLumHeightBwd;
+    OMX_U32 extSramChrHeightBwd;
+    OMX_U32 extSramLumHeightFwd;
+    OMX_U32 extSramChrHeightFwd;
+
+    /* AXI alignment */
+    OMX_U32 AXIAlignment; // bit[31:28] AXI_burst_align_wr_common
+                      // bit[27:24] AXI_burst_align_wr_stream
+                      // bit[23:20] AXI_burst_align_wr_chroma_ref
+                      // bit[19:16] AXI_burst_align_wr_luma_ref
+                      // bit[15:12] AXI_burst_align_rd_common
+                      // bit[11: 8] AXI_burst_align_rd_prp
+                      // bit[ 7: 4] AXI_burst_align_rd_ch_ref_prefetch
+                      // bit[ 3: 0] AXI_burst_align_rd_lu_ref_prefetch
+
+    /* Adaptive Quantization */
+    OMX_U32 aq_mode; /* Mode for Adaptive Quantization - 0:none 1:uniform AQ 2:auto variance 3:auto variance with bias to dark scenes. Default 0 */
+    OMX_U32 aq_strength; /* Reduces blocking and blurring in flat and textured areas (0 to 3.0). Default 1.00 */
+    OMX_U32 writeReconToDDR; /*HW write recon to DDR or not if it's pure I-frame encoding*/
+    OMX_U32 TxTypeSearchEnable; /*av1 tx type search 1=enable 0=disable, enabled by default*/
+
+    /*----*/
+    OMX_U32 PsyFactor;
+    OMX_U32 meVertSearchRange;
+	OMX_U32 layerInRefIdcEnable;
+} OMX_VIDEO_PARAM_HEVCTYPE;
+
+typedef struct OMX_VIDEO_PARAM_CODECFORMAT {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_CODINGTYPE nCodecFormat;
+} OMX_VIDEO_PARAM_CODECFORMAT;
+
+
+/** VP9 profiles */
+typedef enum OMX_VIDEO_VP9PROFILETYPE {
+    OMX_VIDEO_VP9Profile0 = 0x01, /* 8-bit 4:2:0 */
+    OMX_VIDEO_VP9Profile1 = 0x02, /* 8-bit 4:2:2, 4:4:4, alpha channel */
+    OMX_VIDEO_VP9Profile2 = 0x04, /* 10-bit/12-bit 4:2:0, YouTube Premium Content Profile */
+    OMX_VIDEO_VP9Profile3 = 0x08, /* 10-bit/12-bit 4:2:2, 4:4:4, alpha channel */
+    OMX_VIDEO_VP9ProfileUnknown = 0x6EFFFFFF,
+    OMX_VIDEO_VP9ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_VP9ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_VP9ProfileMax = 0x7FFFFFFF
+} OMX_VIDEO_VP9PROFILETYPE;
+
+/** VP9 Param */
+typedef struct OMX_VIDEO_PARAM_VP9TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_VP9PROFILETYPE eProfile;
+    OMX_U32 nBitDepthLuma;
+    OMX_U32 nBitDepthChroma;
+} OMX_VIDEO_PARAM_VP9TYPE;
+
+/** G2 Decoder pixel formats */
+typedef enum OMX_VIDEO_G2PIXELFORMAT {
+    OMX_VIDEO_G2PixelFormat_Default     = 0x0,
+    OMX_VIDEO_G2PixelFormat_8bit        = 0x01, /* 10 bit data is clamped to 8 bit per pixel */
+    OMX_VIDEO_G2PixelFormat_P010        = 0x02, /* MS P010 format */
+    OMX_VIDEO_G2PixelFormat_Custom1     = 0x03
+} OMX_VIDEO_G2PIXELFORMAT;
+
+typedef enum OMX_VIDEO_DECODER_MODE {
+  OMX_VIDEO_DEC_NORMAL = 0,
+  OMX_VIDEO_DEC_LOW_LATENCY = 1,
+  //OMX_VIDEO_DEC_LOW_LATENCY_RTL = 2,
+  OMX_VIDEO_DEC_SECURITY = 3
+} OMX_VIDEO_DECODER_MODE;
+
+/** Structure for configuring VC8000D decoder */
+typedef struct OMX_VIDEO_PARAM_CONFIGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnableTiled;          /* Store reference pictures in tiled format */
+    OMX_U32 nGuardSize;
+    OMX_BOOL bEnableAdaptiveBuffers;
+    OMX_VIDEO_G2PIXELFORMAT ePixelFormat;
+    OMX_BOOL bEnableRFC;
+    OMX_BOOL bDisableReordering;
+    OMX_BOOL bEnableRingBuffer;
+    OMX_VIDEO_DECODER_MODE eDecMode;
+} OMX_VIDEO_PARAM_CONFIGTYPE;
+
+typedef enum OMX_BUFFER_MODE {
+  OMX_BUFFER_MODE_NORMAL = 0,
+  OMX_BUFFER_MODE_DMA = 1,
+} OMX_BUFFER_MODE;
+
+/** Structure for configuring port buffer mode */
+typedef struct OMX_BUFFER_MODE_CONFIGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BUFFER_MODE eMode;
+} OMX_BUFFER_MODE_CONFIGTYPE;
+
+typedef enum OMX_COMPRESSION_MODE {
+  OMX_COMPRESSION_MODE_DISABLED = 0,
+  OMX_COMPRESSION_MODE_LOSSLESS = 1,
+} OMX_COMPRESSION_MODE;
+
+/** Structure for configuring port compression mode */
+typedef struct OMX_COMPRESSION_MODE_CONFIGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_COMPRESSION_MODE eMode;
+} OMX_COMPRESSION_MODE_CONFIGTYPE;
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif // _VSI_VENDOR_EXT_H_
diff --git a/libavutil/Makefile b/libavutil/Makefile
index 9b08372..cd61bde 100644
--- a/libavutil/Makefile
+++ b/libavutil/Makefile
@@ -46,7 +46,7 @@ HEADERS = adler32.h                                                     \
           hwcontext_videotoolbox.h                                      \
           hwcontext_vdpau.h                                             \
           hwcontext_vulkan.h                                            \
-          imgutils.h                                                    \
+	  imgutils.h                                                    \
           intfloat.h                                                    \
           intreadwrite.h                                                \
           lfg.h                                                         \
@@ -184,6 +184,7 @@ OBJS-$(CONFIG_VAAPI)                    += hwcontext_vaapi.o
 OBJS-$(CONFIG_VIDEOTOOLBOX)             += hwcontext_videotoolbox.o
 OBJS-$(CONFIG_VDPAU)                    += hwcontext_vdpau.o
 OBJS-$(CONFIG_VULKAN)                   += hwcontext_vulkan.o
+OBJS-$(CONFIG_OMX)                      += hwcontext_omx.o
 
 OBJS += $(COMPAT_OBJS:%=../compat/%)
 
diff --git a/libavutil/hwcontext.h b/libavutil/hwcontext.h
index 04d19d8..6ea3d04 100644
--- a/libavutil/hwcontext.h
+++ b/libavutil/hwcontext.h
@@ -37,6 +37,7 @@ enum AVHWDeviceType {
     AV_HWDEVICE_TYPE_OPENCL,
     AV_HWDEVICE_TYPE_MEDIACODEC,
     AV_HWDEVICE_TYPE_VULKAN,
+    AV_HWDEVICE_TYPE_OMX,
 };
 
 typedef struct AVHWDeviceInternal AVHWDeviceInternal;
diff --git a/libavutil/hwcontext_omx.c b/libavutil/hwcontext_omx.c
new file mode 100755
index 0000000..f0ff9ec
--- /dev/null
+++ b/libavutil/hwcontext_omx.c
@@ -0,0 +1,75 @@
+#include <dlfcn.h>
+
+#include "config.h"
+#include "buffer.h"
+#include "common.h"
+#include "hwcontext.h"
+#include "hwcontext_internal.h"
+//#include "hwcontext_omx.h"
+
+typedef struct OMXDeviceContext {
+    //AVOMXDeviceContext ctx;
+
+    void *libmedia;
+    //media_status_t (*create_surface)(ANativeWindow **surface);
+} OMXDeviceContext;
+
+
+static int omx_device_create(AVHWDeviceContext *ctx, const char *device,
+                             AVDictionary *opts, int flags)
+{
+    //const AVDictionaryEntry *entry = NULL;
+    //OMXDeviceContext *s = ctx->hwctx;
+    //AVOMXDeviceContext *dev = &s->ctx;
+
+    if (device && device[0]) {
+        av_log(ctx, AV_LOG_ERROR, "Device selection unsupported.\n");
+        return AVERROR_UNKNOWN;
+    }
+
+
+    return 0;
+}
+
+static int omx_device_init(AVHWDeviceContext *ctx)
+{
+    OMXDeviceContext *s = ctx->hwctx;
+    //AVOMXDeviceContext *dev = (AVOMXDeviceContext *)s;
+
+    s->libmedia = dlopen("libomxil-bellagio.so", RTLD_NOW);
+    if (!s->libmedia)
+        return AVERROR_UNKNOWN;
+
+    return 0;
+}
+
+static void omx_device_uninit(AVHWDeviceContext *ctx)
+{
+    OMXDeviceContext *s = ctx->hwctx;
+    //AVOMXDeviceContext *dev = ctx->hwctx;
+    if (!s->libmedia)
+        return;
+
+
+    dlclose(s->libmedia);
+    s->libmedia = NULL;
+}
+
+const HWContextType ff_hwcontext_type_OMX = {
+    .type                 = AV_HWDEVICE_TYPE_OMX,
+    .name                 = "openmax",
+
+    .device_hwctx_size    = sizeof(OMXDeviceContext),
+
+    .device_create        = omx_device_create,
+    .device_init          = omx_device_init,
+    .device_uninit        = omx_device_uninit,
+
+    .pix_fmts = (const enum AVPixelFormat[])
+    {
+        AV_PIX_FMT_NV12,
+        AV_PIX_FMT_NONE
+    },
+};
+
+
diff --git a/tests/api/Makefile b/tests/api/Makefile
index b5c4cca..9b4964e 100644
--- a/tests/api/Makefile
+++ b/tests/api/Makefile
@@ -1,10 +1,11 @@
 APITESTPROGS-$(call ENCDEC, FLAC, FLAC) += api-flac
 APITESTPROGS-$(call DEMDEC, H264, H264) += api-h264
 APITESTPROGS-$(call DEMDEC, H264, H264) += api-h264-slice
-APITESTPROGS-yes += api-seek
-APITESTPROGS-yes += api-codec-param
+#APITESTPROGS-yes += api-seek
+#APITESTPROGS-yes += api-codec-param
+APITESTPROGS-yes += api-dec 
 APITESTPROGS-$(call DEMDEC, H263, H263) += api-band
-APITESTPROGS-$(HAVE_THREADS) += api-threadmessage
+#APITESTPROGS-$(HAVE_THREADS) += api-threadmessage
 APITESTPROGS += $(APITESTPROGS-yes)
 
 APITESTOBJS  := $(APITESTOBJS:%=$(APITESTSDIR)%) $(APITESTPROGS:%=$(APITESTSDIR)/%-test.o)
@@ -15,6 +16,8 @@ $(APITESTOBJS): | $(sort $(dir $(APITESTOBJS)))
 $(APITESTOBJS) $(APITESTOBJS:.o=.i): CPPFLAGS += -DTEST
 $(APITESTOBJS) $(APITESTOBJS:.o=.i): CFLAGS += -Umain
 
+all:$(APITESTPROGS)
+
 $(APITESTPROGS): %$(EXESUF): %.o $(FF_DEP_LIBS)
 	$(LD) $(LDFLAGS) $(LDEXEFLAGS) $(LD_O) $(filter %.o,$^) $(FF_EXTRALIBS) $(ELIBS)
 
diff --git a/tests/api/api-dec-test.c b/tests/api/api-dec-test.c
new file mode 100644
index 0000000..5a8943a
--- /dev/null
+++ b/tests/api/api-dec-test.c
@@ -0,0 +1,169 @@
+#include <libavcodec/avcodec.h>
+#include <libavformat/avformat.h>
+#include <libavutil/imgutils.h>
+#include <math.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+#include<sys/time.h>
+
+int main(int argc, char* argv[]) {
+    //av_register_all();
+
+    AVFormatContext* fmt_ctx = NULL;
+    AVCodecContext* codec_ctx = NULL;
+    AVCodec* codec = NULL;
+    AVPacket pkt;
+    int ret = 0;
+    AVFrame* frame = NULL;
+    int FrameCount = 0;
+    int FrameNum = 0;
+    int video_stream_index = -1;
+    char outPath[10240];
+    snprintf(outPath, sizeof(outPath), "mkdir -p output");
+    struct timeval begin;
+    struct timeval end;
+    double duration;
+    FILE* fp=NULL;
+    int one_flag = 1;
+    int benchmark = 0;
+    double fps = 0;
+    int width = 0, height=0;
+    ret=system(outPath);
+    if(ret!=0){
+        fprintf(stderr, "Error: create output document failed.\n");
+        goto end;
+    }
+    if(argc > 3 && !strcmp(argv[3], "-b"))
+    {
+	benchmark = 1;
+    }
+    // Open input file
+    if (avformat_open_input(&fmt_ctx, argv[1], NULL, NULL) < 0) {
+        fprintf(stderr, "Error: Could not open input file.\n");
+        goto end;
+    }
+
+    // Retrieve stream information
+    if (avformat_find_stream_info(fmt_ctx, NULL) < 0) {
+        fprintf(stderr, "Error: Could not find stream information.\n");
+        goto end;
+    }
+
+    // Find the first video stream
+    for (int i = 0; i < fmt_ctx->nb_streams; i++) {
+        if (fmt_ctx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
+            video_stream_index = i;
+            break;
+        }
+    }
+
+    if (video_stream_index == -1) {
+        fprintf(stderr, "Error: Could not find video stream.\n");
+        goto end;
+    }
+    width = fmt_ctx->streams[video_stream_index]->codecpar->width;
+    height = fmt_ctx->streams[video_stream_index]->codecpar->height;
+    // Get a pointer to the codec context for the video stream
+    codec_ctx = avcodec_alloc_context3(NULL);
+    if (!codec_ctx) {
+        fprintf(stderr, "Error: Could not allocate codec context.\n");
+        goto end;
+    }
+    avcodec_parameters_to_context(codec_ctx, fmt_ctx->streams[video_stream_index]->codecpar);
+
+    // Find the decoder for the video stream
+    //codec = avcodec_find_decoder(codec_ctx->codec_id);
+    codec = avcodec_find_decoder_by_name(argv[2]);
+    if (!codec) {
+        fprintf(stderr, "Error: Could not find decoder.\n");
+        goto end;
+    }
+    // Open codec
+    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {
+        fprintf(stdout,"ok!\n");
+        fprintf(stderr, "Error: Could not open codec.\n");
+        goto end;
+    }
+    // Allocate video frame
+    frame = av_frame_alloc();
+    if (!frame) {
+        fprintf(stderr, "Error: Could not allocate video frame.\n");
+        goto end;
+    }
+
+    //start = clock();
+    //timer.reset();
+    gettimeofday(&begin,NULL);
+#if 1
+    // Read frames from the file
+    while (1) {
+
+        ret = av_read_frame(fmt_ctx, &pkt);
+        if(ret < 0 && one_flag==0)break;
+        if(ret < 0 && one_flag==1){
+            pkt.data = NULL;
+            pkt.size = 0;
+            pkt.stream_index = video_stream_index;
+            one_flag = 0;
+        }
+        // If this is a packet from the video stream, decode it
+        if (pkt.stream_index == video_stream_index) {
+            // Send packet to decoder
+                ret = avcodec_send_packet(codec_ctx, &pkt);
+	        if (ret< 0) {
+                    fprintf(stderr, "Error: Failed to send packet to decoder.\n");
+                    return 1;
+                }
+                FrameNum++;
+	    while(ret >= 0) {
+                ret = avcodec_receive_frame(codec_ctx, frame);
+                if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
+                    break;
+                } else if (ret < 0) {
+                    fprintf(stdout, "Error: Could not decode video frame.");
+                    return 1;
+                }
+                FrameCount++;
+                if(!benchmark)
+		{
+		    memset(outPath, 0, sizeof(outPath));
+		    snprintf(outPath, sizeof(outPath), "output/%d.yuv",FrameCount);
+		    fp = fopen(outPath, "wb");
+		    fwrite(frame->data[0], 1, frame->width * frame->height, fp);
+		    fwrite(frame->data[1], 1, frame->width * frame->height / 2, fp);
+		    fclose(fp);
+		    fprintf(stdout, "This is the %d frame received!\n", FrameCount);
+		}
+                //if(FrameCount==2)goto ok;
+    	    }
+        }
+
+   }
+#endif 
+    //sleep(3);
+    gettimeofday(&end,NULL);
+    //duration = (end.tv_sec-start.tv_sec)*1000000+(end.tv_usec-start.tv_usec);
+    //printf("%.3f\n", duration);
+#if 1
+ok:
+duration = (end.tv_sec-begin.tv_sec)*1000000+(end.tv_usec-begin.tv_usec);
+duration /= 1000000;
+fps = 1.0 * FrameCount / duration;
+if(benchmark)
+{
+    fprintf(stdout, "All Frame Decoded Finished. [Resolution]: %dx%d, [Frame Num]: %d, [FPS]: %.3f, [TIME]: %.3fs\n", width, height, FrameCount, fps, duration);
+}
+else
+{
+    fprintf(stdout, "All Frame Decoded Finished. [Resolution]: %dx%d, [Frame Num]: %d\n", width, height, FrameCount);
+}
+#endif
+end:
+    // Clean up
+    avformat_close_input(&fmt_ctx);
+    avcodec_free_context(&codec_ctx);
+    av_frame_free(&frame);
+    return 0;
+}
+
diff --git a/tests/api/compile-api-dec-test.sh b/tests/api/compile-api-dec-test.sh
new file mode 100644
index 0000000..056b065
--- /dev/null
+++ b/tests/api/compile-api-dec-test.sh
@@ -0,0 +1,4 @@
+echo "Please modify the --sysroot to the absolute path of the document and remove the # sign below!"
+#riscv64-linux-gcc -g -mcpu=c910 -fstack-protector-strong -O2 -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security --no-sysroot-suffix --sysroot=......./yocto/thead-build/light-fm/tmp-glibc/work/riscv64-oe-linux/ffmpeg/4.3.1-r0/recipe-sysroot api-dec-test.c -o api-dec-test \
+#-I../../../image/usr/include \
+#-L../../../image/usr/lib  -lavcodec -lavformat -lavutil -lswscale -lswresample -lavresample -ldl
-- 
2.17.1

